
BTL_LUMI_INTERN.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006760  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0001127c  08006900  08006900  00016900  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08017b7c  08017b7c  0003011c  2**0
                  CONTENTS
  4 .ARM          00000000  08017b7c  08017b7c  0003011c  2**0
                  CONTENTS
  5 .preinit_array 00000000  08017b7c  08017b7c  0003011c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08017b7c  08017b7c  00027b7c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08017b80  08017b80  00027b80  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000011c  20000000  08017b84  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00001614  2000011c  08017ca0  0003011c  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20001730  08017ca0  00031730  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0003011c  2**0
                  CONTENTS, READONLY
 12 .comment      00000043  00000000  00000000  0003014c  2**0
                  CONTENTS, READONLY
 13 .debug_info   00019274  00000000  00000000  0003018f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000041b8  00000000  00000000  00049403  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001240  00000000  00000000  0004d5c0  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00000d3e  00000000  00000000  0004e800  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0000fa23  00000000  00000000  0004f53e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00013b79  00000000  00000000  0005ef61  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00051c24  00000000  00000000  00072ada  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_frame  00004d60  00000000  00000000  000c4700  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000050  00000000  00000000  000c9460  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	2000011c 	.word	0x2000011c
 80001bc:	00000000 	.word	0x00000000
 80001c0:	080068e8 	.word	0x080068e8

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000120 	.word	0x20000120
 80001dc:	080068e8 	.word	0x080068e8

080001e0 <memchr>:
 80001e0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 80001e4:	2a10      	cmp	r2, #16
 80001e6:	db2b      	blt.n	8000240 <memchr+0x60>
 80001e8:	f010 0f07 	tst.w	r0, #7
 80001ec:	d008      	beq.n	8000200 <memchr+0x20>
 80001ee:	f810 3b01 	ldrb.w	r3, [r0], #1
 80001f2:	3a01      	subs	r2, #1
 80001f4:	428b      	cmp	r3, r1
 80001f6:	d02d      	beq.n	8000254 <memchr+0x74>
 80001f8:	f010 0f07 	tst.w	r0, #7
 80001fc:	b342      	cbz	r2, 8000250 <memchr+0x70>
 80001fe:	d1f6      	bne.n	80001ee <memchr+0xe>
 8000200:	b4f0      	push	{r4, r5, r6, r7}
 8000202:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000206:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800020a:	f022 0407 	bic.w	r4, r2, #7
 800020e:	f07f 0700 	mvns.w	r7, #0
 8000212:	2300      	movs	r3, #0
 8000214:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000218:	3c08      	subs	r4, #8
 800021a:	ea85 0501 	eor.w	r5, r5, r1
 800021e:	ea86 0601 	eor.w	r6, r6, r1
 8000222:	fa85 f547 	uadd8	r5, r5, r7
 8000226:	faa3 f587 	sel	r5, r3, r7
 800022a:	fa86 f647 	uadd8	r6, r6, r7
 800022e:	faa5 f687 	sel	r6, r5, r7
 8000232:	b98e      	cbnz	r6, 8000258 <memchr+0x78>
 8000234:	d1ee      	bne.n	8000214 <memchr+0x34>
 8000236:	bcf0      	pop	{r4, r5, r6, r7}
 8000238:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800023c:	f002 0207 	and.w	r2, r2, #7
 8000240:	b132      	cbz	r2, 8000250 <memchr+0x70>
 8000242:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000246:	3a01      	subs	r2, #1
 8000248:	ea83 0301 	eor.w	r3, r3, r1
 800024c:	b113      	cbz	r3, 8000254 <memchr+0x74>
 800024e:	d1f8      	bne.n	8000242 <memchr+0x62>
 8000250:	2000      	movs	r0, #0
 8000252:	4770      	bx	lr
 8000254:	3801      	subs	r0, #1
 8000256:	4770      	bx	lr
 8000258:	2d00      	cmp	r5, #0
 800025a:	bf06      	itte	eq
 800025c:	4635      	moveq	r5, r6
 800025e:	3803      	subeq	r0, #3
 8000260:	3807      	subne	r0, #7
 8000262:	f015 0f01 	tst.w	r5, #1
 8000266:	d107      	bne.n	8000278 <memchr+0x98>
 8000268:	3001      	adds	r0, #1
 800026a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800026e:	bf02      	ittt	eq
 8000270:	3001      	addeq	r0, #1
 8000272:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000276:	3001      	addeq	r0, #1
 8000278:	bcf0      	pop	{r4, r5, r6, r7}
 800027a:	3801      	subs	r0, #1
 800027c:	4770      	bx	lr
 800027e:	bf00      	nop

08000280 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 8000280:	b580      	push	{r7, lr}
 8000282:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8000284:	4b16      	ldr	r3, [pc, #88]	; (80002e0 <SystemInit+0x60>)
 8000286:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800028a:	4a15      	ldr	r2, [pc, #84]	; (80002e0 <SystemInit+0x60>)
 800028c:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8000290:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8000294:	4b13      	ldr	r3, [pc, #76]	; (80002e4 <SystemInit+0x64>)
 8000296:	681b      	ldr	r3, [r3, #0]
 8000298:	4a12      	ldr	r2, [pc, #72]	; (80002e4 <SystemInit+0x64>)
 800029a:	f043 0301 	orr.w	r3, r3, #1
 800029e:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80002a0:	4b10      	ldr	r3, [pc, #64]	; (80002e4 <SystemInit+0x64>)
 80002a2:	2200      	movs	r2, #0
 80002a4:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80002a6:	4b0f      	ldr	r3, [pc, #60]	; (80002e4 <SystemInit+0x64>)
 80002a8:	681b      	ldr	r3, [r3, #0]
 80002aa:	4a0e      	ldr	r2, [pc, #56]	; (80002e4 <SystemInit+0x64>)
 80002ac:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 80002b0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80002b4:	6013      	str	r3, [r2, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80002b6:	4b0b      	ldr	r3, [pc, #44]	; (80002e4 <SystemInit+0x64>)
 80002b8:	4a0b      	ldr	r2, [pc, #44]	; (80002e8 <SystemInit+0x68>)
 80002ba:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80002bc:	4b09      	ldr	r3, [pc, #36]	; (80002e4 <SystemInit+0x64>)
 80002be:	681b      	ldr	r3, [r3, #0]
 80002c0:	4a08      	ldr	r2, [pc, #32]	; (80002e4 <SystemInit+0x64>)
 80002c2:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80002c6:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80002c8:	4b06      	ldr	r3, [pc, #24]	; (80002e4 <SystemInit+0x64>)
 80002ca:	2200      	movs	r2, #0
 80002cc:	60da      	str	r2, [r3, #12]
  SystemInit_ExtMemCtl(); 
#endif /* DATA_IN_ExtSRAM */
         
  /* Configure the System clock source, PLL Multiplier and Divider factors, 
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  SetSysClock();
 80002ce:	f000 f88f 	bl	80003f0 <SetSysClock>

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80002d2:	4b03      	ldr	r3, [pc, #12]	; (80002e0 <SystemInit+0x60>)
 80002d4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80002d8:	609a      	str	r2, [r3, #8]
#endif
}
 80002da:	bf00      	nop
 80002dc:	bd80      	pop	{r7, pc}
 80002de:	bf00      	nop
 80002e0:	e000ed00 	.word	0xe000ed00
 80002e4:	40023800 	.word	0x40023800
 80002e8:	24003010 	.word	0x24003010

080002ec <SystemCoreClockUpdate>:
  *     
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
 80002ec:	b480      	push	{r7}
 80002ee:	b087      	sub	sp, #28
 80002f0:	af00      	add	r7, sp, #0
  uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 80002f2:	2300      	movs	r3, #0
 80002f4:	613b      	str	r3, [r7, #16]
 80002f6:	2300      	movs	r3, #0
 80002f8:	617b      	str	r3, [r7, #20]
 80002fa:	2302      	movs	r3, #2
 80002fc:	60fb      	str	r3, [r7, #12]
 80002fe:	2300      	movs	r3, #0
 8000300:	60bb      	str	r3, [r7, #8]
 8000302:	2302      	movs	r3, #2
 8000304:	607b      	str	r3, [r7, #4]

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000306:	4b35      	ldr	r3, [pc, #212]	; (80003dc <SystemCoreClockUpdate+0xf0>)
 8000308:	689b      	ldr	r3, [r3, #8]
 800030a:	f003 030c 	and.w	r3, r3, #12
 800030e:	613b      	str	r3, [r7, #16]

  switch (tmp)
 8000310:	693b      	ldr	r3, [r7, #16]
 8000312:	2b08      	cmp	r3, #8
 8000314:	d011      	beq.n	800033a <SystemCoreClockUpdate+0x4e>
 8000316:	693b      	ldr	r3, [r7, #16]
 8000318:	2b08      	cmp	r3, #8
 800031a:	d844      	bhi.n	80003a6 <SystemCoreClockUpdate+0xba>
 800031c:	693b      	ldr	r3, [r7, #16]
 800031e:	2b00      	cmp	r3, #0
 8000320:	d003      	beq.n	800032a <SystemCoreClockUpdate+0x3e>
 8000322:	693b      	ldr	r3, [r7, #16]
 8000324:	2b04      	cmp	r3, #4
 8000326:	d004      	beq.n	8000332 <SystemCoreClockUpdate+0x46>
 8000328:	e03d      	b.n	80003a6 <SystemCoreClockUpdate+0xba>
  {
    case 0x00:  /* HSI used as system clock source */
      SystemCoreClock = HSI_VALUE;
 800032a:	4b2d      	ldr	r3, [pc, #180]	; (80003e0 <SystemCoreClockUpdate+0xf4>)
 800032c:	4a2d      	ldr	r2, [pc, #180]	; (80003e4 <SystemCoreClockUpdate+0xf8>)
 800032e:	601a      	str	r2, [r3, #0]
      break;
 8000330:	e03d      	b.n	80003ae <SystemCoreClockUpdate+0xc2>
    case 0x04:  /* HSE used as system clock source */
      SystemCoreClock = HSE_VALUE;
 8000332:	4b2b      	ldr	r3, [pc, #172]	; (80003e0 <SystemCoreClockUpdate+0xf4>)
 8000334:	4a2c      	ldr	r2, [pc, #176]	; (80003e8 <SystemCoreClockUpdate+0xfc>)
 8000336:	601a      	str	r2, [r3, #0]
      break;
 8000338:	e039      	b.n	80003ae <SystemCoreClockUpdate+0xc2>
    case 0x08:  /* PLL used as system clock source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
         SYSCLK = PLL_VCO / PLL_P
         */    
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 800033a:	4b28      	ldr	r3, [pc, #160]	; (80003dc <SystemCoreClockUpdate+0xf0>)
 800033c:	685b      	ldr	r3, [r3, #4]
 800033e:	0d9b      	lsrs	r3, r3, #22
 8000340:	f003 0301 	and.w	r3, r3, #1
 8000344:	60bb      	str	r3, [r7, #8]
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000346:	4b25      	ldr	r3, [pc, #148]	; (80003dc <SystemCoreClockUpdate+0xf0>)
 8000348:	685b      	ldr	r3, [r3, #4]
 800034a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800034e:	607b      	str	r3, [r7, #4]
      
      if (pllsource != 0)
 8000350:	68bb      	ldr	r3, [r7, #8]
 8000352:	2b00      	cmp	r3, #0
 8000354:	d00c      	beq.n	8000370 <SystemCoreClockUpdate+0x84>
      {
        /* HSE used as PLL clock source */
        pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000356:	4a24      	ldr	r2, [pc, #144]	; (80003e8 <SystemCoreClockUpdate+0xfc>)
 8000358:	687b      	ldr	r3, [r7, #4]
 800035a:	fbb2 f3f3 	udiv	r3, r2, r3
 800035e:	4a1f      	ldr	r2, [pc, #124]	; (80003dc <SystemCoreClockUpdate+0xf0>)
 8000360:	6852      	ldr	r2, [r2, #4]
 8000362:	0992      	lsrs	r2, r2, #6
 8000364:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8000368:	fb02 f303 	mul.w	r3, r2, r3
 800036c:	617b      	str	r3, [r7, #20]
 800036e:	e00b      	b.n	8000388 <SystemCoreClockUpdate+0x9c>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000370:	4a1c      	ldr	r2, [pc, #112]	; (80003e4 <SystemCoreClockUpdate+0xf8>)
 8000372:	687b      	ldr	r3, [r7, #4]
 8000374:	fbb2 f3f3 	udiv	r3, r2, r3
 8000378:	4a18      	ldr	r2, [pc, #96]	; (80003dc <SystemCoreClockUpdate+0xf0>)
 800037a:	6852      	ldr	r2, [r2, #4]
 800037c:	0992      	lsrs	r2, r2, #6
 800037e:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8000382:	fb02 f303 	mul.w	r3, r2, r3
 8000386:	617b      	str	r3, [r7, #20]
      }

      pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8000388:	4b14      	ldr	r3, [pc, #80]	; (80003dc <SystemCoreClockUpdate+0xf0>)
 800038a:	685b      	ldr	r3, [r3, #4]
 800038c:	0c1b      	lsrs	r3, r3, #16
 800038e:	f003 0303 	and.w	r3, r3, #3
 8000392:	3301      	adds	r3, #1
 8000394:	005b      	lsls	r3, r3, #1
 8000396:	60fb      	str	r3, [r7, #12]
      SystemCoreClock = pllvco/pllp;
 8000398:	697a      	ldr	r2, [r7, #20]
 800039a:	68fb      	ldr	r3, [r7, #12]
 800039c:	fbb2 f3f3 	udiv	r3, r2, r3
 80003a0:	4a0f      	ldr	r2, [pc, #60]	; (80003e0 <SystemCoreClockUpdate+0xf4>)
 80003a2:	6013      	str	r3, [r2, #0]
      break;
 80003a4:	e003      	b.n	80003ae <SystemCoreClockUpdate+0xc2>
    default:
      SystemCoreClock = HSI_VALUE;
 80003a6:	4b0e      	ldr	r3, [pc, #56]	; (80003e0 <SystemCoreClockUpdate+0xf4>)
 80003a8:	4a0e      	ldr	r2, [pc, #56]	; (80003e4 <SystemCoreClockUpdate+0xf8>)
 80003aa:	601a      	str	r2, [r3, #0]
      break;
 80003ac:	bf00      	nop
  }
  /* Compute HCLK frequency --------------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80003ae:	4b0b      	ldr	r3, [pc, #44]	; (80003dc <SystemCoreClockUpdate+0xf0>)
 80003b0:	689b      	ldr	r3, [r3, #8]
 80003b2:	091b      	lsrs	r3, r3, #4
 80003b4:	f003 030f 	and.w	r3, r3, #15
 80003b8:	4a0c      	ldr	r2, [pc, #48]	; (80003ec <SystemCoreClockUpdate+0x100>)
 80003ba:	5cd3      	ldrb	r3, [r2, r3]
 80003bc:	b2db      	uxtb	r3, r3
 80003be:	613b      	str	r3, [r7, #16]
  /* HCLK frequency */
  SystemCoreClock >>= tmp;
 80003c0:	4b07      	ldr	r3, [pc, #28]	; (80003e0 <SystemCoreClockUpdate+0xf4>)
 80003c2:	681a      	ldr	r2, [r3, #0]
 80003c4:	693b      	ldr	r3, [r7, #16]
 80003c6:	fa22 f303 	lsr.w	r3, r2, r3
 80003ca:	4a05      	ldr	r2, [pc, #20]	; (80003e0 <SystemCoreClockUpdate+0xf4>)
 80003cc:	6013      	str	r3, [r2, #0]
}
 80003ce:	bf00      	nop
 80003d0:	371c      	adds	r7, #28
 80003d2:	46bd      	mov	sp, r7
 80003d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80003d8:	4770      	bx	lr
 80003da:	bf00      	nop
 80003dc:	40023800 	.word	0x40023800
 80003e0:	20000000 	.word	0x20000000
 80003e4:	00f42400 	.word	0x00f42400
 80003e8:	017d7840 	.word	0x017d7840
 80003ec:	20000004 	.word	0x20000004

080003f0 <SetSysClock>:
  *         is reset to the default reset state (done in SystemInit() function).   
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
 80003f0:	b480      	push	{r7}
 80003f2:	af00      	add	r7, sp, #0
/******************************************************************************/

  /* At this stage the HSI is already enabled and used as System clock source */

    /* Select regulator voltage output Scale 1 mode, System frequency up to 168 MHz */
    RCC->APB1ENR |= RCC_APB1ENR_PWREN;
 80003f4:	4b23      	ldr	r3, [pc, #140]	; (8000484 <SetSysClock+0x94>)
 80003f6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80003f8:	4a22      	ldr	r2, [pc, #136]	; (8000484 <SetSysClock+0x94>)
 80003fa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80003fe:	6413      	str	r3, [r2, #64]	; 0x40
    PWR->CR |= PWR_CR_VOS;
 8000400:	4b21      	ldr	r3, [pc, #132]	; (8000488 <SetSysClock+0x98>)
 8000402:	681b      	ldr	r3, [r3, #0]
 8000404:	4a20      	ldr	r2, [pc, #128]	; (8000488 <SetSysClock+0x98>)
 8000406:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800040a:	6013      	str	r3, [r2, #0]

  /* HCLK = SYSCLK / 1*/
  RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
 800040c:	4b1d      	ldr	r3, [pc, #116]	; (8000484 <SetSysClock+0x94>)
 800040e:	4a1d      	ldr	r2, [pc, #116]	; (8000484 <SetSysClock+0x94>)
 8000410:	689b      	ldr	r3, [r3, #8]
 8000412:	6093      	str	r3, [r2, #8]

  /* PCLK2 = HCLK / 1*/
  RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;
 8000414:	4b1b      	ldr	r3, [pc, #108]	; (8000484 <SetSysClock+0x94>)
 8000416:	4a1b      	ldr	r2, [pc, #108]	; (8000484 <SetSysClock+0x94>)
 8000418:	689b      	ldr	r3, [r3, #8]
 800041a:	6093      	str	r3, [r2, #8]
    
  /* PCLK1 = HCLK / 1*/
  RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
 800041c:	4b19      	ldr	r3, [pc, #100]	; (8000484 <SetSysClock+0x94>)
 800041e:	689b      	ldr	r3, [r3, #8]
 8000420:	4a18      	ldr	r2, [pc, #96]	; (8000484 <SetSysClock+0x94>)
 8000422:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000426:	6093      	str	r3, [r2, #8]

  /* Configure the main PLL */
  RCC->PLLCFGR = PLL_M | (PLL_N << 6) | (((PLL_P >> 1) -1) << 16) |
 8000428:	4b16      	ldr	r3, [pc, #88]	; (8000484 <SetSysClock+0x94>)
 800042a:	4a18      	ldr	r2, [pc, #96]	; (800048c <SetSysClock+0x9c>)
 800042c:	605a      	str	r2, [r3, #4]
                 (RCC_PLLCFGR_PLLSRC_HSI) | (PLL_Q << 24);

  /* Enable the main PLL */
  RCC->CR |= RCC_CR_PLLON;
 800042e:	4b15      	ldr	r3, [pc, #84]	; (8000484 <SetSysClock+0x94>)
 8000430:	681b      	ldr	r3, [r3, #0]
 8000432:	4a14      	ldr	r2, [pc, #80]	; (8000484 <SetSysClock+0x94>)
 8000434:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000438:	6013      	str	r3, [r2, #0]

  /* Wait till the main PLL is ready */
  while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800043a:	bf00      	nop
 800043c:	4b11      	ldr	r3, [pc, #68]	; (8000484 <SetSysClock+0x94>)
 800043e:	681b      	ldr	r3, [r3, #0]
 8000440:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8000444:	2b00      	cmp	r3, #0
 8000446:	d0f9      	beq.n	800043c <SetSysClock+0x4c>
  {
  }
   
  /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
  FLASH->ACR = FLASH_ACR_ICEN |FLASH_ACR_DCEN |FLASH_ACR_LATENCY_2WS;
 8000448:	4b11      	ldr	r3, [pc, #68]	; (8000490 <SetSysClock+0xa0>)
 800044a:	f240 6202 	movw	r2, #1538	; 0x602
 800044e:	601a      	str	r2, [r3, #0]

  /* Select the main PLL as system clock source */
  RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8000450:	4b0c      	ldr	r3, [pc, #48]	; (8000484 <SetSysClock+0x94>)
 8000452:	689b      	ldr	r3, [r3, #8]
 8000454:	4a0b      	ldr	r2, [pc, #44]	; (8000484 <SetSysClock+0x94>)
 8000456:	f023 0303 	bic.w	r3, r3, #3
 800045a:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SW_PLL;
 800045c:	4b09      	ldr	r3, [pc, #36]	; (8000484 <SetSysClock+0x94>)
 800045e:	689b      	ldr	r3, [r3, #8]
 8000460:	4a08      	ldr	r2, [pc, #32]	; (8000484 <SetSysClock+0x94>)
 8000462:	f043 0302 	orr.w	r3, r3, #2
 8000466:	6093      	str	r3, [r2, #8]

  /* Wait till the main PLL is used as system clock source */
  while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
 8000468:	bf00      	nop
 800046a:	4b06      	ldr	r3, [pc, #24]	; (8000484 <SetSysClock+0x94>)
 800046c:	689b      	ldr	r3, [r3, #8]
 800046e:	f003 030c 	and.w	r3, r3, #12
 8000472:	2b08      	cmp	r3, #8
 8000474:	d1f9      	bne.n	800046a <SetSysClock+0x7a>
}
 8000476:	bf00      	nop
 8000478:	bf00      	nop
 800047a:	46bd      	mov	sp, r7
 800047c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000480:	4770      	bx	lr
 8000482:	bf00      	nop
 8000484:	40023800 	.word	0x40023800
 8000488:	40007000 	.word	0x40007000
 800048c:	08015410 	.word	0x08015410
 8000490:	40023c00 	.word	0x40023c00

08000494 <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8000494:	b480      	push	{r7}
 8000496:	b087      	sub	sp, #28
 8000498:	af00      	add	r7, sp, #0
 800049a:	6078      	str	r0, [r7, #4]
 800049c:	6039      	str	r1, [r7, #0]
  uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
 800049e:	2300      	movs	r3, #0
 80004a0:	617b      	str	r3, [r7, #20]
 80004a2:	2300      	movs	r3, #0
 80004a4:	613b      	str	r3, [r7, #16]
 80004a6:	2300      	movs	r3, #0
 80004a8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /* ------------------------- Configure the port pins ---------------- */
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80004aa:	2300      	movs	r3, #0
 80004ac:	617b      	str	r3, [r7, #20]
 80004ae:	e076      	b.n	800059e <GPIO_Init+0x10a>
  {
    pos = ((uint32_t)0x01) << pinpos;
 80004b0:	2201      	movs	r2, #1
 80004b2:	697b      	ldr	r3, [r7, #20]
 80004b4:	fa02 f303 	lsl.w	r3, r2, r3
 80004b8:	613b      	str	r3, [r7, #16]
    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80004ba:	683b      	ldr	r3, [r7, #0]
 80004bc:	681b      	ldr	r3, [r3, #0]
 80004be:	693a      	ldr	r2, [r7, #16]
 80004c0:	4013      	ands	r3, r2
 80004c2:	60fb      	str	r3, [r7, #12]

    if (currentpin == pos)
 80004c4:	68fa      	ldr	r2, [r7, #12]
 80004c6:	693b      	ldr	r3, [r7, #16]
 80004c8:	429a      	cmp	r2, r3
 80004ca:	d165      	bne.n	8000598 <GPIO_Init+0x104>
    {
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80004cc:	687b      	ldr	r3, [r7, #4]
 80004ce:	681a      	ldr	r2, [r3, #0]
 80004d0:	697b      	ldr	r3, [r7, #20]
 80004d2:	005b      	lsls	r3, r3, #1
 80004d4:	2103      	movs	r1, #3
 80004d6:	fa01 f303 	lsl.w	r3, r1, r3
 80004da:	43db      	mvns	r3, r3
 80004dc:	401a      	ands	r2, r3
 80004de:	687b      	ldr	r3, [r7, #4]
 80004e0:	601a      	str	r2, [r3, #0]
      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80004e2:	687b      	ldr	r3, [r7, #4]
 80004e4:	681a      	ldr	r2, [r3, #0]
 80004e6:	683b      	ldr	r3, [r7, #0]
 80004e8:	791b      	ldrb	r3, [r3, #4]
 80004ea:	4619      	mov	r1, r3
 80004ec:	697b      	ldr	r3, [r7, #20]
 80004ee:	005b      	lsls	r3, r3, #1
 80004f0:	fa01 f303 	lsl.w	r3, r1, r3
 80004f4:	431a      	orrs	r2, r3
 80004f6:	687b      	ldr	r3, [r7, #4]
 80004f8:	601a      	str	r2, [r3, #0]

      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80004fa:	683b      	ldr	r3, [r7, #0]
 80004fc:	791b      	ldrb	r3, [r3, #4]
 80004fe:	2b01      	cmp	r3, #1
 8000500:	d003      	beq.n	800050a <GPIO_Init+0x76>
 8000502:	683b      	ldr	r3, [r7, #0]
 8000504:	791b      	ldrb	r3, [r3, #4]
 8000506:	2b02      	cmp	r3, #2
 8000508:	d12e      	bne.n	8000568 <GPIO_Init+0xd4>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 800050a:	687b      	ldr	r3, [r7, #4]
 800050c:	689a      	ldr	r2, [r3, #8]
 800050e:	697b      	ldr	r3, [r7, #20]
 8000510:	005b      	lsls	r3, r3, #1
 8000512:	2103      	movs	r1, #3
 8000514:	fa01 f303 	lsl.w	r3, r1, r3
 8000518:	43db      	mvns	r3, r3
 800051a:	401a      	ands	r2, r3
 800051c:	687b      	ldr	r3, [r7, #4]
 800051e:	609a      	str	r2, [r3, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8000520:	687b      	ldr	r3, [r7, #4]
 8000522:	689a      	ldr	r2, [r3, #8]
 8000524:	683b      	ldr	r3, [r7, #0]
 8000526:	795b      	ldrb	r3, [r3, #5]
 8000528:	4619      	mov	r1, r3
 800052a:	697b      	ldr	r3, [r7, #20]
 800052c:	005b      	lsls	r3, r3, #1
 800052e:	fa01 f303 	lsl.w	r3, r1, r3
 8000532:	431a      	orrs	r2, r3
 8000534:	687b      	ldr	r3, [r7, #4]
 8000536:	609a      	str	r2, [r3, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration*/
        GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
 8000538:	687b      	ldr	r3, [r7, #4]
 800053a:	685a      	ldr	r2, [r3, #4]
 800053c:	697b      	ldr	r3, [r7, #20]
 800053e:	b29b      	uxth	r3, r3
 8000540:	4619      	mov	r1, r3
 8000542:	2301      	movs	r3, #1
 8000544:	408b      	lsls	r3, r1
 8000546:	43db      	mvns	r3, r3
 8000548:	401a      	ands	r2, r3
 800054a:	687b      	ldr	r3, [r7, #4]
 800054c:	605a      	str	r2, [r3, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 800054e:	687b      	ldr	r3, [r7, #4]
 8000550:	685b      	ldr	r3, [r3, #4]
 8000552:	683a      	ldr	r2, [r7, #0]
 8000554:	7992      	ldrb	r2, [r2, #6]
 8000556:	4611      	mov	r1, r2
 8000558:	697a      	ldr	r2, [r7, #20]
 800055a:	b292      	uxth	r2, r2
 800055c:	fa01 f202 	lsl.w	r2, r1, r2
 8000560:	b292      	uxth	r2, r2
 8000562:	431a      	orrs	r2, r3
 8000564:	687b      	ldr	r3, [r7, #4]
 8000566:	605a      	str	r2, [r3, #4]
      }

      /* Pull-up Pull down resistor configuration*/
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8000568:	687b      	ldr	r3, [r7, #4]
 800056a:	68da      	ldr	r2, [r3, #12]
 800056c:	697b      	ldr	r3, [r7, #20]
 800056e:	b29b      	uxth	r3, r3
 8000570:	005b      	lsls	r3, r3, #1
 8000572:	2103      	movs	r1, #3
 8000574:	fa01 f303 	lsl.w	r3, r1, r3
 8000578:	43db      	mvns	r3, r3
 800057a:	401a      	ands	r2, r3
 800057c:	687b      	ldr	r3, [r7, #4]
 800057e:	60da      	str	r2, [r3, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 8000580:	687b      	ldr	r3, [r7, #4]
 8000582:	68da      	ldr	r2, [r3, #12]
 8000584:	683b      	ldr	r3, [r7, #0]
 8000586:	79db      	ldrb	r3, [r3, #7]
 8000588:	4619      	mov	r1, r3
 800058a:	697b      	ldr	r3, [r7, #20]
 800058c:	005b      	lsls	r3, r3, #1
 800058e:	fa01 f303 	lsl.w	r3, r1, r3
 8000592:	431a      	orrs	r2, r3
 8000594:	687b      	ldr	r3, [r7, #4]
 8000596:	60da      	str	r2, [r3, #12]
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8000598:	697b      	ldr	r3, [r7, #20]
 800059a:	3301      	adds	r3, #1
 800059c:	617b      	str	r3, [r7, #20]
 800059e:	697b      	ldr	r3, [r7, #20]
 80005a0:	2b0f      	cmp	r3, #15
 80005a2:	d985      	bls.n	80004b0 <GPIO_Init+0x1c>
    }
  }
}
 80005a4:	bf00      	nop
 80005a6:	bf00      	nop
 80005a8:	371c      	adds	r7, #28
 80005aa:	46bd      	mov	sp, r7
 80005ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80005b0:	4770      	bx	lr

080005b2 <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80005b2:	b480      	push	{r7}
 80005b4:	b085      	sub	sp, #20
 80005b6:	af00      	add	r7, sp, #0
 80005b8:	6078      	str	r0, [r7, #4]
 80005ba:	460b      	mov	r3, r1
 80005bc:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 80005be:	2300      	movs	r3, #0
 80005c0:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 80005c2:	687b      	ldr	r3, [r7, #4]
 80005c4:	691a      	ldr	r2, [r3, #16]
 80005c6:	887b      	ldrh	r3, [r7, #2]
 80005c8:	4013      	ands	r3, r2
 80005ca:	2b00      	cmp	r3, #0
 80005cc:	d002      	beq.n	80005d4 <GPIO_ReadInputDataBit+0x22>
  {
    bitstatus = (uint8_t)Bit_SET;
 80005ce:	2301      	movs	r3, #1
 80005d0:	73fb      	strb	r3, [r7, #15]
 80005d2:	e001      	b.n	80005d8 <GPIO_ReadInputDataBit+0x26>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 80005d4:	2300      	movs	r3, #0
 80005d6:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 80005d8:	7bfb      	ldrb	r3, [r7, #15]
}
 80005da:	4618      	mov	r0, r3
 80005dc:	3714      	adds	r7, #20
 80005de:	46bd      	mov	sp, r7
 80005e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80005e4:	4770      	bx	lr

080005e6 <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 80005e6:	b480      	push	{r7}
 80005e8:	b083      	sub	sp, #12
 80005ea:	af00      	add	r7, sp, #0
 80005ec:	6078      	str	r0, [r7, #4]
 80005ee:	460b      	mov	r3, r1
 80005f0:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRL = GPIO_Pin;
 80005f2:	687b      	ldr	r3, [r7, #4]
 80005f4:	887a      	ldrh	r2, [r7, #2]
 80005f6:	831a      	strh	r2, [r3, #24]
}
 80005f8:	bf00      	nop
 80005fa:	370c      	adds	r7, #12
 80005fc:	46bd      	mov	sp, r7
 80005fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000602:	4770      	bx	lr

08000604 <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8000604:	b480      	push	{r7}
 8000606:	b083      	sub	sp, #12
 8000608:	af00      	add	r7, sp, #0
 800060a:	6078      	str	r0, [r7, #4]
 800060c:	460b      	mov	r3, r1
 800060e:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->BSRRH = GPIO_Pin;
 8000610:	687b      	ldr	r3, [r7, #4]
 8000612:	887a      	ldrh	r2, [r7, #2]
 8000614:	835a      	strh	r2, [r3, #26]
}
 8000616:	bf00      	nop
 8000618:	370c      	adds	r7, #12
 800061a:	46bd      	mov	sp, r7
 800061c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000620:	4770      	bx	lr

08000622 <GPIO_WriteBit>:
  *            @arg Bit_RESET: to clear the port pin
  *            @arg Bit_SET: to set the port pin
  * @retval None
  */
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
{
 8000622:	b480      	push	{r7}
 8000624:	b083      	sub	sp, #12
 8000626:	af00      	add	r7, sp, #0
 8000628:	6078      	str	r0, [r7, #4]
 800062a:	460b      	mov	r3, r1
 800062c:	807b      	strh	r3, [r7, #2]
 800062e:	4613      	mov	r3, r2
 8000630:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));

  if (BitVal != Bit_RESET)
 8000632:	787b      	ldrb	r3, [r7, #1]
 8000634:	2b00      	cmp	r3, #0
 8000636:	d003      	beq.n	8000640 <GPIO_WriteBit+0x1e>
  {
    GPIOx->BSRRL = GPIO_Pin;
 8000638:	687b      	ldr	r3, [r7, #4]
 800063a:	887a      	ldrh	r2, [r7, #2]
 800063c:	831a      	strh	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRRH = GPIO_Pin ;
  }
}
 800063e:	e002      	b.n	8000646 <GPIO_WriteBit+0x24>
    GPIOx->BSRRH = GPIO_Pin ;
 8000640:	687b      	ldr	r3, [r7, #4]
 8000642:	887a      	ldrh	r2, [r7, #2]
 8000644:	835a      	strh	r2, [r3, #26]
}
 8000646:	bf00      	nop
 8000648:	370c      	adds	r7, #12
 800064a:	46bd      	mov	sp, r7
 800064c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000650:	4770      	bx	lr

08000652 <GPIO_PinAFConfig>:
  *            @arg GPIO_AF_LTDC: Connect LTDC pins to AF14 for STM32F429xx/439xx devices.
  *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8000652:	b480      	push	{r7}
 8000654:	b085      	sub	sp, #20
 8000656:	af00      	add	r7, sp, #0
 8000658:	6078      	str	r0, [r7, #4]
 800065a:	460b      	mov	r3, r1
 800065c:	807b      	strh	r3, [r7, #2]
 800065e:	4613      	mov	r3, r2
 8000660:	707b      	strb	r3, [r7, #1]
  uint32_t temp = 0x00;
 8000662:	2300      	movs	r3, #0
 8000664:	60fb      	str	r3, [r7, #12]
  uint32_t temp_2 = 0x00;
 8000666:	2300      	movs	r3, #0
 8000668:	60bb      	str	r3, [r7, #8]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));

  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800066a:	787a      	ldrb	r2, [r7, #1]
 800066c:	887b      	ldrh	r3, [r7, #2]
 800066e:	f003 0307 	and.w	r3, r3, #7
 8000672:	009b      	lsls	r3, r3, #2
 8000674:	fa02 f303 	lsl.w	r3, r2, r3
 8000678:	60fb      	str	r3, [r7, #12]
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
 800067a:	887b      	ldrh	r3, [r7, #2]
 800067c:	08db      	lsrs	r3, r3, #3
 800067e:	b29b      	uxth	r3, r3
 8000680:	461a      	mov	r2, r3
 8000682:	687b      	ldr	r3, [r7, #4]
 8000684:	3208      	adds	r2, #8
 8000686:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800068a:	887b      	ldrh	r3, [r7, #2]
 800068c:	f003 0307 	and.w	r3, r3, #7
 8000690:	009b      	lsls	r3, r3, #2
 8000692:	210f      	movs	r1, #15
 8000694:	fa01 f303 	lsl.w	r3, r1, r3
 8000698:	43db      	mvns	r3, r3
 800069a:	8879      	ldrh	r1, [r7, #2]
 800069c:	08c9      	lsrs	r1, r1, #3
 800069e:	b289      	uxth	r1, r1
 80006a0:	4608      	mov	r0, r1
 80006a2:	ea02 0103 	and.w	r1, r2, r3
 80006a6:	687b      	ldr	r3, [r7, #4]
 80006a8:	f100 0208 	add.w	r2, r0, #8
 80006ac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80006b0:	887b      	ldrh	r3, [r7, #2]
 80006b2:	08db      	lsrs	r3, r3, #3
 80006b4:	b29b      	uxth	r3, r3
 80006b6:	461a      	mov	r2, r3
 80006b8:	687b      	ldr	r3, [r7, #4]
 80006ba:	3208      	adds	r2, #8
 80006bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 80006c0:	68fa      	ldr	r2, [r7, #12]
 80006c2:	4313      	orrs	r3, r2
 80006c4:	60bb      	str	r3, [r7, #8]
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 80006c6:	887b      	ldrh	r3, [r7, #2]
 80006c8:	08db      	lsrs	r3, r3, #3
 80006ca:	b29b      	uxth	r3, r3
 80006cc:	461a      	mov	r2, r3
 80006ce:	687b      	ldr	r3, [r7, #4]
 80006d0:	3208      	adds	r2, #8
 80006d2:	68b9      	ldr	r1, [r7, #8]
 80006d4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80006d8:	bf00      	nop
 80006da:	3714      	adds	r7, #20
 80006dc:	46bd      	mov	sp, r7
 80006de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80006e2:	4770      	bx	lr

080006e4 <RCC_GetClocksFreq>:
  *         configuration based on this function will be incorrect.
  *
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 80006e4:	b480      	push	{r7}
 80006e6:	b089      	sub	sp, #36	; 0x24
 80006e8:	af00      	add	r7, sp, #0
 80006ea:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
 80006ec:	2300      	movs	r3, #0
 80006ee:	61bb      	str	r3, [r7, #24]
 80006f0:	2300      	movs	r3, #0
 80006f2:	617b      	str	r3, [r7, #20]
 80006f4:	2300      	movs	r3, #0
 80006f6:	61fb      	str	r3, [r7, #28]
 80006f8:	2302      	movs	r3, #2
 80006fa:	613b      	str	r3, [r7, #16]
 80006fc:	2300      	movs	r3, #0
 80006fe:	60fb      	str	r3, [r7, #12]
 8000700:	2302      	movs	r3, #2
 8000702:	60bb      	str	r3, [r7, #8]
#if defined(STM32F412xG) || defined(STM32F413_423xx) || defined(STM32F446xx)
  uint32_t pllr = 2;
#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8000704:	4b4a      	ldr	r3, [pc, #296]	; (8000830 <RCC_GetClocksFreq+0x14c>)
 8000706:	689b      	ldr	r3, [r3, #8]
 8000708:	f003 030c 	and.w	r3, r3, #12
 800070c:	61bb      	str	r3, [r7, #24]

  switch (tmp)
 800070e:	69bb      	ldr	r3, [r7, #24]
 8000710:	2b08      	cmp	r3, #8
 8000712:	d011      	beq.n	8000738 <RCC_GetClocksFreq+0x54>
 8000714:	69bb      	ldr	r3, [r7, #24]
 8000716:	2b08      	cmp	r3, #8
 8000718:	d844      	bhi.n	80007a4 <RCC_GetClocksFreq+0xc0>
 800071a:	69bb      	ldr	r3, [r7, #24]
 800071c:	2b00      	cmp	r3, #0
 800071e:	d003      	beq.n	8000728 <RCC_GetClocksFreq+0x44>
 8000720:	69bb      	ldr	r3, [r7, #24]
 8000722:	2b04      	cmp	r3, #4
 8000724:	d004      	beq.n	8000730 <RCC_GetClocksFreq+0x4c>
 8000726:	e03d      	b.n	80007a4 <RCC_GetClocksFreq+0xc0>
  {
  case 0x00:  /* HSI used as system clock source */
    RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8000728:	687b      	ldr	r3, [r7, #4]
 800072a:	4a42      	ldr	r2, [pc, #264]	; (8000834 <RCC_GetClocksFreq+0x150>)
 800072c:	601a      	str	r2, [r3, #0]
    break;
 800072e:	e03d      	b.n	80007ac <RCC_GetClocksFreq+0xc8>
  case 0x04:  /* HSE used as system clock  source */
    RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8000730:	687b      	ldr	r3, [r7, #4]
 8000732:	4a41      	ldr	r2, [pc, #260]	; (8000838 <RCC_GetClocksFreq+0x154>)
 8000734:	601a      	str	r2, [r3, #0]
    break;
 8000736:	e039      	b.n	80007ac <RCC_GetClocksFreq+0xc8>
  case 0x08:  /* PLL P used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLP
    */
    pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
 8000738:	4b3d      	ldr	r3, [pc, #244]	; (8000830 <RCC_GetClocksFreq+0x14c>)
 800073a:	685b      	ldr	r3, [r3, #4]
 800073c:	0d9b      	lsrs	r3, r3, #22
 800073e:	f003 0301 	and.w	r3, r3, #1
 8000742:	60fb      	str	r3, [r7, #12]
    pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8000744:	4b3a      	ldr	r3, [pc, #232]	; (8000830 <RCC_GetClocksFreq+0x14c>)
 8000746:	685b      	ldr	r3, [r3, #4]
 8000748:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800074c:	60bb      	str	r3, [r7, #8]

    if (pllsource != 0)
 800074e:	68fb      	ldr	r3, [r7, #12]
 8000750:	2b00      	cmp	r3, #0
 8000752:	d00c      	beq.n	800076e <RCC_GetClocksFreq+0x8a>
    {
      /* HSE used as PLL clock source */
      pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 8000754:	4a38      	ldr	r2, [pc, #224]	; (8000838 <RCC_GetClocksFreq+0x154>)
 8000756:	68bb      	ldr	r3, [r7, #8]
 8000758:	fbb2 f3f3 	udiv	r3, r2, r3
 800075c:	4a34      	ldr	r2, [pc, #208]	; (8000830 <RCC_GetClocksFreq+0x14c>)
 800075e:	6852      	ldr	r2, [r2, #4]
 8000760:	0992      	lsrs	r2, r2, #6
 8000762:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8000766:	fb02 f303 	mul.w	r3, r2, r3
 800076a:	61fb      	str	r3, [r7, #28]
 800076c:	e00b      	b.n	8000786 <RCC_GetClocksFreq+0xa2>
    }
    else
    {
      /* HSI used as PLL clock source */
      pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
 800076e:	4a31      	ldr	r2, [pc, #196]	; (8000834 <RCC_GetClocksFreq+0x150>)
 8000770:	68bb      	ldr	r3, [r7, #8]
 8000772:	fbb2 f3f3 	udiv	r3, r2, r3
 8000776:	4a2e      	ldr	r2, [pc, #184]	; (8000830 <RCC_GetClocksFreq+0x14c>)
 8000778:	6852      	ldr	r2, [r2, #4]
 800077a:	0992      	lsrs	r2, r2, #6
 800077c:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8000780:	fb02 f303 	mul.w	r3, r2, r3
 8000784:	61fb      	str	r3, [r7, #28]
    }

    pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
 8000786:	4b2a      	ldr	r3, [pc, #168]	; (8000830 <RCC_GetClocksFreq+0x14c>)
 8000788:	685b      	ldr	r3, [r3, #4]
 800078a:	0c1b      	lsrs	r3, r3, #16
 800078c:	f003 0303 	and.w	r3, r3, #3
 8000790:	3301      	adds	r3, #1
 8000792:	005b      	lsls	r3, r3, #1
 8000794:	613b      	str	r3, [r7, #16]
    RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
 8000796:	69fa      	ldr	r2, [r7, #28]
 8000798:	693b      	ldr	r3, [r7, #16]
 800079a:	fbb2 f2f3 	udiv	r2, r2, r3
 800079e:	687b      	ldr	r3, [r7, #4]
 80007a0:	601a      	str	r2, [r3, #0]
    break;
 80007a2:	e003      	b.n	80007ac <RCC_GetClocksFreq+0xc8>
    RCC_Clocks->SYSCLK_Frequency = pllvco/pllr;
    break;
#endif /* STM32F412xG || STM32F413_423xx || STM32F446xx */

  default:
    RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 80007a4:	687b      	ldr	r3, [r7, #4]
 80007a6:	4a23      	ldr	r2, [pc, #140]	; (8000834 <RCC_GetClocksFreq+0x150>)
 80007a8:	601a      	str	r2, [r3, #0]
    break;
 80007aa:	bf00      	nop
  }
  /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/

  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 80007ac:	4b20      	ldr	r3, [pc, #128]	; (8000830 <RCC_GetClocksFreq+0x14c>)
 80007ae:	689b      	ldr	r3, [r3, #8]
 80007b0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80007b4:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 4;
 80007b6:	69bb      	ldr	r3, [r7, #24]
 80007b8:	091b      	lsrs	r3, r3, #4
 80007ba:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 80007bc:	4a1f      	ldr	r2, [pc, #124]	; (800083c <RCC_GetClocksFreq+0x158>)
 80007be:	69bb      	ldr	r3, [r7, #24]
 80007c0:	4413      	add	r3, r2
 80007c2:	781b      	ldrb	r3, [r3, #0]
 80007c4:	b2db      	uxtb	r3, r3
 80007c6:	617b      	str	r3, [r7, #20]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80007c8:	687b      	ldr	r3, [r7, #4]
 80007ca:	681a      	ldr	r2, [r3, #0]
 80007cc:	697b      	ldr	r3, [r7, #20]
 80007ce:	40da      	lsrs	r2, r3
 80007d0:	687b      	ldr	r3, [r7, #4]
 80007d2:	605a      	str	r2, [r3, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 80007d4:	4b16      	ldr	r3, [pc, #88]	; (8000830 <RCC_GetClocksFreq+0x14c>)
 80007d6:	689b      	ldr	r3, [r3, #8]
 80007d8:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 80007dc:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 10;
 80007de:	69bb      	ldr	r3, [r7, #24]
 80007e0:	0a9b      	lsrs	r3, r3, #10
 80007e2:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 80007e4:	4a15      	ldr	r2, [pc, #84]	; (800083c <RCC_GetClocksFreq+0x158>)
 80007e6:	69bb      	ldr	r3, [r7, #24]
 80007e8:	4413      	add	r3, r2
 80007ea:	781b      	ldrb	r3, [r3, #0]
 80007ec:	b2db      	uxtb	r3, r3
 80007ee:	617b      	str	r3, [r7, #20]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 80007f0:	687b      	ldr	r3, [r7, #4]
 80007f2:	685a      	ldr	r2, [r3, #4]
 80007f4:	697b      	ldr	r3, [r7, #20]
 80007f6:	40da      	lsrs	r2, r3
 80007f8:	687b      	ldr	r3, [r7, #4]
 80007fa:	609a      	str	r2, [r3, #8]

  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 80007fc:	4b0c      	ldr	r3, [pc, #48]	; (8000830 <RCC_GetClocksFreq+0x14c>)
 80007fe:	689b      	ldr	r3, [r3, #8]
 8000800:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8000804:	61bb      	str	r3, [r7, #24]
  tmp = tmp >> 13;
 8000806:	69bb      	ldr	r3, [r7, #24]
 8000808:	0b5b      	lsrs	r3, r3, #13
 800080a:	61bb      	str	r3, [r7, #24]
  presc = APBAHBPrescTable[tmp];
 800080c:	4a0b      	ldr	r2, [pc, #44]	; (800083c <RCC_GetClocksFreq+0x158>)
 800080e:	69bb      	ldr	r3, [r7, #24]
 8000810:	4413      	add	r3, r2
 8000812:	781b      	ldrb	r3, [r3, #0]
 8000814:	b2db      	uxtb	r3, r3
 8000816:	617b      	str	r3, [r7, #20]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8000818:	687b      	ldr	r3, [r7, #4]
 800081a:	685a      	ldr	r2, [r3, #4]
 800081c:	697b      	ldr	r3, [r7, #20]
 800081e:	40da      	lsrs	r2, r3
 8000820:	687b      	ldr	r3, [r7, #4]
 8000822:	60da      	str	r2, [r3, #12]
}
 8000824:	bf00      	nop
 8000826:	3724      	adds	r7, #36	; 0x24
 8000828:	46bd      	mov	sp, r7
 800082a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800082e:	4770      	bx	lr
 8000830:	40023800 	.word	0x40023800
 8000834:	00f42400 	.word	0x00f42400
 8000838:	017d7840 	.word	0x017d7840
 800083c:	20000014 	.word	0x20000014

08000840 <RCC_AHB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
{
 8000840:	b480      	push	{r7}
 8000842:	b083      	sub	sp, #12
 8000844:	af00      	add	r7, sp, #0
 8000846:	6078      	str	r0, [r7, #4]
 8000848:	460b      	mov	r3, r1
 800084a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));

  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800084c:	78fb      	ldrb	r3, [r7, #3]
 800084e:	2b00      	cmp	r3, #0
 8000850:	d006      	beq.n	8000860 <RCC_AHB1PeriphClockCmd+0x20>
  {
    RCC->AHB1ENR |= RCC_AHB1Periph;
 8000852:	4b0a      	ldr	r3, [pc, #40]	; (800087c <RCC_AHB1PeriphClockCmd+0x3c>)
 8000854:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000856:	4909      	ldr	r1, [pc, #36]	; (800087c <RCC_AHB1PeriphClockCmd+0x3c>)
 8000858:	687b      	ldr	r3, [r7, #4]
 800085a:	4313      	orrs	r3, r2
 800085c:	630b      	str	r3, [r1, #48]	; 0x30
  }
  else
  {
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
  }
}
 800085e:	e006      	b.n	800086e <RCC_AHB1PeriphClockCmd+0x2e>
    RCC->AHB1ENR &= ~RCC_AHB1Periph;
 8000860:	4b06      	ldr	r3, [pc, #24]	; (800087c <RCC_AHB1PeriphClockCmd+0x3c>)
 8000862:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000864:	687b      	ldr	r3, [r7, #4]
 8000866:	43db      	mvns	r3, r3
 8000868:	4904      	ldr	r1, [pc, #16]	; (800087c <RCC_AHB1PeriphClockCmd+0x3c>)
 800086a:	4013      	ands	r3, r2
 800086c:	630b      	str	r3, [r1, #48]	; 0x30
}
 800086e:	bf00      	nop
 8000870:	370c      	adds	r7, #12
 8000872:	46bd      	mov	sp, r7
 8000874:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000878:	4770      	bx	lr
 800087a:	bf00      	nop
 800087c:	40023800 	.word	0x40023800

08000880 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8000880:	b480      	push	{r7}
 8000882:	b083      	sub	sp, #12
 8000884:	af00      	add	r7, sp, #0
 8000886:	6078      	str	r0, [r7, #4]
 8000888:	460b      	mov	r3, r1
 800088a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800088c:	78fb      	ldrb	r3, [r7, #3]
 800088e:	2b00      	cmp	r3, #0
 8000890:	d006      	beq.n	80008a0 <RCC_APB1PeriphClockCmd+0x20>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8000892:	4b0a      	ldr	r3, [pc, #40]	; (80008bc <RCC_APB1PeriphClockCmd+0x3c>)
 8000894:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000896:	4909      	ldr	r1, [pc, #36]	; (80008bc <RCC_APB1PeriphClockCmd+0x3c>)
 8000898:	687b      	ldr	r3, [r7, #4]
 800089a:	4313      	orrs	r3, r2
 800089c:	640b      	str	r3, [r1, #64]	; 0x40
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  }
}
 800089e:	e006      	b.n	80008ae <RCC_APB1PeriphClockCmd+0x2e>
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80008a0:	4b06      	ldr	r3, [pc, #24]	; (80008bc <RCC_APB1PeriphClockCmd+0x3c>)
 80008a2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80008a4:	687b      	ldr	r3, [r7, #4]
 80008a6:	43db      	mvns	r3, r3
 80008a8:	4904      	ldr	r1, [pc, #16]	; (80008bc <RCC_APB1PeriphClockCmd+0x3c>)
 80008aa:	4013      	ands	r3, r2
 80008ac:	640b      	str	r3, [r1, #64]	; 0x40
}
 80008ae:	bf00      	nop
 80008b0:	370c      	adds	r7, #12
 80008b2:	46bd      	mov	sp, r7
 80008b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008b8:	4770      	bx	lr
 80008ba:	bf00      	nop
 80008bc:	40023800 	.word	0x40023800

080008c0 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80008c0:	b480      	push	{r7}
 80008c2:	b083      	sub	sp, #12
 80008c4:	af00      	add	r7, sp, #0
 80008c6:	6078      	str	r0, [r7, #4]
 80008c8:	460b      	mov	r3, r1
 80008ca:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80008cc:	78fb      	ldrb	r3, [r7, #3]
 80008ce:	2b00      	cmp	r3, #0
 80008d0:	d006      	beq.n	80008e0 <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80008d2:	4b0a      	ldr	r3, [pc, #40]	; (80008fc <RCC_APB2PeriphClockCmd+0x3c>)
 80008d4:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80008d6:	4909      	ldr	r1, [pc, #36]	; (80008fc <RCC_APB2PeriphClockCmd+0x3c>)
 80008d8:	687b      	ldr	r3, [r7, #4]
 80008da:	4313      	orrs	r3, r2
 80008dc:	644b      	str	r3, [r1, #68]	; 0x44
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 80008de:	e006      	b.n	80008ee <RCC_APB2PeriphClockCmd+0x2e>
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80008e0:	4b06      	ldr	r3, [pc, #24]	; (80008fc <RCC_APB2PeriphClockCmd+0x3c>)
 80008e2:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80008e4:	687b      	ldr	r3, [r7, #4]
 80008e6:	43db      	mvns	r3, r3
 80008e8:	4904      	ldr	r1, [pc, #16]	; (80008fc <RCC_APB2PeriphClockCmd+0x3c>)
 80008ea:	4013      	ands	r3, r2
 80008ec:	644b      	str	r3, [r1, #68]	; 0x44
}
 80008ee:	bf00      	nop
 80008f0:	370c      	adds	r7, #12
 80008f2:	46bd      	mov	sp, r7
 80008f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008f8:	4770      	bx	lr
 80008fa:	bf00      	nop
 80008fc:	40023800 	.word	0x40023800

08000900 <TIM_TimeBaseInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef structure
  *         that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8000900:	b480      	push	{r7}
 8000902:	b085      	sub	sp, #20
 8000904:	af00      	add	r7, sp, #0
 8000906:	6078      	str	r0, [r7, #4]
 8000908:	6039      	str	r1, [r7, #0]
  uint16_t tmpcr1 = 0;
 800090a:	2300      	movs	r3, #0
 800090c:	81fb      	strh	r3, [r7, #14]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;
 800090e:	687b      	ldr	r3, [r7, #4]
 8000910:	881b      	ldrh	r3, [r3, #0]
 8000912:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8)||
 8000914:	687b      	ldr	r3, [r7, #4]
 8000916:	4a29      	ldr	r2, [pc, #164]	; (80009bc <TIM_TimeBaseInit+0xbc>)
 8000918:	4293      	cmp	r3, r2
 800091a:	d013      	beq.n	8000944 <TIM_TimeBaseInit+0x44>
 800091c:	687b      	ldr	r3, [r7, #4]
 800091e:	4a28      	ldr	r2, [pc, #160]	; (80009c0 <TIM_TimeBaseInit+0xc0>)
 8000920:	4293      	cmp	r3, r2
 8000922:	d00f      	beq.n	8000944 <TIM_TimeBaseInit+0x44>
 8000924:	687b      	ldr	r3, [r7, #4]
 8000926:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800092a:	d00b      	beq.n	8000944 <TIM_TimeBaseInit+0x44>
     (TIMx == TIM2) || (TIMx == TIM3)||
 800092c:	687b      	ldr	r3, [r7, #4]
 800092e:	4a25      	ldr	r2, [pc, #148]	; (80009c4 <TIM_TimeBaseInit+0xc4>)
 8000930:	4293      	cmp	r3, r2
 8000932:	d007      	beq.n	8000944 <TIM_TimeBaseInit+0x44>
 8000934:	687b      	ldr	r3, [r7, #4]
 8000936:	4a24      	ldr	r2, [pc, #144]	; (80009c8 <TIM_TimeBaseInit+0xc8>)
 8000938:	4293      	cmp	r3, r2
 800093a:	d003      	beq.n	8000944 <TIM_TimeBaseInit+0x44>
     (TIMx == TIM4) || (TIMx == TIM5))
 800093c:	687b      	ldr	r3, [r7, #4]
 800093e:	4a23      	ldr	r2, [pc, #140]	; (80009cc <TIM_TimeBaseInit+0xcc>)
 8000940:	4293      	cmp	r3, r2
 8000942:	d108      	bne.n	8000956 <TIM_TimeBaseInit+0x56>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 8000944:	89fb      	ldrh	r3, [r7, #14]
 8000946:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800094a:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 800094c:	683b      	ldr	r3, [r7, #0]
 800094e:	885a      	ldrh	r2, [r3, #2]
 8000950:	89fb      	ldrh	r3, [r7, #14]
 8000952:	4313      	orrs	r3, r2
 8000954:	81fb      	strh	r3, [r7, #14]
  }

  if((TIMx != TIM6) && (TIMx != TIM7))
 8000956:	687b      	ldr	r3, [r7, #4]
 8000958:	4a1d      	ldr	r2, [pc, #116]	; (80009d0 <TIM_TimeBaseInit+0xd0>)
 800095a:	4293      	cmp	r3, r2
 800095c:	d00c      	beq.n	8000978 <TIM_TimeBaseInit+0x78>
 800095e:	687b      	ldr	r3, [r7, #4]
 8000960:	4a1c      	ldr	r2, [pc, #112]	; (80009d4 <TIM_TimeBaseInit+0xd4>)
 8000962:	4293      	cmp	r3, r2
 8000964:	d008      	beq.n	8000978 <TIM_TimeBaseInit+0x78>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8000966:	89fb      	ldrh	r3, [r7, #14]
 8000968:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800096c:	81fb      	strh	r3, [r7, #14]
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 800096e:	683b      	ldr	r3, [r7, #0]
 8000970:	891a      	ldrh	r2, [r3, #8]
 8000972:	89fb      	ldrh	r3, [r7, #14]
 8000974:	4313      	orrs	r3, r2
 8000976:	81fb      	strh	r3, [r7, #14]
  }

  TIMx->CR1 = tmpcr1;
 8000978:	687b      	ldr	r3, [r7, #4]
 800097a:	89fa      	ldrh	r2, [r7, #14]
 800097c:	801a      	strh	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 800097e:	683b      	ldr	r3, [r7, #0]
 8000980:	685a      	ldr	r2, [r3, #4]
 8000982:	687b      	ldr	r3, [r7, #4]
 8000984:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8000986:	683b      	ldr	r3, [r7, #0]
 8000988:	881a      	ldrh	r2, [r3, #0]
 800098a:	687b      	ldr	r3, [r7, #4]
 800098c:	851a      	strh	r2, [r3, #40]	; 0x28

  if ((TIMx == TIM1) || (TIMx == TIM8))
 800098e:	687b      	ldr	r3, [r7, #4]
 8000990:	4a0a      	ldr	r2, [pc, #40]	; (80009bc <TIM_TimeBaseInit+0xbc>)
 8000992:	4293      	cmp	r3, r2
 8000994:	d003      	beq.n	800099e <TIM_TimeBaseInit+0x9e>
 8000996:	687b      	ldr	r3, [r7, #4]
 8000998:	4a09      	ldr	r2, [pc, #36]	; (80009c0 <TIM_TimeBaseInit+0xc0>)
 800099a:	4293      	cmp	r3, r2
 800099c:	d104      	bne.n	80009a8 <TIM_TimeBaseInit+0xa8>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 800099e:	683b      	ldr	r3, [r7, #0]
 80009a0:	7a9b      	ldrb	r3, [r3, #10]
 80009a2:	b29a      	uxth	r2, r3
 80009a4:	687b      	ldr	r3, [r7, #4]
 80009a6:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;
 80009a8:	687b      	ldr	r3, [r7, #4]
 80009aa:	2201      	movs	r2, #1
 80009ac:	829a      	strh	r2, [r3, #20]
}
 80009ae:	bf00      	nop
 80009b0:	3714      	adds	r7, #20
 80009b2:	46bd      	mov	sp, r7
 80009b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80009b8:	4770      	bx	lr
 80009ba:	bf00      	nop
 80009bc:	40010000 	.word	0x40010000
 80009c0:	40010400 	.word	0x40010400
 80009c4:	40000400 	.word	0x40000400
 80009c8:	40000800 	.word	0x40000800
 80009cc:	40000c00 	.word	0x40000c00
 80009d0:	40001000 	.word	0x40001000
 80009d4:	40001400 	.word	0x40001400

080009d8 <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 80009d8:	b480      	push	{r7}
 80009da:	b083      	sub	sp, #12
 80009dc:	af00      	add	r7, sp, #0
 80009de:	6078      	str	r0, [r7, #4]
 80009e0:	460b      	mov	r3, r1
 80009e2:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80009e4:	78fb      	ldrb	r3, [r7, #3]
 80009e6:	2b00      	cmp	r3, #0
 80009e8:	d008      	beq.n	80009fc <TIM_Cmd+0x24>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 80009ea:	687b      	ldr	r3, [r7, #4]
 80009ec:	881b      	ldrh	r3, [r3, #0]
 80009ee:	b29b      	uxth	r3, r3
 80009f0:	f043 0301 	orr.w	r3, r3, #1
 80009f4:	b29a      	uxth	r2, r3
 80009f6:	687b      	ldr	r3, [r7, #4]
 80009f8:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
  }
}
 80009fa:	e007      	b.n	8000a0c <TIM_Cmd+0x34>
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 80009fc:	687b      	ldr	r3, [r7, #4]
 80009fe:	881b      	ldrh	r3, [r3, #0]
 8000a00:	b29b      	uxth	r3, r3
 8000a02:	f023 0301 	bic.w	r3, r3, #1
 8000a06:	b29a      	uxth	r2, r3
 8000a08:	687b      	ldr	r3, [r7, #4]
 8000a0a:	801a      	strh	r2, [r3, #0]
}
 8000a0c:	bf00      	nop
 8000a0e:	370c      	adds	r7, #12
 8000a10:	46bd      	mov	sp, r7
 8000a12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a16:	4770      	bx	lr

08000a18 <TIM_OC1Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8000a18:	b480      	push	{r7}
 8000a1a:	b085      	sub	sp, #20
 8000a1c:	af00      	add	r7, sp, #0
 8000a1e:	6078      	str	r0, [r7, #4]
 8000a20:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 8000a22:	2300      	movs	r3, #0
 8000a24:	817b      	strh	r3, [r7, #10]
 8000a26:	2300      	movs	r3, #0
 8000a28:	81fb      	strh	r3, [r7, #14]
 8000a2a:	2300      	movs	r3, #0
 8000a2c:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
 8000a2e:	687b      	ldr	r3, [r7, #4]
 8000a30:	8c1b      	ldrh	r3, [r3, #32]
 8000a32:	b29b      	uxth	r3, r3
 8000a34:	f023 0301 	bic.w	r3, r3, #1
 8000a38:	b29a      	uxth	r2, r3
 8000a3a:	687b      	ldr	r3, [r7, #4]
 8000a3c:	841a      	strh	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8000a3e:	687b      	ldr	r3, [r7, #4]
 8000a40:	8c1b      	ldrh	r3, [r3, #32]
 8000a42:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8000a44:	687b      	ldr	r3, [r7, #4]
 8000a46:	889b      	ldrh	r3, [r3, #4]
 8000a48:	81bb      	strh	r3, [r7, #12]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8000a4a:	687b      	ldr	r3, [r7, #4]
 8000a4c:	8b1b      	ldrh	r3, [r3, #24]
 8000a4e:	817b      	strh	r3, [r7, #10]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
 8000a50:	897b      	ldrh	r3, [r7, #10]
 8000a52:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8000a56:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
 8000a58:	897b      	ldrh	r3, [r7, #10]
 8000a5a:	f023 0303 	bic.w	r3, r3, #3
 8000a5e:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8000a60:	683b      	ldr	r3, [r7, #0]
 8000a62:	881a      	ldrh	r2, [r3, #0]
 8000a64:	897b      	ldrh	r3, [r7, #10]
 8000a66:	4313      	orrs	r3, r2
 8000a68:	817b      	strh	r3, [r7, #10]

  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC1P;
 8000a6a:	89fb      	ldrh	r3, [r7, #14]
 8000a6c:	f023 0302 	bic.w	r3, r3, #2
 8000a70:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8000a72:	683b      	ldr	r3, [r7, #0]
 8000a74:	899a      	ldrh	r2, [r3, #12]
 8000a76:	89fb      	ldrh	r3, [r7, #14]
 8000a78:	4313      	orrs	r3, r2
 8000a7a:	81fb      	strh	r3, [r7, #14]

  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8000a7c:	683b      	ldr	r3, [r7, #0]
 8000a7e:	885a      	ldrh	r2, [r3, #2]
 8000a80:	89fb      	ldrh	r3, [r7, #14]
 8000a82:	4313      	orrs	r3, r2
 8000a84:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8))
 8000a86:	687b      	ldr	r3, [r7, #4]
 8000a88:	4a1e      	ldr	r2, [pc, #120]	; (8000b04 <TIM_OC1Init+0xec>)
 8000a8a:	4293      	cmp	r3, r2
 8000a8c:	d003      	beq.n	8000a96 <TIM_OC1Init+0x7e>
 8000a8e:	687b      	ldr	r3, [r7, #4]
 8000a90:	4a1d      	ldr	r2, [pc, #116]	; (8000b08 <TIM_OC1Init+0xf0>)
 8000a92:	4293      	cmp	r3, r2
 8000a94:	d123      	bne.n	8000ade <TIM_OC1Init+0xc6>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));

    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
 8000a96:	89fb      	ldrh	r3, [r7, #14]
 8000a98:	f023 0308 	bic.w	r3, r3, #8
 8000a9c:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8000a9e:	683b      	ldr	r3, [r7, #0]
 8000aa0:	89da      	ldrh	r2, [r3, #14]
 8000aa2:	89fb      	ldrh	r3, [r7, #14]
 8000aa4:	4313      	orrs	r3, r2
 8000aa6:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
 8000aa8:	89fb      	ldrh	r3, [r7, #14]
 8000aaa:	f023 0304 	bic.w	r3, r3, #4
 8000aae:	81fb      	strh	r3, [r7, #14]

    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8000ab0:	683b      	ldr	r3, [r7, #0]
 8000ab2:	889a      	ldrh	r2, [r3, #4]
 8000ab4:	89fb      	ldrh	r3, [r7, #14]
 8000ab6:	4313      	orrs	r3, r2
 8000ab8:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
 8000aba:	89bb      	ldrh	r3, [r7, #12]
 8000abc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000ac0:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
 8000ac2:	89bb      	ldrh	r3, [r7, #12]
 8000ac4:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000ac8:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8000aca:	683b      	ldr	r3, [r7, #0]
 8000acc:	8a1a      	ldrh	r2, [r3, #16]
 8000ace:	89bb      	ldrh	r3, [r7, #12]
 8000ad0:	4313      	orrs	r3, r2
 8000ad2:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 8000ad4:	683b      	ldr	r3, [r7, #0]
 8000ad6:	8a5a      	ldrh	r2, [r3, #18]
 8000ad8:	89bb      	ldrh	r3, [r7, #12]
 8000ada:	4313      	orrs	r3, r2
 8000adc:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8000ade:	687b      	ldr	r3, [r7, #4]
 8000ae0:	89ba      	ldrh	r2, [r7, #12]
 8000ae2:	809a      	strh	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8000ae4:	687b      	ldr	r3, [r7, #4]
 8000ae6:	897a      	ldrh	r2, [r7, #10]
 8000ae8:	831a      	strh	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8000aea:	683b      	ldr	r3, [r7, #0]
 8000aec:	689a      	ldr	r2, [r3, #8]
 8000aee:	687b      	ldr	r3, [r7, #4]
 8000af0:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8000af2:	687b      	ldr	r3, [r7, #4]
 8000af4:	89fa      	ldrh	r2, [r7, #14]
 8000af6:	841a      	strh	r2, [r3, #32]
}
 8000af8:	bf00      	nop
 8000afa:	3714      	adds	r7, #20
 8000afc:	46bd      	mov	sp, r7
 8000afe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b02:	4770      	bx	lr
 8000b04:	40010000 	.word	0x40010000
 8000b08:	40010400 	.word	0x40010400

08000b0c <TIM_OC2Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8000b0c:	b480      	push	{r7}
 8000b0e:	b085      	sub	sp, #20
 8000b10:	af00      	add	r7, sp, #0
 8000b12:	6078      	str	r0, [r7, #4]
 8000b14:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 8000b16:	2300      	movs	r3, #0
 8000b18:	817b      	strh	r3, [r7, #10]
 8000b1a:	2300      	movs	r3, #0
 8000b1c:	81fb      	strh	r3, [r7, #14]
 8000b1e:	2300      	movs	r3, #0
 8000b20:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 8000b22:	687b      	ldr	r3, [r7, #4]
 8000b24:	8c1b      	ldrh	r3, [r3, #32]
 8000b26:	b29b      	uxth	r3, r3
 8000b28:	f023 0310 	bic.w	r3, r3, #16
 8000b2c:	b29a      	uxth	r2, r3
 8000b2e:	687b      	ldr	r3, [r7, #4]
 8000b30:	841a      	strh	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8000b32:	687b      	ldr	r3, [r7, #4]
 8000b34:	8c1b      	ldrh	r3, [r3, #32]
 8000b36:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8000b38:	687b      	ldr	r3, [r7, #4]
 8000b3a:	889b      	ldrh	r3, [r3, #4]
 8000b3c:	81bb      	strh	r3, [r7, #12]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8000b3e:	687b      	ldr	r3, [r7, #4]
 8000b40:	8b1b      	ldrh	r3, [r3, #24]
 8000b42:	817b      	strh	r3, [r7, #10]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
 8000b44:	897b      	ldrh	r3, [r7, #10]
 8000b46:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8000b4a:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
 8000b4c:	897b      	ldrh	r3, [r7, #10]
 8000b4e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000b52:	817b      	strh	r3, [r7, #10]

  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8000b54:	683b      	ldr	r3, [r7, #0]
 8000b56:	881b      	ldrh	r3, [r3, #0]
 8000b58:	021b      	lsls	r3, r3, #8
 8000b5a:	b29a      	uxth	r2, r3
 8000b5c:	897b      	ldrh	r3, [r7, #10]
 8000b5e:	4313      	orrs	r3, r2
 8000b60:	817b      	strh	r3, [r7, #10]

  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC2P;
 8000b62:	89fb      	ldrh	r3, [r7, #14]
 8000b64:	f023 0320 	bic.w	r3, r3, #32
 8000b68:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
 8000b6a:	683b      	ldr	r3, [r7, #0]
 8000b6c:	899b      	ldrh	r3, [r3, #12]
 8000b6e:	011b      	lsls	r3, r3, #4
 8000b70:	b29a      	uxth	r2, r3
 8000b72:	89fb      	ldrh	r3, [r7, #14]
 8000b74:	4313      	orrs	r3, r2
 8000b76:	81fb      	strh	r3, [r7, #14]

  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
 8000b78:	683b      	ldr	r3, [r7, #0]
 8000b7a:	885b      	ldrh	r3, [r3, #2]
 8000b7c:	011b      	lsls	r3, r3, #4
 8000b7e:	b29a      	uxth	r2, r3
 8000b80:	89fb      	ldrh	r3, [r7, #14]
 8000b82:	4313      	orrs	r3, r2
 8000b84:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8))
 8000b86:	687b      	ldr	r3, [r7, #4]
 8000b88:	4a22      	ldr	r2, [pc, #136]	; (8000c14 <TIM_OC2Init+0x108>)
 8000b8a:	4293      	cmp	r3, r2
 8000b8c:	d003      	beq.n	8000b96 <TIM_OC2Init+0x8a>
 8000b8e:	687b      	ldr	r3, [r7, #4]
 8000b90:	4a21      	ldr	r2, [pc, #132]	; (8000c18 <TIM_OC2Init+0x10c>)
 8000b92:	4293      	cmp	r3, r2
 8000b94:	d12b      	bne.n	8000bee <TIM_OC2Init+0xe2>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));

    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
 8000b96:	89fb      	ldrh	r3, [r7, #14]
 8000b98:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8000b9c:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8000b9e:	683b      	ldr	r3, [r7, #0]
 8000ba0:	89db      	ldrh	r3, [r3, #14]
 8000ba2:	011b      	lsls	r3, r3, #4
 8000ba4:	b29a      	uxth	r2, r3
 8000ba6:	89fb      	ldrh	r3, [r7, #14]
 8000ba8:	4313      	orrs	r3, r2
 8000baa:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
 8000bac:	89fb      	ldrh	r3, [r7, #14]
 8000bae:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000bb2:	81fb      	strh	r3, [r7, #14]

    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
 8000bb4:	683b      	ldr	r3, [r7, #0]
 8000bb6:	889b      	ldrh	r3, [r3, #4]
 8000bb8:	011b      	lsls	r3, r3, #4
 8000bba:	b29a      	uxth	r2, r3
 8000bbc:	89fb      	ldrh	r3, [r7, #14]
 8000bbe:	4313      	orrs	r3, r2
 8000bc0:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
 8000bc2:	89bb      	ldrh	r3, [r7, #12]
 8000bc4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000bc8:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
 8000bca:	89bb      	ldrh	r3, [r7, #12]
 8000bcc:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000bd0:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
 8000bd2:	683b      	ldr	r3, [r7, #0]
 8000bd4:	8a1b      	ldrh	r3, [r3, #16]
 8000bd6:	009b      	lsls	r3, r3, #2
 8000bd8:	b29a      	uxth	r2, r3
 8000bda:	89bb      	ldrh	r3, [r7, #12]
 8000bdc:	4313      	orrs	r3, r2
 8000bde:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8000be0:	683b      	ldr	r3, [r7, #0]
 8000be2:	8a5b      	ldrh	r3, [r3, #18]
 8000be4:	009b      	lsls	r3, r3, #2
 8000be6:	b29a      	uxth	r2, r3
 8000be8:	89bb      	ldrh	r3, [r7, #12]
 8000bea:	4313      	orrs	r3, r2
 8000bec:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8000bee:	687b      	ldr	r3, [r7, #4]
 8000bf0:	89ba      	ldrh	r2, [r7, #12]
 8000bf2:	809a      	strh	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8000bf4:	687b      	ldr	r3, [r7, #4]
 8000bf6:	897a      	ldrh	r2, [r7, #10]
 8000bf8:	831a      	strh	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8000bfa:	683b      	ldr	r3, [r7, #0]
 8000bfc:	689a      	ldr	r2, [r3, #8]
 8000bfe:	687b      	ldr	r3, [r7, #4]
 8000c00:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8000c02:	687b      	ldr	r3, [r7, #4]
 8000c04:	89fa      	ldrh	r2, [r7, #14]
 8000c06:	841a      	strh	r2, [r3, #32]
}
 8000c08:	bf00      	nop
 8000c0a:	3714      	adds	r7, #20
 8000c0c:	46bd      	mov	sp, r7
 8000c0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c12:	4770      	bx	lr
 8000c14:	40010000 	.word	0x40010000
 8000c18:	40010400 	.word	0x40010400

08000c1c <TIM_OC3Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8000c1c:	b480      	push	{r7}
 8000c1e:	b085      	sub	sp, #20
 8000c20:	af00      	add	r7, sp, #0
 8000c22:	6078      	str	r0, [r7, #4]
 8000c24:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 8000c26:	2300      	movs	r3, #0
 8000c28:	817b      	strh	r3, [r7, #10]
 8000c2a:	2300      	movs	r3, #0
 8000c2c:	81fb      	strh	r3, [r7, #14]
 8000c2e:	2300      	movs	r3, #0
 8000c30:	81bb      	strh	r3, [r7, #12]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8000c32:	687b      	ldr	r3, [r7, #4]
 8000c34:	8c1b      	ldrh	r3, [r3, #32]
 8000c36:	b29b      	uxth	r3, r3
 8000c38:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000c3c:	b29a      	uxth	r2, r3
 8000c3e:	687b      	ldr	r3, [r7, #4]
 8000c40:	841a      	strh	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8000c42:	687b      	ldr	r3, [r7, #4]
 8000c44:	8c1b      	ldrh	r3, [r3, #32]
 8000c46:	81fb      	strh	r3, [r7, #14]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8000c48:	687b      	ldr	r3, [r7, #4]
 8000c4a:	889b      	ldrh	r3, [r3, #4]
 8000c4c:	81bb      	strh	r3, [r7, #12]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8000c4e:	687b      	ldr	r3, [r7, #4]
 8000c50:	8b9b      	ldrh	r3, [r3, #28]
 8000c52:	817b      	strh	r3, [r7, #10]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
 8000c54:	897b      	ldrh	r3, [r7, #10]
 8000c56:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8000c5a:	817b      	strh	r3, [r7, #10]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;
 8000c5c:	897b      	ldrh	r3, [r7, #10]
 8000c5e:	f023 0303 	bic.w	r3, r3, #3
 8000c62:	817b      	strh	r3, [r7, #10]
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8000c64:	683b      	ldr	r3, [r7, #0]
 8000c66:	881a      	ldrh	r2, [r3, #0]
 8000c68:	897b      	ldrh	r3, [r7, #10]
 8000c6a:	4313      	orrs	r3, r2
 8000c6c:	817b      	strh	r3, [r7, #10]

  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC3P;
 8000c6e:	89fb      	ldrh	r3, [r7, #14]
 8000c70:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000c74:	81fb      	strh	r3, [r7, #14]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
 8000c76:	683b      	ldr	r3, [r7, #0]
 8000c78:	899b      	ldrh	r3, [r3, #12]
 8000c7a:	021b      	lsls	r3, r3, #8
 8000c7c:	b29a      	uxth	r2, r3
 8000c7e:	89fb      	ldrh	r3, [r7, #14]
 8000c80:	4313      	orrs	r3, r2
 8000c82:	81fb      	strh	r3, [r7, #14]

  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
 8000c84:	683b      	ldr	r3, [r7, #0]
 8000c86:	885b      	ldrh	r3, [r3, #2]
 8000c88:	021b      	lsls	r3, r3, #8
 8000c8a:	b29a      	uxth	r2, r3
 8000c8c:	89fb      	ldrh	r3, [r7, #14]
 8000c8e:	4313      	orrs	r3, r2
 8000c90:	81fb      	strh	r3, [r7, #14]

  if((TIMx == TIM1) || (TIMx == TIM8))
 8000c92:	687b      	ldr	r3, [r7, #4]
 8000c94:	4a22      	ldr	r2, [pc, #136]	; (8000d20 <TIM_OC3Init+0x104>)
 8000c96:	4293      	cmp	r3, r2
 8000c98:	d003      	beq.n	8000ca2 <TIM_OC3Init+0x86>
 8000c9a:	687b      	ldr	r3, [r7, #4]
 8000c9c:	4a21      	ldr	r2, [pc, #132]	; (8000d24 <TIM_OC3Init+0x108>)
 8000c9e:	4293      	cmp	r3, r2
 8000ca0:	d12b      	bne.n	8000cfa <TIM_OC3Init+0xde>
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));

    /* Reset the Output N Polarity level */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
 8000ca2:	89fb      	ldrh	r3, [r7, #14]
 8000ca4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8000ca8:	81fb      	strh	r3, [r7, #14]
    /* Set the Output N Polarity */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8000caa:	683b      	ldr	r3, [r7, #0]
 8000cac:	89db      	ldrh	r3, [r3, #14]
 8000cae:	021b      	lsls	r3, r3, #8
 8000cb0:	b29a      	uxth	r2, r3
 8000cb2:	89fb      	ldrh	r3, [r7, #14]
 8000cb4:	4313      	orrs	r3, r2
 8000cb6:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output N State */
    tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
 8000cb8:	89fb      	ldrh	r3, [r7, #14]
 8000cba:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8000cbe:	81fb      	strh	r3, [r7, #14]

    /* Set the Output N State */
    tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
 8000cc0:	683b      	ldr	r3, [r7, #0]
 8000cc2:	889b      	ldrh	r3, [r3, #4]
 8000cc4:	021b      	lsls	r3, r3, #8
 8000cc6:	b29a      	uxth	r2, r3
 8000cc8:	89fb      	ldrh	r3, [r7, #14]
 8000cca:	4313      	orrs	r3, r2
 8000ccc:	81fb      	strh	r3, [r7, #14]
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
 8000cce:	89bb      	ldrh	r3, [r7, #12]
 8000cd0:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000cd4:	81bb      	strh	r3, [r7, #12]
    tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
 8000cd6:	89bb      	ldrh	r3, [r7, #12]
 8000cd8:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8000cdc:	81bb      	strh	r3, [r7, #12]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
 8000cde:	683b      	ldr	r3, [r7, #0]
 8000ce0:	8a1b      	ldrh	r3, [r3, #16]
 8000ce2:	011b      	lsls	r3, r3, #4
 8000ce4:	b29a      	uxth	r2, r3
 8000ce6:	89bb      	ldrh	r3, [r7, #12]
 8000ce8:	4313      	orrs	r3, r2
 8000cea:	81bb      	strh	r3, [r7, #12]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
 8000cec:	683b      	ldr	r3, [r7, #0]
 8000cee:	8a5b      	ldrh	r3, [r3, #18]
 8000cf0:	011b      	lsls	r3, r3, #4
 8000cf2:	b29a      	uxth	r2, r3
 8000cf4:	89bb      	ldrh	r3, [r7, #12]
 8000cf6:	4313      	orrs	r3, r2
 8000cf8:	81bb      	strh	r3, [r7, #12]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8000cfa:	687b      	ldr	r3, [r7, #4]
 8000cfc:	89ba      	ldrh	r2, [r7, #12]
 8000cfe:	809a      	strh	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8000d00:	687b      	ldr	r3, [r7, #4]
 8000d02:	897a      	ldrh	r2, [r7, #10]
 8000d04:	839a      	strh	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8000d06:	683b      	ldr	r3, [r7, #0]
 8000d08:	689a      	ldr	r2, [r3, #8]
 8000d0a:	687b      	ldr	r3, [r7, #4]
 8000d0c:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8000d0e:	687b      	ldr	r3, [r7, #4]
 8000d10:	89fa      	ldrh	r2, [r7, #14]
 8000d12:	841a      	strh	r2, [r3, #32]
}
 8000d14:	bf00      	nop
 8000d16:	3714      	adds	r7, #20
 8000d18:	46bd      	mov	sp, r7
 8000d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000d1e:	4770      	bx	lr
 8000d20:	40010000 	.word	0x40010000
 8000d24:	40010400 	.word	0x40010400

08000d28 <TIM_OC4Init>:
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8000d28:	b480      	push	{r7}
 8000d2a:	b085      	sub	sp, #20
 8000d2c:	af00      	add	r7, sp, #0
 8000d2e:	6078      	str	r0, [r7, #4]
 8000d30:	6039      	str	r1, [r7, #0]
  uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
 8000d32:	2300      	movs	r3, #0
 8000d34:	81bb      	strh	r3, [r7, #12]
 8000d36:	2300      	movs	r3, #0
 8000d38:	817b      	strh	r3, [r7, #10]
 8000d3a:	2300      	movs	r3, #0
 8000d3c:	81fb      	strh	r3, [r7, #14]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 8000d3e:	687b      	ldr	r3, [r7, #4]
 8000d40:	8c1b      	ldrh	r3, [r3, #32]
 8000d42:	b29b      	uxth	r3, r3
 8000d44:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000d48:	b29a      	uxth	r2, r3
 8000d4a:	687b      	ldr	r3, [r7, #4]
 8000d4c:	841a      	strh	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8000d4e:	687b      	ldr	r3, [r7, #4]
 8000d50:	8c1b      	ldrh	r3, [r3, #32]
 8000d52:	817b      	strh	r3, [r7, #10]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8000d54:	687b      	ldr	r3, [r7, #4]
 8000d56:	889b      	ldrh	r3, [r3, #4]
 8000d58:	81fb      	strh	r3, [r7, #14]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8000d5a:	687b      	ldr	r3, [r7, #4]
 8000d5c:	8b9b      	ldrh	r3, [r3, #28]
 8000d5e:	81bb      	strh	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
 8000d60:	89bb      	ldrh	r3, [r7, #12]
 8000d62:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8000d66:	81bb      	strh	r3, [r7, #12]
  tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
 8000d68:	89bb      	ldrh	r3, [r7, #12]
 8000d6a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8000d6e:	81bb      	strh	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8000d70:	683b      	ldr	r3, [r7, #0]
 8000d72:	881b      	ldrh	r3, [r3, #0]
 8000d74:	021b      	lsls	r3, r3, #8
 8000d76:	b29a      	uxth	r2, r3
 8000d78:	89bb      	ldrh	r3, [r7, #12]
 8000d7a:	4313      	orrs	r3, r2
 8000d7c:	81bb      	strh	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= (uint16_t)~TIM_CCER_CC4P;
 8000d7e:	897b      	ldrh	r3, [r7, #10]
 8000d80:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8000d84:	817b      	strh	r3, [r7, #10]
  /* Set the Output Compare Polarity */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
 8000d86:	683b      	ldr	r3, [r7, #0]
 8000d88:	899b      	ldrh	r3, [r3, #12]
 8000d8a:	031b      	lsls	r3, r3, #12
 8000d8c:	b29a      	uxth	r2, r3
 8000d8e:	897b      	ldrh	r3, [r7, #10]
 8000d90:	4313      	orrs	r3, r2
 8000d92:	817b      	strh	r3, [r7, #10]

  /* Set the Output State */
  tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
 8000d94:	683b      	ldr	r3, [r7, #0]
 8000d96:	885b      	ldrh	r3, [r3, #2]
 8000d98:	031b      	lsls	r3, r3, #12
 8000d9a:	b29a      	uxth	r2, r3
 8000d9c:	897b      	ldrh	r3, [r7, #10]
 8000d9e:	4313      	orrs	r3, r2
 8000da0:	817b      	strh	r3, [r7, #10]

  if((TIMx == TIM1) || (TIMx == TIM8))
 8000da2:	687b      	ldr	r3, [r7, #4]
 8000da4:	4a12      	ldr	r2, [pc, #72]	; (8000df0 <TIM_OC4Init+0xc8>)
 8000da6:	4293      	cmp	r3, r2
 8000da8:	d003      	beq.n	8000db2 <TIM_OC4Init+0x8a>
 8000daa:	687b      	ldr	r3, [r7, #4]
 8000dac:	4a11      	ldr	r2, [pc, #68]	; (8000df4 <TIM_OC4Init+0xcc>)
 8000dae:	4293      	cmp	r3, r2
 8000db0:	d10a      	bne.n	8000dc8 <TIM_OC4Init+0xa0>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
 8000db2:	89fb      	ldrh	r3, [r7, #14]
 8000db4:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8000db8:	81fb      	strh	r3, [r7, #14]
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
 8000dba:	683b      	ldr	r3, [r7, #0]
 8000dbc:	8a1b      	ldrh	r3, [r3, #16]
 8000dbe:	019b      	lsls	r3, r3, #6
 8000dc0:	b29a      	uxth	r2, r3
 8000dc2:	89fb      	ldrh	r3, [r7, #14]
 8000dc4:	4313      	orrs	r3, r2
 8000dc6:	81fb      	strh	r3, [r7, #14]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8000dc8:	687b      	ldr	r3, [r7, #4]
 8000dca:	89fa      	ldrh	r2, [r7, #14]
 8000dcc:	809a      	strh	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8000dce:	687b      	ldr	r3, [r7, #4]
 8000dd0:	89ba      	ldrh	r2, [r7, #12]
 8000dd2:	839a      	strh	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 8000dd4:	683b      	ldr	r3, [r7, #0]
 8000dd6:	689a      	ldr	r2, [r3, #8]
 8000dd8:	687b      	ldr	r3, [r7, #4]
 8000dda:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8000ddc:	687b      	ldr	r3, [r7, #4]
 8000dde:	897a      	ldrh	r2, [r7, #10]
 8000de0:	841a      	strh	r2, [r3, #32]
}
 8000de2:	bf00      	nop
 8000de4:	3714      	adds	r7, #20
 8000de6:	46bd      	mov	sp, r7
 8000de8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000dec:	4770      	bx	lr
 8000dee:	bf00      	nop
 8000df0:	40010000 	.word	0x40010000
 8000df4:	40010400 	.word	0x40010400

08000df8 <TIM_SetCompare1>:
  * @param  TIMx: where x can be 1 to 14 except 6 and 7, to select the TIM peripheral.
  * @param  Compare1: specifies the Capture Compare1 register new value.
  * @retval None
  */
void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
{
 8000df8:	b480      	push	{r7}
 8000dfa:	b083      	sub	sp, #12
 8000dfc:	af00      	add	r7, sp, #0
 8000dfe:	6078      	str	r0, [r7, #4]
 8000e00:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 8000e02:	687b      	ldr	r3, [r7, #4]
 8000e04:	683a      	ldr	r2, [r7, #0]
 8000e06:	635a      	str	r2, [r3, #52]	; 0x34
}
 8000e08:	bf00      	nop
 8000e0a:	370c      	adds	r7, #12
 8000e0c:	46bd      	mov	sp, r7
 8000e0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e12:	4770      	bx	lr

08000e14 <TIM_SetCompare2>:
  *         peripheral.
  * @param  Compare2: specifies the Capture Compare2 register new value.
  * @retval None
  */
void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
{
 8000e14:	b480      	push	{r7}
 8000e16:	b083      	sub	sp, #12
 8000e18:	af00      	add	r7, sp, #0
 8000e1a:	6078      	str	r0, [r7, #4]
 8000e1c:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 8000e1e:	687b      	ldr	r3, [r7, #4]
 8000e20:	683a      	ldr	r2, [r7, #0]
 8000e22:	639a      	str	r2, [r3, #56]	; 0x38
}
 8000e24:	bf00      	nop
 8000e26:	370c      	adds	r7, #12
 8000e28:	46bd      	mov	sp, r7
 8000e2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e2e:	4770      	bx	lr

08000e30 <TIM_SetCompare3>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare3: specifies the Capture Compare3 register new value.
  * @retval None
  */
void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
{
 8000e30:	b480      	push	{r7}
 8000e32:	b083      	sub	sp, #12
 8000e34:	af00      	add	r7, sp, #0
 8000e36:	6078      	str	r0, [r7, #4]
 8000e38:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 8000e3a:	687b      	ldr	r3, [r7, #4]
 8000e3c:	683a      	ldr	r2, [r7, #0]
 8000e3e:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8000e40:	bf00      	nop
 8000e42:	370c      	adds	r7, #12
 8000e44:	46bd      	mov	sp, r7
 8000e46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e4a:	4770      	bx	lr

08000e4c <TIM_SetCompare4>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @param  Compare4: specifies the Capture Compare4 register new value.
  * @retval None
  */
void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
{
 8000e4c:	b480      	push	{r7}
 8000e4e:	b083      	sub	sp, #12
 8000e50:	af00      	add	r7, sp, #0
 8000e52:	6078      	str	r0, [r7, #4]
 8000e54:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 8000e56:	687b      	ldr	r3, [r7, #4]
 8000e58:	683a      	ldr	r2, [r7, #0]
 8000e5a:	641a      	str	r2, [r3, #64]	; 0x40
}
 8000e5c:	bf00      	nop
 8000e5e:	370c      	adds	r7, #12
 8000e60:	46bd      	mov	sp, r7
 8000e62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000e66:	4770      	bx	lr

08000e68 <TIM_CtrlPWMOutputs>:
  * @param  NewState: new state of the TIM peripheral Main Outputs.
  *          This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8000e68:	b480      	push	{r7}
 8000e6a:	b083      	sub	sp, #12
 8000e6c:	af00      	add	r7, sp, #0
 8000e6e:	6078      	str	r0, [r7, #4]
 8000e70:	460b      	mov	r3, r1
 8000e72:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8000e74:	78fb      	ldrb	r3, [r7, #3]
 8000e76:	2b00      	cmp	r3, #0
 8000e78:	d00c      	beq.n	8000e94 <TIM_CtrlPWMOutputs+0x2c>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 8000e7a:	687b      	ldr	r3, [r7, #4]
 8000e7c:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8000e80:	b29b      	uxth	r3, r3
 8000e82:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8000e86:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8000e8a:	b29a      	uxth	r2, r3
 8000e8c:	687b      	ldr	r3, [r7, #4]
 8000e8e:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
  }
}
 8000e92:	e009      	b.n	8000ea8 <TIM_CtrlPWMOutputs+0x40>
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 8000e94:	687b      	ldr	r3, [r7, #4]
 8000e96:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8000e9a:	b29b      	uxth	r3, r3
 8000e9c:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8000ea0:	b29a      	uxth	r2, r3
 8000ea2:	687b      	ldr	r3, [r7, #4]
 8000ea4:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
}
 8000ea8:	bf00      	nop
 8000eaa:	370c      	adds	r7, #12
 8000eac:	46bd      	mov	sp, r7
 8000eae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000eb2:	4770      	bx	lr

08000eb4 <USART_ReceiveData>:
  * @param  USARTx: where x can be 1, 2, 3, 4, 5, 6, 7 or 8 to select the USART or 
  *         UART peripheral.
  * @retval The received data.
  */
uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
{
 8000eb4:	b480      	push	{r7}
 8000eb6:	b083      	sub	sp, #12
 8000eb8:	af00      	add	r7, sp, #0
 8000eba:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  
  /* Receive Data */
  return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
 8000ebc:	687b      	ldr	r3, [r7, #4]
 8000ebe:	889b      	ldrh	r3, [r3, #4]
 8000ec0:	b29b      	uxth	r3, r3
 8000ec2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8000ec6:	b29b      	uxth	r3, r3
}
 8000ec8:	4618      	mov	r0, r3
 8000eca:	370c      	adds	r7, #12
 8000ecc:	46bd      	mov	sp, r7
 8000ece:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000ed2:	4770      	bx	lr

08000ed4 <USART_GetITStatus>:
  *            @arg USART_IT_FE:   Framing Error interrupt
  *            @arg USART_IT_PE:   Parity Error interrupt
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8000ed4:	b480      	push	{r7}
 8000ed6:	b087      	sub	sp, #28
 8000ed8:	af00      	add	r7, sp, #0
 8000eda:	6078      	str	r0, [r7, #4]
 8000edc:	460b      	mov	r3, r1
 8000ede:	807b      	strh	r3, [r7, #2]
  uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 8000ee0:	2300      	movs	r3, #0
 8000ee2:	60fb      	str	r3, [r7, #12]
 8000ee4:	2300      	movs	r3, #0
 8000ee6:	617b      	str	r3, [r7, #20]
 8000ee8:	2300      	movs	r3, #0
 8000eea:	60bb      	str	r3, [r7, #8]
  ITStatus bitstatus = RESET;
 8000eec:	2300      	movs	r3, #0
 8000eee:	74fb      	strb	r3, [r7, #19]
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  /* Get the USART register index */
  usartreg = (((uint8_t)USART_IT) >> 0x05);
 8000ef0:	887b      	ldrh	r3, [r7, #2]
 8000ef2:	b2db      	uxtb	r3, r3
 8000ef4:	095b      	lsrs	r3, r3, #5
 8000ef6:	b2db      	uxtb	r3, r3
 8000ef8:	60bb      	str	r3, [r7, #8]
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 8000efa:	887b      	ldrh	r3, [r7, #2]
 8000efc:	f003 031f 	and.w	r3, r3, #31
 8000f00:	617b      	str	r3, [r7, #20]
  itmask = (uint32_t)0x01 << itmask;
 8000f02:	2201      	movs	r2, #1
 8000f04:	697b      	ldr	r3, [r7, #20]
 8000f06:	fa02 f303 	lsl.w	r3, r2, r3
 8000f0a:	617b      	str	r3, [r7, #20]
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8000f0c:	68bb      	ldr	r3, [r7, #8]
 8000f0e:	2b01      	cmp	r3, #1
 8000f10:	d107      	bne.n	8000f22 <USART_GetITStatus+0x4e>
  {
    itmask &= USARTx->CR1;
 8000f12:	687b      	ldr	r3, [r7, #4]
 8000f14:	899b      	ldrh	r3, [r3, #12]
 8000f16:	b29b      	uxth	r3, r3
 8000f18:	461a      	mov	r2, r3
 8000f1a:	697b      	ldr	r3, [r7, #20]
 8000f1c:	4013      	ands	r3, r2
 8000f1e:	617b      	str	r3, [r7, #20]
 8000f20:	e011      	b.n	8000f46 <USART_GetITStatus+0x72>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8000f22:	68bb      	ldr	r3, [r7, #8]
 8000f24:	2b02      	cmp	r3, #2
 8000f26:	d107      	bne.n	8000f38 <USART_GetITStatus+0x64>
  {
    itmask &= USARTx->CR2;
 8000f28:	687b      	ldr	r3, [r7, #4]
 8000f2a:	8a1b      	ldrh	r3, [r3, #16]
 8000f2c:	b29b      	uxth	r3, r3
 8000f2e:	461a      	mov	r2, r3
 8000f30:	697b      	ldr	r3, [r7, #20]
 8000f32:	4013      	ands	r3, r2
 8000f34:	617b      	str	r3, [r7, #20]
 8000f36:	e006      	b.n	8000f46 <USART_GetITStatus+0x72>
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8000f38:	687b      	ldr	r3, [r7, #4]
 8000f3a:	8a9b      	ldrh	r3, [r3, #20]
 8000f3c:	b29b      	uxth	r3, r3
 8000f3e:	461a      	mov	r2, r3
 8000f40:	697b      	ldr	r3, [r7, #20]
 8000f42:	4013      	ands	r3, r2
 8000f44:	617b      	str	r3, [r7, #20]
  }
  
  bitpos = USART_IT >> 0x08;
 8000f46:	887b      	ldrh	r3, [r7, #2]
 8000f48:	0a1b      	lsrs	r3, r3, #8
 8000f4a:	b29b      	uxth	r3, r3
 8000f4c:	60fb      	str	r3, [r7, #12]
  bitpos = (uint32_t)0x01 << bitpos;
 8000f4e:	2201      	movs	r2, #1
 8000f50:	68fb      	ldr	r3, [r7, #12]
 8000f52:	fa02 f303 	lsl.w	r3, r2, r3
 8000f56:	60fb      	str	r3, [r7, #12]
  bitpos &= USARTx->SR;
 8000f58:	687b      	ldr	r3, [r7, #4]
 8000f5a:	881b      	ldrh	r3, [r3, #0]
 8000f5c:	b29b      	uxth	r3, r3
 8000f5e:	461a      	mov	r2, r3
 8000f60:	68fb      	ldr	r3, [r7, #12]
 8000f62:	4013      	ands	r3, r2
 8000f64:	60fb      	str	r3, [r7, #12]
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8000f66:	697b      	ldr	r3, [r7, #20]
 8000f68:	2b00      	cmp	r3, #0
 8000f6a:	d005      	beq.n	8000f78 <USART_GetITStatus+0xa4>
 8000f6c:	68fb      	ldr	r3, [r7, #12]
 8000f6e:	2b00      	cmp	r3, #0
 8000f70:	d002      	beq.n	8000f78 <USART_GetITStatus+0xa4>
  {
    bitstatus = SET;
 8000f72:	2301      	movs	r3, #1
 8000f74:	74fb      	strb	r3, [r7, #19]
 8000f76:	e001      	b.n	8000f7c <USART_GetITStatus+0xa8>
  }
  else
  {
    bitstatus = RESET;
 8000f78:	2300      	movs	r3, #0
 8000f7a:	74fb      	strb	r3, [r7, #19]
  }
  
  return bitstatus;  
 8000f7c:	7cfb      	ldrb	r3, [r7, #19]
}
 8000f7e:	4618      	mov	r0, r3
 8000f80:	371c      	adds	r7, #28
 8000f82:	46bd      	mov	sp, r7
 8000f84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000f88:	4770      	bx	lr

08000f8a <USART_ClearITPendingBit>:
  *          (USART_SendData()).
  *  
  * @retval None
  */
void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
{
 8000f8a:	b480      	push	{r7}
 8000f8c:	b085      	sub	sp, #20
 8000f8e:	af00      	add	r7, sp, #0
 8000f90:	6078      	str	r0, [r7, #4]
 8000f92:	460b      	mov	r3, r1
 8000f94:	807b      	strh	r3, [r7, #2]
  uint16_t bitpos = 0x00, itmask = 0x00;
 8000f96:	2300      	movs	r3, #0
 8000f98:	81fb      	strh	r3, [r7, #14]
 8000f9a:	2300      	movs	r3, #0
 8000f9c:	81bb      	strh	r3, [r7, #12]
  if (USART_IT == USART_IT_CTS)
  {
    assert_param(IS_USART_1236_PERIPH(USARTx));
  } 
    
  bitpos = USART_IT >> 0x08;
 8000f9e:	887b      	ldrh	r3, [r7, #2]
 8000fa0:	0a1b      	lsrs	r3, r3, #8
 8000fa2:	81fb      	strh	r3, [r7, #14]
  itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
 8000fa4:	89fb      	ldrh	r3, [r7, #14]
 8000fa6:	2201      	movs	r2, #1
 8000fa8:	fa02 f303 	lsl.w	r3, r2, r3
 8000fac:	81bb      	strh	r3, [r7, #12]
  USARTx->SR = (uint16_t)~itmask;
 8000fae:	89bb      	ldrh	r3, [r7, #12]
 8000fb0:	43db      	mvns	r3, r3
 8000fb2:	b29a      	uxth	r2, r3
 8000fb4:	687b      	ldr	r3, [r7, #4]
 8000fb6:	801a      	strh	r2, [r3, #0]
}
 8000fb8:	bf00      	nop
 8000fba:	3714      	adds	r7, #20
 8000fbc:	46bd      	mov	sp, r7
 8000fbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000fc2:	4770      	bx	lr

08000fc4 <FLASH_SetLatency>:
  *       FLASH_Latency_0 and FLASH_Latency_15. 
  *         
  * @retval None
  */
void FLASH_SetLatency(uint32_t FLASH_Latency)
{
 8000fc4:	b480      	push	{r7}
 8000fc6:	b083      	sub	sp, #12
 8000fc8:	af00      	add	r7, sp, #0
 8000fca:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));
  
  /* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
  *(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
 8000fcc:	4b04      	ldr	r3, [pc, #16]	; (8000fe0 <FLASH_SetLatency+0x1c>)
 8000fce:	687a      	ldr	r2, [r7, #4]
 8000fd0:	b2d2      	uxtb	r2, r2
 8000fd2:	701a      	strb	r2, [r3, #0]
}
 8000fd4:	bf00      	nop
 8000fd6:	370c      	adds	r7, #12
 8000fd8:	46bd      	mov	sp, r7
 8000fda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000fde:	4770      	bx	lr
 8000fe0:	40023c00 	.word	0x40023c00

08000fe4 <FLASH_PrefetchBufferCmd>:
  * @param  NewState: new state of the Prefetch Buffer.
  *          This parameter  can be: ENABLE or DISABLE.
  * @retval None
  */
void FLASH_PrefetchBufferCmd(FunctionalState NewState)
{
 8000fe4:	b480      	push	{r7}
 8000fe6:	b083      	sub	sp, #12
 8000fe8:	af00      	add	r7, sp, #0
 8000fea:	4603      	mov	r3, r0
 8000fec:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  /* Enable or disable the Prefetch Buffer */
  if(NewState != DISABLE)
 8000fee:	79fb      	ldrb	r3, [r7, #7]
 8000ff0:	2b00      	cmp	r3, #0
 8000ff2:	d006      	beq.n	8001002 <FLASH_PrefetchBufferCmd+0x1e>
  {
    FLASH->ACR |= FLASH_ACR_PRFTEN;
 8000ff4:	4b09      	ldr	r3, [pc, #36]	; (800101c <FLASH_PrefetchBufferCmd+0x38>)
 8000ff6:	681b      	ldr	r3, [r3, #0]
 8000ff8:	4a08      	ldr	r2, [pc, #32]	; (800101c <FLASH_PrefetchBufferCmd+0x38>)
 8000ffa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000ffe:	6013      	str	r3, [r2, #0]
  }
  else
  {
    FLASH->ACR &= (~FLASH_ACR_PRFTEN);
  }
}
 8001000:	e005      	b.n	800100e <FLASH_PrefetchBufferCmd+0x2a>
    FLASH->ACR &= (~FLASH_ACR_PRFTEN);
 8001002:	4b06      	ldr	r3, [pc, #24]	; (800101c <FLASH_PrefetchBufferCmd+0x38>)
 8001004:	681b      	ldr	r3, [r3, #0]
 8001006:	4a05      	ldr	r2, [pc, #20]	; (800101c <FLASH_PrefetchBufferCmd+0x38>)
 8001008:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800100c:	6013      	str	r3, [r2, #0]
}
 800100e:	bf00      	nop
 8001010:	370c      	adds	r7, #12
 8001012:	46bd      	mov	sp, r7
 8001014:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001018:	4770      	bx	lr
 800101a:	bf00      	nop
 800101c:	40023c00 	.word	0x40023c00

08001020 <FLASH_Unlock>:
  * @brief  Unlocks the FLASH control register access
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
 8001020:	b480      	push	{r7}
 8001022:	af00      	add	r7, sp, #0
  if((FLASH->CR & FLASH_CR_LOCK) != RESET)
 8001024:	4b07      	ldr	r3, [pc, #28]	; (8001044 <FLASH_Unlock+0x24>)
 8001026:	691b      	ldr	r3, [r3, #16]
 8001028:	2b00      	cmp	r3, #0
 800102a:	da05      	bge.n	8001038 <FLASH_Unlock+0x18>
  {
    /* Authorize the FLASH Registers access */
    FLASH->KEYR = FLASH_KEY1;
 800102c:	4b05      	ldr	r3, [pc, #20]	; (8001044 <FLASH_Unlock+0x24>)
 800102e:	4a06      	ldr	r2, [pc, #24]	; (8001048 <FLASH_Unlock+0x28>)
 8001030:	605a      	str	r2, [r3, #4]
    FLASH->KEYR = FLASH_KEY2;
 8001032:	4b04      	ldr	r3, [pc, #16]	; (8001044 <FLASH_Unlock+0x24>)
 8001034:	4a05      	ldr	r2, [pc, #20]	; (800104c <FLASH_Unlock+0x2c>)
 8001036:	605a      	str	r2, [r3, #4]
  }  
}
 8001038:	bf00      	nop
 800103a:	46bd      	mov	sp, r7
 800103c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001040:	4770      	bx	lr
 8001042:	bf00      	nop
 8001044:	40023c00 	.word	0x40023c00
 8001048:	45670123 	.word	0x45670123
 800104c:	cdef89ab 	.word	0xcdef89ab

08001050 <FLASH_Lock>:
  * @brief  Locks the FLASH control register access
  * @param  None
  * @retval None
  */
void FLASH_Lock(void)
{
 8001050:	b480      	push	{r7}
 8001052:	af00      	add	r7, sp, #0
  /* Set the LOCK Bit to lock the FLASH Registers access */
  FLASH->CR |= FLASH_CR_LOCK;
 8001054:	4b05      	ldr	r3, [pc, #20]	; (800106c <FLASH_Lock+0x1c>)
 8001056:	691b      	ldr	r3, [r3, #16]
 8001058:	4a04      	ldr	r2, [pc, #16]	; (800106c <FLASH_Lock+0x1c>)
 800105a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800105e:	6113      	str	r3, [r2, #16]
}
 8001060:	bf00      	nop
 8001062:	46bd      	mov	sp, r7
 8001064:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001068:	4770      	bx	lr
 800106a:	bf00      	nop
 800106c:	40023c00 	.word	0x40023c00

08001070 <FLASH_EraseSector>:
  *       
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
{
 8001070:	b580      	push	{r7, lr}
 8001072:	b084      	sub	sp, #16
 8001074:	af00      	add	r7, sp, #0
 8001076:	6078      	str	r0, [r7, #4]
 8001078:	460b      	mov	r3, r1
 800107a:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp_psize = 0x0;
 800107c:	2300      	movs	r3, #0
 800107e:	60fb      	str	r3, [r7, #12]
  FLASH_Status status = FLASH_COMPLETE;
 8001080:	2309      	movs	r3, #9
 8001082:	72fb      	strb	r3, [r7, #11]

  /* Check the parameters */
  assert_param(IS_FLASH_SECTOR(FLASH_Sector));
  assert_param(IS_VOLTAGERANGE(VoltageRange));
  
  if(VoltageRange == VoltageRange_1)
 8001084:	78fb      	ldrb	r3, [r7, #3]
 8001086:	2b00      	cmp	r3, #0
 8001088:	d102      	bne.n	8001090 <FLASH_EraseSector+0x20>
  {
     tmp_psize = FLASH_PSIZE_BYTE;
 800108a:	2300      	movs	r3, #0
 800108c:	60fb      	str	r3, [r7, #12]
 800108e:	e010      	b.n	80010b2 <FLASH_EraseSector+0x42>
  }
  else if(VoltageRange == VoltageRange_2)
 8001090:	78fb      	ldrb	r3, [r7, #3]
 8001092:	2b01      	cmp	r3, #1
 8001094:	d103      	bne.n	800109e <FLASH_EraseSector+0x2e>
  {
    tmp_psize = FLASH_PSIZE_HALF_WORD;
 8001096:	f44f 7380 	mov.w	r3, #256	; 0x100
 800109a:	60fb      	str	r3, [r7, #12]
 800109c:	e009      	b.n	80010b2 <FLASH_EraseSector+0x42>
  }
  else if(VoltageRange == VoltageRange_3)
 800109e:	78fb      	ldrb	r3, [r7, #3]
 80010a0:	2b02      	cmp	r3, #2
 80010a2:	d103      	bne.n	80010ac <FLASH_EraseSector+0x3c>
  {
    tmp_psize = FLASH_PSIZE_WORD;
 80010a4:	f44f 7300 	mov.w	r3, #512	; 0x200
 80010a8:	60fb      	str	r3, [r7, #12]
 80010aa:	e002      	b.n	80010b2 <FLASH_EraseSector+0x42>
  }
  else
  {
    tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
 80010ac:	f44f 7340 	mov.w	r3, #768	; 0x300
 80010b0:	60fb      	str	r3, [r7, #12]
  }
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 80010b2:	f000 f8bf 	bl	8001234 <FLASH_WaitForLastOperation>
 80010b6:	4603      	mov	r3, r0
 80010b8:	72fb      	strb	r3, [r7, #11]
  
  if(status == FLASH_COMPLETE)
 80010ba:	7afb      	ldrb	r3, [r7, #11]
 80010bc:	2b09      	cmp	r3, #9
 80010be:	d12f      	bne.n	8001120 <FLASH_EraseSector+0xb0>
  { 
    /* if the previous operation is completed, proceed to erase the sector */
    FLASH->CR &= CR_PSIZE_MASK;
 80010c0:	4b1a      	ldr	r3, [pc, #104]	; (800112c <FLASH_EraseSector+0xbc>)
 80010c2:	691b      	ldr	r3, [r3, #16]
 80010c4:	4a19      	ldr	r2, [pc, #100]	; (800112c <FLASH_EraseSector+0xbc>)
 80010c6:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80010ca:	6113      	str	r3, [r2, #16]
    FLASH->CR |= tmp_psize;
 80010cc:	4b17      	ldr	r3, [pc, #92]	; (800112c <FLASH_EraseSector+0xbc>)
 80010ce:	691a      	ldr	r2, [r3, #16]
 80010d0:	4916      	ldr	r1, [pc, #88]	; (800112c <FLASH_EraseSector+0xbc>)
 80010d2:	68fb      	ldr	r3, [r7, #12]
 80010d4:	4313      	orrs	r3, r2
 80010d6:	610b      	str	r3, [r1, #16]
    FLASH->CR &= SECTOR_MASK;
 80010d8:	4b14      	ldr	r3, [pc, #80]	; (800112c <FLASH_EraseSector+0xbc>)
 80010da:	691b      	ldr	r3, [r3, #16]
 80010dc:	4a13      	ldr	r2, [pc, #76]	; (800112c <FLASH_EraseSector+0xbc>)
 80010de:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 80010e2:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
 80010e4:	4b11      	ldr	r3, [pc, #68]	; (800112c <FLASH_EraseSector+0xbc>)
 80010e6:	691a      	ldr	r2, [r3, #16]
 80010e8:	687b      	ldr	r3, [r7, #4]
 80010ea:	4313      	orrs	r3, r2
 80010ec:	4a0f      	ldr	r2, [pc, #60]	; (800112c <FLASH_EraseSector+0xbc>)
 80010ee:	f043 0302 	orr.w	r3, r3, #2
 80010f2:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_STRT;
 80010f4:	4b0d      	ldr	r3, [pc, #52]	; (800112c <FLASH_EraseSector+0xbc>)
 80010f6:	691b      	ldr	r3, [r3, #16]
 80010f8:	4a0c      	ldr	r2, [pc, #48]	; (800112c <FLASH_EraseSector+0xbc>)
 80010fa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80010fe:	6113      	str	r3, [r2, #16]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8001100:	f000 f898 	bl	8001234 <FLASH_WaitForLastOperation>
 8001104:	4603      	mov	r3, r0
 8001106:	72fb      	strb	r3, [r7, #11]
    
    /* if the erase operation is completed, disable the SER Bit */
    FLASH->CR &= (~FLASH_CR_SER);
 8001108:	4b08      	ldr	r3, [pc, #32]	; (800112c <FLASH_EraseSector+0xbc>)
 800110a:	691b      	ldr	r3, [r3, #16]
 800110c:	4a07      	ldr	r2, [pc, #28]	; (800112c <FLASH_EraseSector+0xbc>)
 800110e:	f023 0302 	bic.w	r3, r3, #2
 8001112:	6113      	str	r3, [r2, #16]
    FLASH->CR &= SECTOR_MASK; 
 8001114:	4b05      	ldr	r3, [pc, #20]	; (800112c <FLASH_EraseSector+0xbc>)
 8001116:	691b      	ldr	r3, [r3, #16]
 8001118:	4a04      	ldr	r2, [pc, #16]	; (800112c <FLASH_EraseSector+0xbc>)
 800111a:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800111e:	6113      	str	r3, [r2, #16]
  }
  /* Return the Erase Status */
  return status;
 8001120:	7afb      	ldrb	r3, [r7, #11]
}
 8001122:	4618      	mov	r0, r3
 8001124:	3710      	adds	r7, #16
 8001126:	46bd      	mov	sp, r7
 8001128:	bd80      	pop	{r7, pc}
 800112a:	bf00      	nop
 800112c:	40023c00 	.word	0x40023c00

08001130 <FLASH_ProgramWord>:
  * @param  Data: specifies the data to be programmed.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
{
 8001130:	b580      	push	{r7, lr}
 8001132:	b084      	sub	sp, #16
 8001134:	af00      	add	r7, sp, #0
 8001136:	6078      	str	r0, [r7, #4]
 8001138:	6039      	str	r1, [r7, #0]
  FLASH_Status status = FLASH_COMPLETE;
 800113a:	2309      	movs	r3, #9
 800113c:	73fb      	strb	r3, [r7, #15]

  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Address));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation();
 800113e:	f000 f879 	bl	8001234 <FLASH_WaitForLastOperation>
 8001142:	4603      	mov	r3, r0
 8001144:	73fb      	strb	r3, [r7, #15]
  
  if(status == FLASH_COMPLETE)
 8001146:	7bfb      	ldrb	r3, [r7, #15]
 8001148:	2b09      	cmp	r3, #9
 800114a:	d11e      	bne.n	800118a <FLASH_ProgramWord+0x5a>
  {
    /* if the previous operation is completed, proceed to program the new data */
    FLASH->CR &= CR_PSIZE_MASK;
 800114c:	4b11      	ldr	r3, [pc, #68]	; (8001194 <FLASH_ProgramWord+0x64>)
 800114e:	691b      	ldr	r3, [r3, #16]
 8001150:	4a10      	ldr	r2, [pc, #64]	; (8001194 <FLASH_ProgramWord+0x64>)
 8001152:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001156:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_PSIZE_WORD;
 8001158:	4b0e      	ldr	r3, [pc, #56]	; (8001194 <FLASH_ProgramWord+0x64>)
 800115a:	691b      	ldr	r3, [r3, #16]
 800115c:	4a0d      	ldr	r2, [pc, #52]	; (8001194 <FLASH_ProgramWord+0x64>)
 800115e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001162:	6113      	str	r3, [r2, #16]
    FLASH->CR |= FLASH_CR_PG;
 8001164:	4b0b      	ldr	r3, [pc, #44]	; (8001194 <FLASH_ProgramWord+0x64>)
 8001166:	691b      	ldr	r3, [r3, #16]
 8001168:	4a0a      	ldr	r2, [pc, #40]	; (8001194 <FLASH_ProgramWord+0x64>)
 800116a:	f043 0301 	orr.w	r3, r3, #1
 800116e:	6113      	str	r3, [r2, #16]
  
    *(__IO uint32_t*)Address = Data;
 8001170:	687b      	ldr	r3, [r7, #4]
 8001172:	683a      	ldr	r2, [r7, #0]
 8001174:	601a      	str	r2, [r3, #0]
        
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation();
 8001176:	f000 f85d 	bl	8001234 <FLASH_WaitForLastOperation>
 800117a:	4603      	mov	r3, r0
 800117c:	73fb      	strb	r3, [r7, #15]

    /* if the program operation is completed, disable the PG Bit */
    FLASH->CR &= (~FLASH_CR_PG);
 800117e:	4b05      	ldr	r3, [pc, #20]	; (8001194 <FLASH_ProgramWord+0x64>)
 8001180:	691b      	ldr	r3, [r3, #16]
 8001182:	4a04      	ldr	r2, [pc, #16]	; (8001194 <FLASH_ProgramWord+0x64>)
 8001184:	f023 0301 	bic.w	r3, r3, #1
 8001188:	6113      	str	r3, [r2, #16]
  } 
  /* Return the Program Status */
  return status;
 800118a:	7bfb      	ldrb	r3, [r7, #15]
}
 800118c:	4618      	mov	r0, r3
 800118e:	3710      	adds	r7, #16
 8001190:	46bd      	mov	sp, r7
 8001192:	bd80      	pop	{r7, pc}
 8001194:	40023c00 	.word	0x40023c00

08001198 <FLASH_ClearFlag>:
  *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
  *            @arg FLASH_FLAG_RDERR: FLASH Read Protection error flag (STM32F42xx/43xxx and STM32F401xx/411xE devices)   
  * @retval None
  */
void FLASH_ClearFlag(uint32_t FLASH_FLAG)
{
 8001198:	b480      	push	{r7}
 800119a:	b083      	sub	sp, #12
 800119c:	af00      	add	r7, sp, #0
 800119e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
  
  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 80011a0:	4a04      	ldr	r2, [pc, #16]	; (80011b4 <FLASH_ClearFlag+0x1c>)
 80011a2:	687b      	ldr	r3, [r7, #4]
 80011a4:	60d3      	str	r3, [r2, #12]
}
 80011a6:	bf00      	nop
 80011a8:	370c      	adds	r7, #12
 80011aa:	46bd      	mov	sp, r7
 80011ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80011b0:	4770      	bx	lr
 80011b2:	bf00      	nop
 80011b4:	40023c00 	.word	0x40023c00

080011b8 <FLASH_GetStatus>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_RD, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_GetStatus(void)
{
 80011b8:	b480      	push	{r7}
 80011ba:	b083      	sub	sp, #12
 80011bc:	af00      	add	r7, sp, #0
  FLASH_Status flashstatus = FLASH_COMPLETE;
 80011be:	2309      	movs	r3, #9
 80011c0:	71fb      	strb	r3, [r7, #7]
  
  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
 80011c2:	4b1b      	ldr	r3, [pc, #108]	; (8001230 <FLASH_GetStatus+0x78>)
 80011c4:	68db      	ldr	r3, [r3, #12]
 80011c6:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80011ca:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80011ce:	d102      	bne.n	80011d6 <FLASH_GetStatus+0x1e>
  {
    flashstatus = FLASH_BUSY;
 80011d0:	2301      	movs	r3, #1
 80011d2:	71fb      	strb	r3, [r7, #7]
 80011d4:	e025      	b.n	8001222 <FLASH_GetStatus+0x6a>
  }
  else 
  {  
    if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
 80011d6:	4b16      	ldr	r3, [pc, #88]	; (8001230 <FLASH_GetStatus+0x78>)
 80011d8:	68db      	ldr	r3, [r3, #12]
 80011da:	f003 0310 	and.w	r3, r3, #16
 80011de:	2b00      	cmp	r3, #0
 80011e0:	d002      	beq.n	80011e8 <FLASH_GetStatus+0x30>
    { 
      flashstatus = FLASH_ERROR_WRP;
 80011e2:	2306      	movs	r3, #6
 80011e4:	71fb      	strb	r3, [r7, #7]
 80011e6:	e01c      	b.n	8001222 <FLASH_GetStatus+0x6a>
    }
    else
    {
      if((FLASH->SR & FLASH_FLAG_RDERR) != (uint32_t)0x00)
 80011e8:	4b11      	ldr	r3, [pc, #68]	; (8001230 <FLASH_GetStatus+0x78>)
 80011ea:	68db      	ldr	r3, [r3, #12]
 80011ec:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80011f0:	2b00      	cmp	r3, #0
 80011f2:	d002      	beq.n	80011fa <FLASH_GetStatus+0x42>
      { 
        flashstatus = FLASH_ERROR_RD;
 80011f4:	2302      	movs	r3, #2
 80011f6:	71fb      	strb	r3, [r7, #7]
 80011f8:	e013      	b.n	8001222 <FLASH_GetStatus+0x6a>
      } 
      else 
      {
        if((FLASH->SR & (uint32_t)0xE0) != (uint32_t)0x00)
 80011fa:	4b0d      	ldr	r3, [pc, #52]	; (8001230 <FLASH_GetStatus+0x78>)
 80011fc:	68db      	ldr	r3, [r3, #12]
 80011fe:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 8001202:	2b00      	cmp	r3, #0
 8001204:	d002      	beq.n	800120c <FLASH_GetStatus+0x54>
        {
          flashstatus = FLASH_ERROR_PROGRAM; 
 8001206:	2307      	movs	r3, #7
 8001208:	71fb      	strb	r3, [r7, #7]
 800120a:	e00a      	b.n	8001222 <FLASH_GetStatus+0x6a>
        }
        else
        {
          if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
 800120c:	4b08      	ldr	r3, [pc, #32]	; (8001230 <FLASH_GetStatus+0x78>)
 800120e:	68db      	ldr	r3, [r3, #12]
 8001210:	f003 0302 	and.w	r3, r3, #2
 8001214:	2b00      	cmp	r3, #0
 8001216:	d002      	beq.n	800121e <FLASH_GetStatus+0x66>
          {
            flashstatus = FLASH_ERROR_OPERATION;
 8001218:	2308      	movs	r3, #8
 800121a:	71fb      	strb	r3, [r7, #7]
 800121c:	e001      	b.n	8001222 <FLASH_GetStatus+0x6a>
          }
          else
          {
            flashstatus = FLASH_COMPLETE;
 800121e:	2309      	movs	r3, #9
 8001220:	71fb      	strb	r3, [r7, #7]
        }
      }
    }
  }
  /* Return the FLASH Status */
  return flashstatus;
 8001222:	79fb      	ldrb	r3, [r7, #7]
}
 8001224:	4618      	mov	r0, r3
 8001226:	370c      	adds	r7, #12
 8001228:	46bd      	mov	sp, r7
 800122a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800122e:	4770      	bx	lr
 8001230:	40023c00 	.word	0x40023c00

08001234 <FLASH_WaitForLastOperation>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
  *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
  */
FLASH_Status FLASH_WaitForLastOperation(void)
{ 
 8001234:	b580      	push	{r7, lr}
 8001236:	b082      	sub	sp, #8
 8001238:	af00      	add	r7, sp, #0
  __IO FLASH_Status status = FLASH_COMPLETE;
 800123a:	2309      	movs	r3, #9
 800123c:	71fb      	strb	r3, [r7, #7]
   
  /* Check for the FLASH Status */
  status = FLASH_GetStatus();
 800123e:	f7ff ffbb 	bl	80011b8 <FLASH_GetStatus>
 8001242:	4603      	mov	r3, r0
 8001244:	71fb      	strb	r3, [r7, #7]

  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */
  while(status == FLASH_BUSY)
 8001246:	e003      	b.n	8001250 <FLASH_WaitForLastOperation+0x1c>
  {
    status = FLASH_GetStatus();
 8001248:	f7ff ffb6 	bl	80011b8 <FLASH_GetStatus>
 800124c:	4603      	mov	r3, r0
 800124e:	71fb      	strb	r3, [r7, #7]
  while(status == FLASH_BUSY)
 8001250:	79fb      	ldrb	r3, [r7, #7]
 8001252:	b2db      	uxtb	r3, r3
 8001254:	2b01      	cmp	r3, #1
 8001256:	d0f7      	beq.n	8001248 <FLASH_WaitForLastOperation+0x14>
  }
  /* Return the operation status */
  return status;
 8001258:	79fb      	ldrb	r3, [r7, #7]
 800125a:	b2db      	uxtb	r3, r3
}
 800125c:	4618      	mov	r0, r3
 800125e:	3708      	adds	r7, #8
 8001260:	46bd      	mov	sp, r7
 8001262:	bd80      	pop	{r7, pc}

08001264 <Button_Init>:
 * @brief  Initialize module button
 * @param  None
 * @retval None
 */
void
Button_Init(void) {
 8001264:	b580      	push	{r7, lr}
 8001266:	b084      	sub	sp, #16
 8001268:	af02      	add	r7, sp, #8
    // Initialize gpio
	BTNGPIO_Init();
 800126a:	f000 f9b1 	bl	80015d0 <BTNGPIO_Init>

    for (uint8_t i = 0; i < BUTTON_MAX; i++) {
 800126e:	2300      	movs	r3, #0
 8001270:	71fb      	strb	r3, [r7, #7]
 8001272:	e036      	b.n	80012e2 <Button_Init+0x7e>
		kpad[i].index = i;
 8001274:	79fa      	ldrb	r2, [r7, #7]
 8001276:	4924      	ldr	r1, [pc, #144]	; (8001308 <Button_Init+0xa4>)
 8001278:	4613      	mov	r3, r2
 800127a:	009b      	lsls	r3, r3, #2
 800127c:	4413      	add	r3, r2
 800127e:	009b      	lsls	r3, r3, #2
 8001280:	440b      	add	r3, r1
 8001282:	330a      	adds	r3, #10
 8001284:	79fa      	ldrb	r2, [r7, #7]
 8001286:	701a      	strb	r2, [r3, #0]
		kpad[i].scanBtnFunc = ButtonScanTypeEdge;
 8001288:	79fa      	ldrb	r2, [r7, #7]
 800128a:	491f      	ldr	r1, [pc, #124]	; (8001308 <Button_Init+0xa4>)
 800128c:	4613      	mov	r3, r2
 800128e:	009b      	lsls	r3, r3, #2
 8001290:	4413      	add	r3, r2
 8001292:	009b      	lsls	r3, r3, #2
 8001294:	440b      	add	r3, r1
 8001296:	3310      	adds	r3, #16
 8001298:	4a1c      	ldr	r2, [pc, #112]	; (800130c <Button_Init+0xa8>)
 800129a:	601a      	str	r2, [r3, #0]
		if (GPIO_ReadInputDataBit(pinBtnPad[i].port, pinBtnPad[i].pin) == pinBtnPad[i].logicPress) {
 800129c:	79fb      	ldrb	r3, [r7, #7]
 800129e:	4a1c      	ldr	r2, [pc, #112]	; (8001310 <Button_Init+0xac>)
 80012a0:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 80012a4:	79fb      	ldrb	r3, [r7, #7]
 80012a6:	491a      	ldr	r1, [pc, #104]	; (8001310 <Button_Init+0xac>)
 80012a8:	00db      	lsls	r3, r3, #3
 80012aa:	440b      	add	r3, r1
 80012ac:	889b      	ldrh	r3, [r3, #4]
 80012ae:	4619      	mov	r1, r3
 80012b0:	4610      	mov	r0, r2
 80012b2:	f7ff f97e 	bl	80005b2 <GPIO_ReadInputDataBit>
 80012b6:	4603      	mov	r3, r0
 80012b8:	4619      	mov	r1, r3
 80012ba:	79fb      	ldrb	r3, [r7, #7]
 80012bc:	4a14      	ldr	r2, [pc, #80]	; (8001310 <Button_Init+0xac>)
 80012be:	00db      	lsls	r3, r3, #3
 80012c0:	4413      	add	r3, r2
 80012c2:	799b      	ldrb	r3, [r3, #6]
 80012c4:	4299      	cmp	r1, r3
 80012c6:	d109      	bne.n	80012dc <Button_Init+0x78>
			kpad[i].sold = PIN_ACTIVE;
 80012c8:	79fa      	ldrb	r2, [r7, #7]
 80012ca:	490f      	ldr	r1, [pc, #60]	; (8001308 <Button_Init+0xa4>)
 80012cc:	4613      	mov	r3, r2
 80012ce:	009b      	lsls	r3, r3, #2
 80012d0:	4413      	add	r3, r2
 80012d2:	009b      	lsls	r3, r3, #2
 80012d4:	440b      	add	r3, r1
 80012d6:	3309      	adds	r3, #9
 80012d8:	2201      	movs	r2, #1
 80012da:	701a      	strb	r2, [r3, #0]
    for (uint8_t i = 0; i < BUTTON_MAX; i++) {
 80012dc:	79fb      	ldrb	r3, [r7, #7]
 80012de:	3301      	adds	r3, #1
 80012e0:	71fb      	strb	r3, [r7, #7]
 80012e2:	79fb      	ldrb	r3, [r7, #7]
 80012e4:	2b05      	cmp	r3, #5
 80012e6:	d9c5      	bls.n	8001274 <Button_Init+0x10>
		}
	}

    idTaskScanButton = TimerStart("", KEY_TIME_SCAN, TIMER_REPEAT_FOREVER, ButtonScan, NULL);
 80012e8:	2300      	movs	r3, #0
 80012ea:	9300      	str	r3, [sp, #0]
 80012ec:	4b09      	ldr	r3, [pc, #36]	; (8001314 <Button_Init+0xb0>)
 80012ee:	22ff      	movs	r2, #255	; 0xff
 80012f0:	2105      	movs	r1, #5
 80012f2:	4809      	ldr	r0, [pc, #36]	; (8001318 <Button_Init+0xb4>)
 80012f4:	f001 f810 	bl	8002318 <TimerStart>
 80012f8:	4603      	mov	r3, r0
 80012fa:	461a      	mov	r2, r3
 80012fc:	4b07      	ldr	r3, [pc, #28]	; (800131c <Button_Init+0xb8>)
 80012fe:	701a      	strb	r2, [r3, #0]
}
 8001300:	bf00      	nop
 8001302:	3708      	adds	r7, #8
 8001304:	46bd      	mov	sp, r7
 8001306:	bd80      	pop	{r7, pc}
 8001308:	20000138 	.word	0x20000138
 800130c:	08001385 	.word	0x08001385
 8001310:	20000024 	.word	0x20000024
 8001314:	08001585 	.word	0x08001585
 8001318:	08006900 	.word	0x08006900
 800131c:	20000054 	.word	0x20000054

08001320 <Button_SetMode>:
 */
void
Button_SetMode(
    uint8_t id,
    uint8_t mode
) {
 8001320:	b480      	push	{r7}
 8001322:	b083      	sub	sp, #12
 8001324:	af00      	add	r7, sp, #0
 8001326:	4603      	mov	r3, r0
 8001328:	460a      	mov	r2, r1
 800132a:	71fb      	strb	r3, [r7, #7]
 800132c:	4613      	mov	r3, r2
 800132e:	71bb      	strb	r3, [r7, #6]
    if (id >= BUTTON_MAX) return;
 8001330:	79fb      	ldrb	r3, [r7, #7]
 8001332:	2b05      	cmp	r3, #5
 8001334:	d80a      	bhi.n	800134c <Button_SetMode+0x2c>
    kpad[id].mode = mode;
 8001336:	79fa      	ldrb	r2, [r7, #7]
 8001338:	4907      	ldr	r1, [pc, #28]	; (8001358 <Button_SetMode+0x38>)
 800133a:	4613      	mov	r3, r2
 800133c:	009b      	lsls	r3, r3, #2
 800133e:	4413      	add	r3, r2
 8001340:	009b      	lsls	r3, r3, #2
 8001342:	440b      	add	r3, r1
 8001344:	330b      	adds	r3, #11
 8001346:	79ba      	ldrb	r2, [r7, #6]
 8001348:	701a      	strb	r2, [r3, #0]
 800134a:	e000      	b.n	800134e <Button_SetMode+0x2e>
    if (id >= BUTTON_MAX) return;
 800134c:	bf00      	nop
}
 800134e:	370c      	adds	r7, #12
 8001350:	46bd      	mov	sp, r7
 8001352:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001356:	4770      	bx	lr
 8001358:	20000138 	.word	0x20000138

0800135c <Button_RegisterEventCallback>:
 */
void
Button_RegisterEventCallback(
    button_event_t buttonEvent,
    button_event_callback procbuttonEvent
) {
 800135c:	b480      	push	{r7}
 800135e:	b083      	sub	sp, #12
 8001360:	af00      	add	r7, sp, #0
 8001362:	4603      	mov	r3, r0
 8001364:	6039      	str	r1, [r7, #0]
 8001366:	71fb      	strb	r3, [r7, #7]
    pEventCallbacks[buttonEvent] = procbuttonEvent;
 8001368:	79fb      	ldrb	r3, [r7, #7]
 800136a:	4905      	ldr	r1, [pc, #20]	; (8001380 <Button_RegisterEventCallback+0x24>)
 800136c:	683a      	ldr	r2, [r7, #0]
 800136e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 8001372:	bf00      	nop
 8001374:	370c      	adds	r7, #12
 8001376:	46bd      	mov	sp, r7
 8001378:	f85d 7b04 	ldr.w	r7, [sp], #4
 800137c:	4770      	bx	lr
 800137e:	bf00      	nop
 8001380:	200001b0 	.word	0x200001b0

08001384 <ButtonScanTypeEdge>:
 * @retval None
 */
void
ButtonScanTypeEdge(
    void *arg
) {
 8001384:	b580      	push	{r7, lr}
 8001386:	b084      	sub	sp, #16
 8001388:	af00      	add	r7, sp, #0
 800138a:	6078      	str	r0, [r7, #4]
	buttondat_p bt = (buttondat_p)arg;
 800138c:	687b      	ldr	r3, [r7, #4]
 800138e:	60fb      	str	r3, [r7, #12]
    uint8_t i = bt->index;
 8001390:	68fb      	ldr	r3, [r7, #12]
 8001392:	7a9b      	ldrb	r3, [r3, #10]
 8001394:	72fb      	strb	r3, [r7, #11]
    
    if (GPIO_ReadInputDataBit(pinBtnPad[i].port, pinBtnPad[i].pin) == pinBtnPad[i].logicPress) {
 8001396:	7afb      	ldrb	r3, [r7, #11]
 8001398:	4a78      	ldr	r2, [pc, #480]	; (800157c <ButtonScanTypeEdge+0x1f8>)
 800139a:	f852 2033 	ldr.w	r2, [r2, r3, lsl #3]
 800139e:	7afb      	ldrb	r3, [r7, #11]
 80013a0:	4976      	ldr	r1, [pc, #472]	; (800157c <ButtonScanTypeEdge+0x1f8>)
 80013a2:	00db      	lsls	r3, r3, #3
 80013a4:	440b      	add	r3, r1
 80013a6:	889b      	ldrh	r3, [r3, #4]
 80013a8:	4619      	mov	r1, r3
 80013aa:	4610      	mov	r0, r2
 80013ac:	f7ff f901 	bl	80005b2 <GPIO_ReadInputDataBit>
 80013b0:	4603      	mov	r3, r0
 80013b2:	4619      	mov	r1, r3
 80013b4:	7afb      	ldrb	r3, [r7, #11]
 80013b6:	4a71      	ldr	r2, [pc, #452]	; (800157c <ButtonScanTypeEdge+0x1f8>)
 80013b8:	00db      	lsls	r3, r3, #3
 80013ba:	4413      	add	r3, r2
 80013bc:	799b      	ldrb	r3, [r3, #6]
 80013be:	4299      	cmp	r1, r3
 80013c0:	d10a      	bne.n	80013d8 <ButtonScanTypeEdge+0x54>
        if (bt->countActive != 0xFFU) {
 80013c2:	68fb      	ldr	r3, [r7, #12]
 80013c4:	7b5b      	ldrb	r3, [r3, #13]
 80013c6:	2bff      	cmp	r3, #255	; 0xff
 80013c8:	d013      	beq.n	80013f2 <ButtonScanTypeEdge+0x6e>
            bt->countActive++;
 80013ca:	68fb      	ldr	r3, [r7, #12]
 80013cc:	7b5b      	ldrb	r3, [r3, #13]
 80013ce:	3301      	adds	r3, #1
 80013d0:	b2da      	uxtb	r2, r3
 80013d2:	68fb      	ldr	r3, [r7, #12]
 80013d4:	735a      	strb	r2, [r3, #13]
 80013d6:	e00c      	b.n	80013f2 <ButtonScanTypeEdge+0x6e>
        }
    }
    else {
        if (bt->countInactive != 0xFFU) {
 80013d8:	68fb      	ldr	r3, [r7, #12]
 80013da:	7b1b      	ldrb	r3, [r3, #12]
 80013dc:	2bff      	cmp	r3, #255	; 0xff
 80013de:	d005      	beq.n	80013ec <ButtonScanTypeEdge+0x68>
            bt->countInactive++;
 80013e0:	68fb      	ldr	r3, [r7, #12]
 80013e2:	7b1b      	ldrb	r3, [r3, #12]
 80013e4:	3301      	adds	r3, #1
 80013e6:	b2da      	uxtb	r2, r3
 80013e8:	68fb      	ldr	r3, [r7, #12]
 80013ea:	731a      	strb	r2, [r3, #12]
        }
        
        bt->countActive = 0;
 80013ec:	68fb      	ldr	r3, [r7, #12]
 80013ee:	2200      	movs	r2, #0
 80013f0:	735a      	strb	r2, [r3, #13]
    }
    
    if (bt->countInactive >= KEY_COUNT_IS_PRESS) {
 80013f2:	68fb      	ldr	r3, [r7, #12]
 80013f4:	7b1b      	ldrb	r3, [r3, #12]
 80013f6:	2b09      	cmp	r3, #9
 80013f8:	d958      	bls.n	80014ac <ButtonScanTypeEdge+0x128>
        if (bt->sold == PIN_ACTIVE) {
 80013fa:	68fb      	ldr	r3, [r7, #12]
 80013fc:	7a5b      	ldrb	r3, [r3, #9]
 80013fe:	2b01      	cmp	r3, #1
 8001400:	d118      	bne.n	8001434 <ButtonScanTypeEdge+0xb0>
            bt->sold = PIN_UNACTIVE;
 8001402:	68fb      	ldr	r3, [r7, #12]
 8001404:	2200      	movs	r2, #0
 8001406:	725a      	strb	r2, [r3, #9]
            
            if ((pEventCallbacks[BUTTON_EVENT_EDGE] != NULL) && (bt->mode & BUTTON_TYPE_EDGE)) {
 8001408:	4b5d      	ldr	r3, [pc, #372]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 800140a:	681b      	ldr	r3, [r3, #0]
 800140c:	2b00      	cmp	r3, #0
 800140e:	d00b      	beq.n	8001428 <ButtonScanTypeEdge+0xa4>
 8001410:	68fb      	ldr	r3, [r7, #12]
 8001412:	7adb      	ldrb	r3, [r3, #11]
 8001414:	f003 0302 	and.w	r3, r3, #2
 8001418:	2b00      	cmp	r3, #0
 800141a:	d005      	beq.n	8001428 <ButtonScanTypeEdge+0xa4>
                pEventCallbacks[BUTTON_EVENT_EDGE](i, BUTTON_EDGE_FALLING);
 800141c:	4b58      	ldr	r3, [pc, #352]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 800141e:	681b      	ldr	r3, [r3, #0]
 8001420:	7afa      	ldrb	r2, [r7, #11]
 8001422:	2101      	movs	r1, #1
 8001424:	4610      	mov	r0, r2
 8001426:	4798      	blx	r3
            }
            
            bt->time = bt->countInactive;
 8001428:	68fb      	ldr	r3, [r7, #12]
 800142a:	7b1b      	ldrb	r3, [r3, #12]
 800142c:	461a      	mov	r2, r3
 800142e:	68fb      	ldr	r3, [r7, #12]
 8001430:	601a      	str	r2, [r3, #0]
 8001432:	e03b      	b.n	80014ac <ButtonScanTypeEdge+0x128>
        } else {
            bt->time++;
 8001434:	68fb      	ldr	r3, [r7, #12]
 8001436:	681b      	ldr	r3, [r3, #0]
 8001438:	1c5a      	adds	r2, r3, #1
 800143a:	68fb      	ldr	r3, [r7, #12]
 800143c:	601a      	str	r2, [r3, #0]
            if (bt->time >= TIMECNT_BW2PRESS) {
 800143e:	68fb      	ldr	r3, [r7, #12]
 8001440:	681b      	ldr	r3, [r3, #0]
 8001442:	2b4f      	cmp	r3, #79	; 0x4f
 8001444:	d932      	bls.n	80014ac <ButtonScanTypeEdge+0x128>
                if (bt->holdCnt != 0) {
 8001446:	68fb      	ldr	r3, [r7, #12]
 8001448:	685b      	ldr	r3, [r3, #4]
 800144a:	2b00      	cmp	r3, #0
 800144c:	d012      	beq.n	8001474 <ButtonScanTypeEdge+0xf0>
                    if ((pEventCallbacks[BUTTON_EVENT_RELEASE] != NULL) && (bt->mode & BUTTON_TYPE_LOGIC)) {
 800144e:	4b4c      	ldr	r3, [pc, #304]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 8001450:	68db      	ldr	r3, [r3, #12]
 8001452:	2b00      	cmp	r3, #0
 8001454:	d024      	beq.n	80014a0 <ButtonScanTypeEdge+0x11c>
 8001456:	68fb      	ldr	r3, [r7, #12]
 8001458:	7adb      	ldrb	r3, [r3, #11]
 800145a:	f003 0301 	and.w	r3, r3, #1
 800145e:	2b00      	cmp	r3, #0
 8001460:	d01e      	beq.n	80014a0 <ButtonScanTypeEdge+0x11c>
                        pEventCallbacks[BUTTON_EVENT_RELEASE](i, bt->holdCnt);
 8001462:	4b47      	ldr	r3, [pc, #284]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 8001464:	68db      	ldr	r3, [r3, #12]
 8001466:	68fa      	ldr	r2, [r7, #12]
 8001468:	6852      	ldr	r2, [r2, #4]
 800146a:	b291      	uxth	r1, r2
 800146c:	7afa      	ldrb	r2, [r7, #11]
 800146e:	4610      	mov	r0, r2
 8001470:	4798      	blx	r3
 8001472:	e015      	b.n	80014a0 <ButtonScanTypeEdge+0x11c>
                    }
                }
                else if ((pEventCallbacks[BUTTON_EVENT_PRESS] != NULL) && (bt->mode & BUTTON_TYPE_LOGIC) \
 8001474:	4b42      	ldr	r3, [pc, #264]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 8001476:	685b      	ldr	r3, [r3, #4]
 8001478:	2b00      	cmp	r3, #0
 800147a:	d011      	beq.n	80014a0 <ButtonScanTypeEdge+0x11c>
 800147c:	68fb      	ldr	r3, [r7, #12]
 800147e:	7adb      	ldrb	r3, [r3, #11]
 8001480:	f003 0301 	and.w	r3, r3, #1
 8001484:	2b00      	cmp	r3, #0
 8001486:	d00b      	beq.n	80014a0 <ButtonScanTypeEdge+0x11c>
                         && bt->pressCnt != 0) 
 8001488:	68fb      	ldr	r3, [r7, #12]
 800148a:	7a1b      	ldrb	r3, [r3, #8]
 800148c:	2b00      	cmp	r3, #0
 800148e:	d007      	beq.n	80014a0 <ButtonScanTypeEdge+0x11c>
                {
                    pEventCallbacks[BUTTON_EVENT_PRESS](i, bt->pressCnt);
 8001490:	4b3b      	ldr	r3, [pc, #236]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 8001492:	685b      	ldr	r3, [r3, #4]
 8001494:	68fa      	ldr	r2, [r7, #12]
 8001496:	7a12      	ldrb	r2, [r2, #8]
 8001498:	b291      	uxth	r1, r2
 800149a:	7afa      	ldrb	r2, [r7, #11]
 800149c:	4610      	mov	r0, r2
 800149e:	4798      	blx	r3
                }
                
                bt->holdCnt = 0;
 80014a0:	68fb      	ldr	r3, [r7, #12]
 80014a2:	2200      	movs	r2, #0
 80014a4:	605a      	str	r2, [r3, #4]
                bt->pressCnt = 0;
 80014a6:	68fb      	ldr	r3, [r7, #12]
 80014a8:	2200      	movs	r2, #0
 80014aa:	721a      	strb	r2, [r3, #8]
            }
        }
    }
    
    if (bt->countActive >= KEY_COUNT_IS_PRESS) {
 80014ac:	68fb      	ldr	r3, [r7, #12]
 80014ae:	7b5b      	ldrb	r3, [r3, #13]
 80014b0:	2b09      	cmp	r3, #9
 80014b2:	d95e      	bls.n	8001572 <ButtonScanTypeEdge+0x1ee>
        /* reset count inactive */
        bt->countInactive = 0; 
 80014b4:	68fb      	ldr	r3, [r7, #12]
 80014b6:	2200      	movs	r2, #0
 80014b8:	731a      	strb	r2, [r3, #12]
        
        if (bt->sold == PIN_UNACTIVE) {
 80014ba:	68fb      	ldr	r3, [r7, #12]
 80014bc:	7a5b      	ldrb	r3, [r3, #9]
 80014be:	2b00      	cmp	r3, #0
 80014c0:	d11e      	bne.n	8001500 <ButtonScanTypeEdge+0x17c>
            bt->sold = PIN_ACTIVE;
 80014c2:	68fb      	ldr	r3, [r7, #12]
 80014c4:	2201      	movs	r2, #1
 80014c6:	725a      	strb	r2, [r3, #9]
            
            if ((pEventCallbacks[BUTTON_EVENT_EDGE] != NULL) && (bt->mode & BUTTON_TYPE_EDGE)) {
 80014c8:	4b2d      	ldr	r3, [pc, #180]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 80014ca:	681b      	ldr	r3, [r3, #0]
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d00b      	beq.n	80014e8 <ButtonScanTypeEdge+0x164>
 80014d0:	68fb      	ldr	r3, [r7, #12]
 80014d2:	7adb      	ldrb	r3, [r3, #11]
 80014d4:	f003 0302 	and.w	r3, r3, #2
 80014d8:	2b00      	cmp	r3, #0
 80014da:	d005      	beq.n	80014e8 <ButtonScanTypeEdge+0x164>
                pEventCallbacks[BUTTON_EVENT_EDGE](i, BUTTON_EDGE_RISING);
 80014dc:	4b28      	ldr	r3, [pc, #160]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 80014de:	681b      	ldr	r3, [r3, #0]
 80014e0:	7afa      	ldrb	r2, [r7, #11]
 80014e2:	2100      	movs	r1, #0
 80014e4:	4610      	mov	r0, r2
 80014e6:	4798      	blx	r3
            }
            
            bt->time = bt->countActive;
 80014e8:	68fb      	ldr	r3, [r7, #12]
 80014ea:	7b5b      	ldrb	r3, [r3, #13]
 80014ec:	461a      	mov	r2, r3
 80014ee:	68fb      	ldr	r3, [r7, #12]
 80014f0:	601a      	str	r2, [r3, #0]
            bt->pressCnt++;
 80014f2:	68fb      	ldr	r3, [r7, #12]
 80014f4:	7a1b      	ldrb	r3, [r3, #8]
 80014f6:	3301      	adds	r3, #1
 80014f8:	b2da      	uxtb	r2, r3
 80014fa:	68fb      	ldr	r3, [r7, #12]
 80014fc:	721a      	strb	r2, [r3, #8]
                    }
                }
            }
        }
    }
}
 80014fe:	e038      	b.n	8001572 <ButtonScanTypeEdge+0x1ee>
            bt->time++;
 8001500:	68fb      	ldr	r3, [r7, #12]
 8001502:	681b      	ldr	r3, [r3, #0]
 8001504:	1c5a      	adds	r2, r3, #1
 8001506:	68fb      	ldr	r3, [r7, #12]
 8001508:	601a      	str	r2, [r3, #0]
            if (bt->time >= TIMECNT_IS_HOLD) {
 800150a:	68fb      	ldr	r3, [r7, #12]
 800150c:	681b      	ldr	r3, [r3, #0]
 800150e:	2b77      	cmp	r3, #119	; 0x77
 8001510:	d92f      	bls.n	8001572 <ButtonScanTypeEdge+0x1ee>
                bt->pressCnt = 0;
 8001512:	68fb      	ldr	r3, [r7, #12]
 8001514:	2200      	movs	r2, #0
 8001516:	721a      	strb	r2, [r3, #8]
                bt->holdCnt = bt->time;
 8001518:	68fb      	ldr	r3, [r7, #12]
 800151a:	681a      	ldr	r2, [r3, #0]
 800151c:	68fb      	ldr	r3, [r7, #12]
 800151e:	605a      	str	r2, [r3, #4]
                if ((bt->holdCnt == TIMECNT_IS_HOLD) || (bt->holdCnt == TIMECNT_HOLD1S) || (bt->holdCnt == TIMECNT_HOLD3S) ||
 8001520:	68fb      	ldr	r3, [r7, #12]
 8001522:	685b      	ldr	r3, [r3, #4]
 8001524:	2b78      	cmp	r3, #120	; 0x78
 8001526:	d012      	beq.n	800154e <ButtonScanTypeEdge+0x1ca>
 8001528:	68fb      	ldr	r3, [r7, #12]
 800152a:	685b      	ldr	r3, [r3, #4]
 800152c:	2bc8      	cmp	r3, #200	; 0xc8
 800152e:	d00e      	beq.n	800154e <ButtonScanTypeEdge+0x1ca>
 8001530:	68fb      	ldr	r3, [r7, #12]
 8001532:	685b      	ldr	r3, [r3, #4]
 8001534:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 8001538:	d009      	beq.n	800154e <ButtonScanTypeEdge+0x1ca>
                    (bt->holdCnt == TIMECNT_HOLD5S) || (bt->holdCnt == TIMECNT_HOLD10S)) 
 800153a:	68fb      	ldr	r3, [r7, #12]
 800153c:	685b      	ldr	r3, [r3, #4]
                if ((bt->holdCnt == TIMECNT_IS_HOLD) || (bt->holdCnt == TIMECNT_HOLD1S) || (bt->holdCnt == TIMECNT_HOLD3S) ||
 800153e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8001542:	d004      	beq.n	800154e <ButtonScanTypeEdge+0x1ca>
                    (bt->holdCnt == TIMECNT_HOLD5S) || (bt->holdCnt == TIMECNT_HOLD10S)) 
 8001544:	68fb      	ldr	r3, [r7, #12]
 8001546:	685b      	ldr	r3, [r3, #4]
 8001548:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 800154c:	d111      	bne.n	8001572 <ButtonScanTypeEdge+0x1ee>
                    if (pEventCallbacks[BUTTON_EVENT_HOLD] != NULL && (bt->mode & BUTTON_TYPE_LOGIC)) {
 800154e:	4b0c      	ldr	r3, [pc, #48]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 8001550:	689b      	ldr	r3, [r3, #8]
 8001552:	2b00      	cmp	r3, #0
 8001554:	d00d      	beq.n	8001572 <ButtonScanTypeEdge+0x1ee>
 8001556:	68fb      	ldr	r3, [r7, #12]
 8001558:	7adb      	ldrb	r3, [r3, #11]
 800155a:	f003 0301 	and.w	r3, r3, #1
 800155e:	2b00      	cmp	r3, #0
 8001560:	d007      	beq.n	8001572 <ButtonScanTypeEdge+0x1ee>
                        pEventCallbacks[BUTTON_EVENT_HOLD](i, bt->holdCnt);
 8001562:	4b07      	ldr	r3, [pc, #28]	; (8001580 <ButtonScanTypeEdge+0x1fc>)
 8001564:	689b      	ldr	r3, [r3, #8]
 8001566:	68fa      	ldr	r2, [r7, #12]
 8001568:	6852      	ldr	r2, [r2, #4]
 800156a:	b291      	uxth	r1, r2
 800156c:	7afa      	ldrb	r2, [r7, #11]
 800156e:	4610      	mov	r0, r2
 8001570:	4798      	blx	r3
}
 8001572:	bf00      	nop
 8001574:	3710      	adds	r7, #16
 8001576:	46bd      	mov	sp, r7
 8001578:	bd80      	pop	{r7, pc}
 800157a:	bf00      	nop
 800157c:	20000024 	.word	0x20000024
 8001580:	200001b0 	.word	0x200001b0

08001584 <ButtonScan>:
 * @retval None
 */
void
ButtonScan(
    void *arg
) {
 8001584:	b580      	push	{r7, lr}
 8001586:	b084      	sub	sp, #16
 8001588:	af00      	add	r7, sp, #0
 800158a:	6078      	str	r0, [r7, #4]
    for (uint8_t i = 0; i < MAX_ELEMENT; i++) {
 800158c:	2300      	movs	r3, #0
 800158e:	73fb      	strb	r3, [r7, #15]
 8001590:	e014      	b.n	80015bc <ButtonScan+0x38>
        kpad[i].scanBtnFunc(&kpad[i]);
 8001592:	7bfa      	ldrb	r2, [r7, #15]
 8001594:	490d      	ldr	r1, [pc, #52]	; (80015cc <ButtonScan+0x48>)
 8001596:	4613      	mov	r3, r2
 8001598:	009b      	lsls	r3, r3, #2
 800159a:	4413      	add	r3, r2
 800159c:	009b      	lsls	r3, r3, #2
 800159e:	440b      	add	r3, r1
 80015a0:	3310      	adds	r3, #16
 80015a2:	6819      	ldr	r1, [r3, #0]
 80015a4:	7bfa      	ldrb	r2, [r7, #15]
 80015a6:	4613      	mov	r3, r2
 80015a8:	009b      	lsls	r3, r3, #2
 80015aa:	4413      	add	r3, r2
 80015ac:	009b      	lsls	r3, r3, #2
 80015ae:	4a07      	ldr	r2, [pc, #28]	; (80015cc <ButtonScan+0x48>)
 80015b0:	4413      	add	r3, r2
 80015b2:	4618      	mov	r0, r3
 80015b4:	4788      	blx	r1
    for (uint8_t i = 0; i < MAX_ELEMENT; i++) {
 80015b6:	7bfb      	ldrb	r3, [r7, #15]
 80015b8:	3301      	adds	r3, #1
 80015ba:	73fb      	strb	r3, [r7, #15]
 80015bc:	7bfb      	ldrb	r3, [r7, #15]
 80015be:	2b05      	cmp	r3, #5
 80015c0:	d9e7      	bls.n	8001592 <ButtonScan+0xe>
    }
}
 80015c2:	bf00      	nop
 80015c4:	bf00      	nop
 80015c6:	3710      	adds	r7, #16
 80015c8:	46bd      	mov	sp, r7
 80015ca:	bd80      	pop	{r7, pc}
 80015cc:	20000138 	.word	0x20000138

080015d0 <BTNGPIO_Init>:
 * @brief  Initializes module button
 * @param  None
 * @retval None
 */
static void BTNGPIO_Init(void)
{
 80015d0:	b580      	push	{r7, lr}
 80015d2:	b082      	sub	sp, #8
 80015d4:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOA, GPIOB and GPIOC Clocks enable */
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
 80015d6:	2101      	movs	r1, #1
 80015d8:	2001      	movs	r0, #1
 80015da:	f7ff f931 	bl	8000840 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
 80015de:	2101      	movs	r1, #1
 80015e0:	2002      	movs	r0, #2
 80015e2:	f7ff f92d 	bl	8000840 <RCC_AHB1PeriphClockCmd>
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
 80015e6:	2101      	movs	r1, #1
 80015e8:	2004      	movs	r0, #4
 80015ea:	f7ff f929 	bl	8000840 <RCC_AHB1PeriphClockCmd>

	/* GPIOA Configuration: Channel 1 and 3 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
 80015ee:	2300      	movs	r3, #0
 80015f0:	713b      	strb	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 80015f2:	2303      	movs	r3, #3
 80015f4:	717b      	strb	r3, [r7, #5]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 80015f6:	2301      	movs	r3, #1
 80015f8:	71fb      	strb	r3, [r7, #7]

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
 80015fa:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80015fe:	603b      	str	r3, [r7, #0]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8001600:	463b      	mov	r3, r7
 8001602:	4619      	mov	r1, r3
 8001604:	480a      	ldr	r0, [pc, #40]	; (8001630 <BTNGPIO_Init+0x60>)
 8001606:	f7fe ff45 	bl	8000494 <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
 800160a:	2339      	movs	r3, #57	; 0x39
 800160c:	603b      	str	r3, [r7, #0]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800160e:	463b      	mov	r3, r7
 8001610:	4619      	mov	r1, r3
 8001612:	4808      	ldr	r0, [pc, #32]	; (8001634 <BTNGPIO_Init+0x64>)
 8001614:	f7fe ff3e 	bl	8000494 <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
 8001618:	2310      	movs	r3, #16
 800161a:	603b      	str	r3, [r7, #0]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800161c:	463b      	mov	r3, r7
 800161e:	4619      	mov	r1, r3
 8001620:	4805      	ldr	r0, [pc, #20]	; (8001638 <BTNGPIO_Init+0x68>)
 8001622:	f7fe ff37 	bl	8000494 <GPIO_Init>
}
 8001626:	bf00      	nop
 8001628:	3708      	adds	r7, #8
 800162a:	46bd      	mov	sp, r7
 800162c:	bd80      	pop	{r7, pc}
 800162e:	bf00      	nop
 8001630:	40020800 	.word	0x40020800
 8001634:	40020400 	.word	0x40020400
 8001638:	40020000 	.word	0x40020000

0800163c <EventButton_Init>:
 * @brief  Initialize events of button
 * @param  pFuncAppProcEvent: funtion callback
 * @retval None
 */
void
EventButton_Init(void) {
 800163c:	b580      	push	{r7, lr}
 800163e:	af00      	add	r7, sp, #0
    /* Init callback functions */
	Button_RegisterEventCallback(BUTTON_EVENT_EDGE, ButtonProcessEventEdge);
 8001640:	4915      	ldr	r1, [pc, #84]	; (8001698 <EventButton_Init+0x5c>)
 8001642:	2000      	movs	r0, #0
 8001644:	f7ff fe8a 	bl	800135c <Button_RegisterEventCallback>
	Button_RegisterEventCallback(BUTTON_EVENT_PRESS, ButtonProcessEventPress);
 8001648:	4914      	ldr	r1, [pc, #80]	; (800169c <EventButton_Init+0x60>)
 800164a:	2001      	movs	r0, #1
 800164c:	f7ff fe86 	bl	800135c <Button_RegisterEventCallback>
	Button_RegisterEventCallback(BUTTON_EVENT_HOLD, ButtonProcessEventHold);
 8001650:	4913      	ldr	r1, [pc, #76]	; (80016a0 <EventButton_Init+0x64>)
 8001652:	2002      	movs	r0, #2
 8001654:	f7ff fe82 	bl	800135c <Button_RegisterEventCallback>
	Button_RegisterEventCallback(BUTTON_EVENT_RELEASE, ButtonProcessEventRelease);
 8001658:	4912      	ldr	r1, [pc, #72]	; (80016a4 <EventButton_Init+0x68>)
 800165a:	2003      	movs	r0, #3
 800165c:	f7ff fe7e 	bl	800135c <Button_RegisterEventCallback>
    
    /* Init mode of buttons */
    Button_SetMode(BUTTON_BOARD_ID, BUTTON_TYPE_LOGIC);
 8001660:	2101      	movs	r1, #1
 8001662:	2000      	movs	r0, #0
 8001664:	f7ff fe5c 	bl	8001320 <Button_SetMode>
    Button_SetMode(BUTTON_KIT_ID1, BUTTON_TYPE_LOGIC);
 8001668:	2101      	movs	r1, #1
 800166a:	2001      	movs	r0, #1
 800166c:	f7ff fe58 	bl	8001320 <Button_SetMode>
    Button_SetMode(BUTTON_KIT_ID2, BUTTON_TYPE_LOGIC);
 8001670:	2101      	movs	r1, #1
 8001672:	2002      	movs	r0, #2
 8001674:	f7ff fe54 	bl	8001320 <Button_SetMode>
    Button_SetMode(BUTTON_KIT_ID3, BUTTON_TYPE_LOGIC);
 8001678:	2101      	movs	r1, #1
 800167a:	2003      	movs	r0, #3
 800167c:	f7ff fe50 	bl	8001320 <Button_SetMode>
	Button_SetMode(BUTTON_KIT_ID4, BUTTON_TYPE_LOGIC);
 8001680:	2101      	movs	r1, #1
 8001682:	2004      	movs	r0, #4
 8001684:	f7ff fe4c 	bl	8001320 <Button_SetMode>
    Button_SetMode(BUTTON_KIT_ID5, BUTTON_TYPE_LOGIC);
 8001688:	2101      	movs	r1, #1
 800168a:	2005      	movs	r0, #5
 800168c:	f7ff fe48 	bl	8001320 <Button_SetMode>

    Button_Init();
 8001690:	f7ff fde8 	bl	8001264 <Button_Init>
}
 8001694:	bf00      	nop
 8001696:	bd80      	pop	{r7, pc}
 8001698:	080016a9 	.word	0x080016a9
 800169c:	080016dd 	.word	0x080016dd
 80016a0:	08001725 	.word	0x08001725
 80016a4:	08001783 	.word	0x08001783

080016a8 <ButtonProcessEventEdge>:
 */
static void 
ButtonProcessEventEdge(
    uint8_t btnID,
    uint16_t edge
) {
 80016a8:	b580      	push	{r7, lr}
 80016aa:	b084      	sub	sp, #16
 80016ac:	af00      	add	r7, sp, #0
 80016ae:	4603      	mov	r3, r0
 80016b0:	460a      	mov	r2, r1
 80016b2:	71fb      	strb	r3, [r7, #7]
 80016b4:	4613      	mov	r3, r2
 80016b6:	80bb      	strh	r3, [r7, #4]
	uint8_t event;

    if (edge == BUTTON_EDGE_RISING)
 80016b8:	88bb      	ldrh	r3, [r7, #4]
 80016ba:	2b00      	cmp	r3, #0
 80016bc:	d103      	bne.n	80016c6 <ButtonProcessEventEdge+0x1e>
    {
    	event = EVENT_OF_BUTTON_0_PRESS_EDGE_RISING + btnID;
 80016be:	79fb      	ldrb	r3, [r7, #7]
 80016c0:	3306      	adds	r3, #6
 80016c2:	73fb      	strb	r3, [r7, #15]
 80016c4:	e002      	b.n	80016cc <ButtonProcessEventEdge+0x24>
    }
    else /* (edge == BUTTON_EDGE_FAILING) */
    {
    	event = EVENT_OF_BUTTON_0_PRESS_EDGE_FALLING + btnID;
 80016c6:	79fb      	ldrb	r3, [r7, #7]
 80016c8:	330c      	adds	r3, #12
 80016ca:	73fb      	strb	r3, [r7, #15]
    }

    EventSchedulerAdd(event);
 80016cc:	7bfb      	ldrb	r3, [r7, #15]
 80016ce:	4618      	mov	r0, r3
 80016d0:	f000 fd82 	bl	80021d8 <EventSchedulerAdd>
}
 80016d4:	bf00      	nop
 80016d6:	3710      	adds	r7, #16
 80016d8:	46bd      	mov	sp, r7
 80016da:	bd80      	pop	{r7, pc}

080016dc <ButtonProcessEventPress>:
 */
static void 
ButtonProcessEventPress(
    uint8_t btnID,
    uint16_t time
) {
 80016dc:	b580      	push	{r7, lr}
 80016de:	b084      	sub	sp, #16
 80016e0:	af00      	add	r7, sp, #0
 80016e2:	4603      	mov	r3, r0
 80016e4:	460a      	mov	r2, r1
 80016e6:	71fb      	strb	r3, [r7, #7]
 80016e8:	4613      	mov	r3, r2
 80016ea:	80bb      	strh	r3, [r7, #4]
	uint8_t event;

	if (time == 1)
 80016ec:	88bb      	ldrh	r3, [r7, #4]
 80016ee:	2b01      	cmp	r3, #1
 80016f0:	d102      	bne.n	80016f8 <ButtonProcessEventPress+0x1c>
	{
		event = EVENT_OF_BUTTON_0_PRESS_LOGIC + btnID;
 80016f2:	79fb      	ldrb	r3, [r7, #7]
 80016f4:	73fb      	strb	r3, [r7, #15]
 80016f6:	e00c      	b.n	8001712 <ButtonProcessEventPress+0x36>
	}
	else if (time == 2)
 80016f8:	88bb      	ldrh	r3, [r7, #4]
 80016fa:	2b02      	cmp	r3, #2
 80016fc:	d103      	bne.n	8001706 <ButtonProcessEventPress+0x2a>
	{
		event = EVENT_OF_BUTTON_0_PRESS_2_TIMES + btnID;
 80016fe:	79fb      	ldrb	r3, [r7, #7]
 8001700:	3312      	adds	r3, #18
 8001702:	73fb      	strb	r3, [r7, #15]
 8001704:	e005      	b.n	8001712 <ButtonProcessEventPress+0x36>
	}
	else if (time == 5)
 8001706:	88bb      	ldrh	r3, [r7, #4]
 8001708:	2b05      	cmp	r3, #5
 800170a:	d107      	bne.n	800171c <ButtonProcessEventPress+0x40>
	{
		event = EVENT_OF_BUTTON_0_PRESS_5_TIMES + btnID;
 800170c:	79fb      	ldrb	r3, [r7, #7]
 800170e:	3318      	adds	r3, #24
 8001710:	73fb      	strb	r3, [r7, #15]
	}
	else return;

    EventSchedulerAdd(event);
 8001712:	7bfb      	ldrb	r3, [r7, #15]
 8001714:	4618      	mov	r0, r3
 8001716:	f000 fd5f 	bl	80021d8 <EventSchedulerAdd>
 800171a:	e000      	b.n	800171e <ButtonProcessEventPress+0x42>
	else return;
 800171c:	bf00      	nop
}
 800171e:	3710      	adds	r7, #16
 8001720:	46bd      	mov	sp, r7
 8001722:	bd80      	pop	{r7, pc}

08001724 <ButtonProcessEventHold>:
 */
static void 
ButtonProcessEventHold(
    uint8_t btnID,
    uint16_t time
) {
 8001724:	b580      	push	{r7, lr}
 8001726:	b084      	sub	sp, #16
 8001728:	af00      	add	r7, sp, #0
 800172a:	4603      	mov	r3, r0
 800172c:	460a      	mov	r2, r1
 800172e:	71fb      	strb	r3, [r7, #7]
 8001730:	4613      	mov	r3, r2
 8001732:	80bb      	strh	r3, [r7, #4]
	uint8_t event;

	if (time == TIMECNT_HOLD10S)
 8001734:	88bb      	ldrh	r3, [r7, #4]
 8001736:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 800173a:	d103      	bne.n	8001744 <ButtonProcessEventHold+0x20>
	{
		event = EVENT_OF_BUTTON_0_HOLD_10S + btnID;
 800173c:	79fb      	ldrb	r3, [r7, #7]
 800173e:	3330      	adds	r3, #48	; 0x30
 8001740:	73fb      	strb	r3, [r7, #15]
 8001742:	e015      	b.n	8001770 <ButtonProcessEventHold+0x4c>
	}
	else if (time == TIMECNT_HOLD5S)
 8001744:	88bb      	ldrh	r3, [r7, #4]
 8001746:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800174a:	d103      	bne.n	8001754 <ButtonProcessEventHold+0x30>
	{
		event = EVENT_OF_BUTTON_0_HOLD_5S + btnID;
 800174c:	79fb      	ldrb	r3, [r7, #7]
 800174e:	332a      	adds	r3, #42	; 0x2a
 8001750:	73fb      	strb	r3, [r7, #15]
 8001752:	e00d      	b.n	8001770 <ButtonProcessEventHold+0x4c>
	}
	else if (time == TIMECNT_HOLD3S)
 8001754:	88bb      	ldrh	r3, [r7, #4]
 8001756:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 800175a:	d103      	bne.n	8001764 <ButtonProcessEventHold+0x40>
	{
		event = EVENT_OF_BUTTON_0_HOLD_3S + btnID;
 800175c:	79fb      	ldrb	r3, [r7, #7]
 800175e:	3324      	adds	r3, #36	; 0x24
 8001760:	73fb      	strb	r3, [r7, #15]
 8001762:	e005      	b.n	8001770 <ButtonProcessEventHold+0x4c>
	}
	else if (time == TIMECNT_HOLD1S)
 8001764:	88bb      	ldrh	r3, [r7, #4]
 8001766:	2bc8      	cmp	r3, #200	; 0xc8
 8001768:	d107      	bne.n	800177a <ButtonProcessEventHold+0x56>
	{
		event = EVENT_OF_BUTTON_0_HOLD_1S + btnID;
 800176a:	79fb      	ldrb	r3, [r7, #7]
 800176c:	331e      	adds	r3, #30
 800176e:	73fb      	strb	r3, [r7, #15]
	}
	else return;

	EventSchedulerAdd(event);
 8001770:	7bfb      	ldrb	r3, [r7, #15]
 8001772:	4618      	mov	r0, r3
 8001774:	f000 fd30 	bl	80021d8 <EventSchedulerAdd>
 8001778:	e000      	b.n	800177c <ButtonProcessEventHold+0x58>
	else return;
 800177a:	bf00      	nop
}
 800177c:	3710      	adds	r7, #16
 800177e:	46bd      	mov	sp, r7
 8001780:	bd80      	pop	{r7, pc}

08001782 <ButtonProcessEventRelease>:
 */
static void 
ButtonProcessEventRelease(
    uint8_t btnID,
    uint16_t time
) {
 8001782:	b580      	push	{r7, lr}
 8001784:	b084      	sub	sp, #16
 8001786:	af00      	add	r7, sp, #0
 8001788:	4603      	mov	r3, r0
 800178a:	460a      	mov	r2, r1
 800178c:	71fb      	strb	r3, [r7, #7]
 800178e:	4613      	mov	r3, r2
 8001790:	80bb      	strh	r3, [r7, #4]
	uint8_t event;

	if (time >= TIMECNT_HOLD10S)
 8001792:	88bb      	ldrh	r3, [r7, #4]
 8001794:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 8001798:	d303      	bcc.n	80017a2 <ButtonProcessEventRelease+0x20>
	{
		event = EVENT_OF_BUTTON_0_RELEASED_10S + btnID;
 800179a:	79fb      	ldrb	r3, [r7, #7]
 800179c:	3348      	adds	r3, #72	; 0x48
 800179e:	73fb      	strb	r3, [r7, #15]
 80017a0:	e015      	b.n	80017ce <ButtonProcessEventRelease+0x4c>
	}
	else if (time >= TIMECNT_HOLD5S)
 80017a2:	88bb      	ldrh	r3, [r7, #4]
 80017a4:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80017a8:	d303      	bcc.n	80017b2 <ButtonProcessEventRelease+0x30>
	{
		event = EVENT_OF_BUTTON_0_RELEASED_5S + btnID;
 80017aa:	79fb      	ldrb	r3, [r7, #7]
 80017ac:	3342      	adds	r3, #66	; 0x42
 80017ae:	73fb      	strb	r3, [r7, #15]
 80017b0:	e00d      	b.n	80017ce <ButtonProcessEventRelease+0x4c>
	}
	else if (time >= TIMECNT_HOLD3S)
 80017b2:	88bb      	ldrh	r3, [r7, #4]
 80017b4:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 80017b8:	d303      	bcc.n	80017c2 <ButtonProcessEventRelease+0x40>
	{
		event = EVENT_OF_BUTTON_0_RELEASED_3S + btnID;
 80017ba:	79fb      	ldrb	r3, [r7, #7]
 80017bc:	333c      	adds	r3, #60	; 0x3c
 80017be:	73fb      	strb	r3, [r7, #15]
 80017c0:	e005      	b.n	80017ce <ButtonProcessEventRelease+0x4c>
	}
	else if (time >= TIMECNT_HOLD1S)
 80017c2:	88bb      	ldrh	r3, [r7, #4]
 80017c4:	2bc7      	cmp	r3, #199	; 0xc7
 80017c6:	d907      	bls.n	80017d8 <ButtonProcessEventRelease+0x56>
	{
		event = EVENT_OF_BUTTON_0_RELEASED_1S + btnID;
 80017c8:	79fb      	ldrb	r3, [r7, #7]
 80017ca:	3336      	adds	r3, #54	; 0x36
 80017cc:	73fb      	strb	r3, [r7, #15]
	}
	else return;

	EventSchedulerAdd(event);
 80017ce:	7bfb      	ldrb	r3, [r7, #15]
 80017d0:	4618      	mov	r0, r3
 80017d2:	f000 fd01 	bl	80021d8 <EventSchedulerAdd>
 80017d6:	e000      	b.n	80017da <ButtonProcessEventRelease+0x58>
	else return;
 80017d8:	bf00      	nop
}
 80017da:	3710      	adds	r7, #16
 80017dc:	46bd      	mov	sp, r7
 80017de:	bd80      	pop	{r7, pc}

080017e0 <BuzzOff>:
 * @retval None
 */
static void
BuzzOff(
    void *arg
) {
 80017e0:	b580      	push	{r7, lr}
 80017e2:	b082      	sub	sp, #8
 80017e4:	af00      	add	r7, sp, #0
 80017e6:	6078      	str	r0, [r7, #4]
    idBuzz = NO_TIMER;
 80017e8:	4b12      	ldr	r3, [pc, #72]	; (8001834 <BuzzOff+0x54>)
 80017ea:	22ff      	movs	r2, #255	; 0xff
 80017ec:	701a      	strb	r2, [r3, #0]
    gpToneList++;  /* Next Element */
 80017ee:	4b12      	ldr	r3, [pc, #72]	; (8001838 <BuzzOff+0x58>)
 80017f0:	681b      	ldr	r3, [r3, #0]
 80017f2:	3304      	adds	r3, #4
 80017f4:	4a10      	ldr	r2, [pc, #64]	; (8001838 <BuzzOff+0x58>)
 80017f6:	6013      	str	r3, [r2, #0]
    if ((gpToneList->freq == 0) && (gpToneList->duration == 0)) {
 80017f8:	4b0f      	ldr	r3, [pc, #60]	; (8001838 <BuzzOff+0x58>)
 80017fa:	681b      	ldr	r3, [r3, #0]
 80017fc:	881b      	ldrh	r3, [r3, #0]
 80017fe:	2b00      	cmp	r3, #0
 8001800:	d108      	bne.n	8001814 <BuzzOff+0x34>
 8001802:	4b0d      	ldr	r3, [pc, #52]	; (8001838 <BuzzOff+0x58>)
 8001804:	681b      	ldr	r3, [r3, #0]
 8001806:	885b      	ldrh	r3, [r3, #2]
 8001808:	2b00      	cmp	r3, #0
 800180a:	d103      	bne.n	8001814 <BuzzOff+0x34>
    	BuzzerControl_SetDutyCycle(0);
 800180c:	2000      	movs	r0, #0
 800180e:	f000 f87f 	bl	8001910 <BuzzerControl_SetDutyCycle>
 8001812:	e00a      	b.n	800182a <BuzzOff+0x4a>
    }
    else {
        BuzzPlay(gpToneList->freq, gpToneList->duration);
 8001814:	4b08      	ldr	r3, [pc, #32]	; (8001838 <BuzzOff+0x58>)
 8001816:	681b      	ldr	r3, [r3, #0]
 8001818:	881a      	ldrh	r2, [r3, #0]
 800181a:	4b07      	ldr	r3, [pc, #28]	; (8001838 <BuzzOff+0x58>)
 800181c:	681b      	ldr	r3, [r3, #0]
 800181e:	885b      	ldrh	r3, [r3, #2]
 8001820:	4619      	mov	r1, r3
 8001822:	4610      	mov	r0, r2
 8001824:	f000 f80a 	bl	800183c <BuzzPlay>
    }
}
 8001828:	bf00      	nop
 800182a:	bf00      	nop
 800182c:	3708      	adds	r7, #8
 800182e:	46bd      	mov	sp, r7
 8001830:	bd80      	pop	{r7, pc}
 8001832:	bf00      	nop
 8001834:	20000055 	.word	0x20000055
 8001838:	200001c4 	.word	0x200001c4

0800183c <BuzzPlay>:
 */
static void
BuzzPlay(
    uint16_t freq,
	uint16_t duration
) {
 800183c:	b580      	push	{r7, lr}
 800183e:	b086      	sub	sp, #24
 8001840:	af02      	add	r7, sp, #8
 8001842:	4603      	mov	r3, r0
 8001844:	460a      	mov	r2, r1
 8001846:	80fb      	strh	r3, [r7, #6]
 8001848:	4613      	mov	r3, r2
 800184a:	80bb      	strh	r3, [r7, #4]
    if (freq == 0) {
 800184c:	88fb      	ldrh	r3, [r7, #6]
 800184e:	2b00      	cmp	r3, #0
 8001850:	d103      	bne.n	800185a <BuzzPlay+0x1e>
    	BuzzerControl_SetDutyCycle(0);
 8001852:	2000      	movs	r0, #0
 8001854:	f000 f85c 	bl	8001910 <BuzzerControl_SetDutyCycle>
 8001858:	e017      	b.n	800188a <BuzzPlay+0x4e>
    }
    else if (freq == 0xFFFFU) {
 800185a:	88fb      	ldrh	r3, [r7, #6]
 800185c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001860:	4293      	cmp	r3, r2
 8001862:	d107      	bne.n	8001874 <BuzzPlay+0x38>
    	BuzzerControl_SetPreriod(5000);
 8001864:	f241 3088 	movw	r0, #5000	; 0x1388
 8001868:	f000 f870 	bl	800194c <BuzzerControl_SetPreriod>
    	BuzzerControl_SetDutyCycle(101);
 800186c:	2065      	movs	r0, #101	; 0x65
 800186e:	f000 f84f 	bl	8001910 <BuzzerControl_SetDutyCycle>
 8001872:	e00a      	b.n	800188a <BuzzPlay+0x4e>
    }
    else {
        uint32_t period = 750000 / freq;
 8001874:	88fb      	ldrh	r3, [r7, #6]
 8001876:	4a13      	ldr	r2, [pc, #76]	; (80018c4 <BuzzPlay+0x88>)
 8001878:	fb92 f3f3 	sdiv	r3, r2, r3
 800187c:	60fb      	str	r3, [r7, #12]
        BuzzerControl_SetPreriod(period);
 800187e:	68f8      	ldr	r0, [r7, #12]
 8001880:	f000 f864 	bl	800194c <BuzzerControl_SetPreriod>
        BuzzerControl_SetDutyCycle(5);
 8001884:	2005      	movs	r0, #5
 8001886:	f000 f843 	bl	8001910 <BuzzerControl_SetDutyCycle>
    }

    if (idBuzz != NO_TIMER) {
 800188a:	4b0f      	ldr	r3, [pc, #60]	; (80018c8 <BuzzPlay+0x8c>)
 800188c:	781b      	ldrb	r3, [r3, #0]
 800188e:	2bff      	cmp	r3, #255	; 0xff
 8001890:	d007      	beq.n	80018a2 <BuzzPlay+0x66>
        TimerStop(idBuzz);
 8001892:	4b0d      	ldr	r3, [pc, #52]	; (80018c8 <BuzzPlay+0x8c>)
 8001894:	781b      	ldrb	r3, [r3, #0]
 8001896:	4618      	mov	r0, r3
 8001898:	f000 fdbc 	bl	8002414 <TimerStop>
        idBuzz = NO_TIMER;
 800189c:	4b0a      	ldr	r3, [pc, #40]	; (80018c8 <BuzzPlay+0x8c>)
 800189e:	22ff      	movs	r2, #255	; 0xff
 80018a0:	701a      	strb	r2, [r3, #0]
    }

    idBuzz = TimerStart("buzz", duration, TIMER_REPEAT_ONE_TIME, BuzzOff, NULL);
 80018a2:	88b9      	ldrh	r1, [r7, #4]
 80018a4:	2300      	movs	r3, #0
 80018a6:	9300      	str	r3, [sp, #0]
 80018a8:	4b08      	ldr	r3, [pc, #32]	; (80018cc <BuzzPlay+0x90>)
 80018aa:	2200      	movs	r2, #0
 80018ac:	4808      	ldr	r0, [pc, #32]	; (80018d0 <BuzzPlay+0x94>)
 80018ae:	f000 fd33 	bl	8002318 <TimerStart>
 80018b2:	4603      	mov	r3, r0
 80018b4:	461a      	mov	r2, r3
 80018b6:	4b04      	ldr	r3, [pc, #16]	; (80018c8 <BuzzPlay+0x8c>)
 80018b8:	701a      	strb	r2, [r3, #0]
}
 80018ba:	bf00      	nop
 80018bc:	3710      	adds	r7, #16
 80018be:	46bd      	mov	sp, r7
 80018c0:	bd80      	pop	{r7, pc}
 80018c2:	bf00      	nop
 80018c4:	000b71b0 	.word	0x000b71b0
 80018c8:	20000055 	.word	0x20000055
 80018cc:	080017e1 	.word	0x080017e1
 80018d0:	08006904 	.word	0x08006904

080018d4 <BuzzerControl_SetMelody>:
 * @retval None
 */
void 
BuzzerControl_SetMelody(
    tone_p pListTone   
) {
 80018d4:	b580      	push	{r7, lr}
 80018d6:	b082      	sub	sp, #8
 80018d8:	af00      	add	r7, sp, #0
 80018da:	6078      	str	r0, [r7, #4]
    if (!bBuzzInit) return;
 80018dc:	4b0a      	ldr	r3, [pc, #40]	; (8001908 <BuzzerControl_SetMelody+0x34>)
 80018de:	781b      	ldrb	r3, [r3, #0]
 80018e0:	2b00      	cmp	r3, #0
 80018e2:	d00d      	beq.n	8001900 <BuzzerControl_SetMelody+0x2c>
    gpToneList = pListTone;
 80018e4:	4a09      	ldr	r2, [pc, #36]	; (800190c <BuzzerControl_SetMelody+0x38>)
 80018e6:	687b      	ldr	r3, [r7, #4]
 80018e8:	6013      	str	r3, [r2, #0]
    BuzzPlay(gpToneList->freq, gpToneList->duration); 
 80018ea:	4b08      	ldr	r3, [pc, #32]	; (800190c <BuzzerControl_SetMelody+0x38>)
 80018ec:	681b      	ldr	r3, [r3, #0]
 80018ee:	881a      	ldrh	r2, [r3, #0]
 80018f0:	4b06      	ldr	r3, [pc, #24]	; (800190c <BuzzerControl_SetMelody+0x38>)
 80018f2:	681b      	ldr	r3, [r3, #0]
 80018f4:	885b      	ldrh	r3, [r3, #2]
 80018f6:	4619      	mov	r1, r3
 80018f8:	4610      	mov	r0, r2
 80018fa:	f7ff ff9f 	bl	800183c <BuzzPlay>
 80018fe:	e000      	b.n	8001902 <BuzzerControl_SetMelody+0x2e>
    if (!bBuzzInit) return;
 8001900:	bf00      	nop
}
 8001902:	3708      	adds	r7, #8
 8001904:	46bd      	mov	sp, r7
 8001906:	bd80      	pop	{r7, pc}
 8001908:	200001c0 	.word	0x200001c0
 800190c:	200001c4 	.word	0x200001c4

08001910 <BuzzerControl_SetDutyCycle>:
 * @retval None
 */
void
BuzzerControl_SetDutyCycle(
    uint8_t dutycycle
) {
 8001910:	b580      	push	{r7, lr}
 8001912:	b084      	sub	sp, #16
 8001914:	af00      	add	r7, sp, #0
 8001916:	4603      	mov	r3, r0
 8001918:	71fb      	strb	r3, [r7, #7]
	uint32_t val;
    uint32_t maxval;

    maxval = TIM3->ARR;
 800191a:	4b0a      	ldr	r3, [pc, #40]	; (8001944 <BuzzerControl_SetDutyCycle+0x34>)
 800191c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800191e:	60fb      	str	r3, [r7, #12]
    val = dutycycle * maxval / 100;
 8001920:	79fb      	ldrb	r3, [r7, #7]
 8001922:	68fa      	ldr	r2, [r7, #12]
 8001924:	fb02 f303 	mul.w	r3, r2, r3
 8001928:	4a07      	ldr	r2, [pc, #28]	; (8001948 <BuzzerControl_SetDutyCycle+0x38>)
 800192a:	fba2 2303 	umull	r2, r3, r2, r3
 800192e:	095b      	lsrs	r3, r3, #5
 8001930:	60bb      	str	r3, [r7, #8]

	TIM_SetCompare4(TIM3, val);
 8001932:	68b9      	ldr	r1, [r7, #8]
 8001934:	4803      	ldr	r0, [pc, #12]	; (8001944 <BuzzerControl_SetDutyCycle+0x34>)
 8001936:	f7ff fa89 	bl	8000e4c <TIM_SetCompare4>
}
 800193a:	bf00      	nop
 800193c:	3710      	adds	r7, #16
 800193e:	46bd      	mov	sp, r7
 8001940:	bd80      	pop	{r7, pc}
 8001942:	bf00      	nop
 8001944:	40000400 	.word	0x40000400
 8001948:	51eb851f 	.word	0x51eb851f

0800194c <BuzzerControl_SetPreriod>:
 * @retval None
 */
void
BuzzerControl_SetPreriod(
	uint32_t period
) {
 800194c:	b480      	push	{r7}
 800194e:	b083      	sub	sp, #12
 8001950:	af00      	add	r7, sp, #0
 8001952:	6078      	str	r0, [r7, #4]
    TIM3->ARR = period - 1;
 8001954:	4a04      	ldr	r2, [pc, #16]	; (8001968 <BuzzerControl_SetPreriod+0x1c>)
 8001956:	687b      	ldr	r3, [r7, #4]
 8001958:	3b01      	subs	r3, #1
 800195a:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 800195c:	bf00      	nop
 800195e:	370c      	adds	r7, #12
 8001960:	46bd      	mov	sp, r7
 8001962:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001966:	4770      	bx	lr
 8001968:	40000400 	.word	0x40000400

0800196c <FLASH_Init>:
/*                            EXPORTED FUNCTIONS                              */
/******************************************************************************/
/******************************************************************************/


void FLASH_Init(void) {
 800196c:	b580      	push	{r7, lr}
 800196e:	af00      	add	r7, sp, #0
	/* Next commands may be used in SysClock initialization function
	   In this case using of FLASH_Init is not obligatorily */
	/* Enable Prefetch Buffer */
	FLASH_PrefetchBufferCmd( ENABLE);
 8001970:	2001      	movs	r0, #1
 8001972:	f7ff fb37 	bl	8000fe4 <FLASH_PrefetchBufferCmd>
	/* Flash 2 wait state */
	FLASH_SetLatency( FLASH_Latency_2);
 8001976:	2002      	movs	r0, #2
 8001978:	f7ff fb24 	bl	8000fc4 <FLASH_SetLatency>

	if( UserData_FindAddress() == SUCCESS){
 800197c:	f000 f81e 	bl	80019bc <UserData_FindAddress>
 8001980:	4603      	mov	r3, r0
 8001982:	2b01      	cmp	r3, #1
 8001984:	d004      	beq.n	8001990 <FLASH_Init+0x24>
//		printf("Found User Data Address 0x%lu!\n", UserDataAddress);
	} else {
//		printf("Erase sector!\n");
		UserData_Erase();
 8001986:	f000 f8e3 	bl	8001b50 <UserData_Erase>
		UserDataAddress = USER_FLASH_FIRST_PAGE_ADDRESS;
 800198a:	4b02      	ldr	r3, [pc, #8]	; (8001994 <FLASH_Init+0x28>)
 800198c:	4a02      	ldr	r2, [pc, #8]	; (8001998 <FLASH_Init+0x2c>)
 800198e:	601a      	str	r2, [r3, #0]
	}
}
 8001990:	bf00      	nop
 8001992:	bd80      	pop	{r7, pc}
 8001994:	20000070 	.word	0x20000070
 8001998:	08010000 	.word	0x08010000

0800199c <FLASH_RamToFlash>:

uint8_t FLASH_IsUserDataChange(void){
	return (!(memcmp((void *)UserDataAddress, (void *)&UserData, USERDATA_BYTES_SIZE) == 0));
}

void FLASH_RamToFlash(void){
 800199c:	b580      	push	{r7, lr}
 800199e:	af00      	add	r7, sp, #0
//	if( FLASH_IsUserDataChange() ){
//		printf("Run\n");
		UserData_Write();
 80019a0:	f000 f856 	bl	8001a50 <UserData_Write>
//	}
}
 80019a4:	bf00      	nop
 80019a6:	bd80      	pop	{r7, pc}

080019a8 <FLASH_GetUserData>:

UserData_t *FLASH_GetUserData(){
 80019a8:	b480      	push	{r7}
 80019aa:	af00      	add	r7, sp, #0
	return &UserData;
 80019ac:	4b02      	ldr	r3, [pc, #8]	; (80019b8 <FLASH_GetUserData+0x10>)
}
 80019ae:	4618      	mov	r0, r3
 80019b0:	46bd      	mov	sp, r7
 80019b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80019b6:	4770      	bx	lr
 80019b8:	200001c8 	.word	0x200001c8

080019bc <UserData_FindAddress>:
/************************************/
static uint8_t UserData_FindAddress(void){
 80019bc:	b580      	push	{r7, lr}
 80019be:	b082      	sub	sp, #8
 80019c0:	af00      	add	r7, sp, #0
	for(uint32_t i = 0; i < MAX_NUMBER_OF_USERDATA_IN_SECTOR; i++){
 80019c2:	2300      	movs	r3, #0
 80019c4:	607b      	str	r3, [r7, #4]
 80019c6:	e015      	b.n	80019f4 <UserData_FindAddress+0x38>
		UserData_Read();	//Read user data to
 80019c8:	f000 f89c 	bl	8001b04 <UserData_Read>

		if( UserData.Used == FLASH_USERDATA_VALID || UserData.Used == FLASH_USERDATA_IDLE){
 80019cc:	4b0e      	ldr	r3, [pc, #56]	; (8001a08 <UserData_FindAddress+0x4c>)
 80019ce:	681b      	ldr	r3, [r3, #0]
 80019d0:	f1b3 3f5a 	cmp.w	r3, #1515870810	; 0x5a5a5a5a
 80019d4:	d004      	beq.n	80019e0 <UserData_FindAddress+0x24>
 80019d6:	4b0c      	ldr	r3, [pc, #48]	; (8001a08 <UserData_FindAddress+0x4c>)
 80019d8:	681b      	ldr	r3, [r3, #0]
 80019da:	f1b3 3fff 	cmp.w	r3, #4294967295
 80019de:	d101      	bne.n	80019e4 <UserData_FindAddress+0x28>
			return SUCCESS;
 80019e0:	2301      	movs	r3, #1
 80019e2:	e00c      	b.n	80019fe <UserData_FindAddress+0x42>
		}
		UserDataAddress += USERDATA_BYTES_SIZE;
 80019e4:	4b09      	ldr	r3, [pc, #36]	; (8001a0c <UserData_FindAddress+0x50>)
 80019e6:	681b      	ldr	r3, [r3, #0]
 80019e8:	3308      	adds	r3, #8
 80019ea:	4a08      	ldr	r2, [pc, #32]	; (8001a0c <UserData_FindAddress+0x50>)
 80019ec:	6013      	str	r3, [r2, #0]
	for(uint32_t i = 0; i < MAX_NUMBER_OF_USERDATA_IN_SECTOR; i++){
 80019ee:	687b      	ldr	r3, [r7, #4]
 80019f0:	3301      	adds	r3, #1
 80019f2:	607b      	str	r3, [r7, #4]
 80019f4:	687b      	ldr	r3, [r7, #4]
 80019f6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80019fa:	d3e5      	bcc.n	80019c8 <UserData_FindAddress+0xc>
	}
	return ERROR;
 80019fc:	2300      	movs	r3, #0
}
 80019fe:	4618      	mov	r0, r3
 8001a00:	3708      	adds	r7, #8
 8001a02:	46bd      	mov	sp, r7
 8001a04:	bd80      	pop	{r7, pc}
 8001a06:	bf00      	nop
 8001a08:	200001c8 	.word	0x200001c8
 8001a0c:	20000070 	.word	0x20000070

08001a10 <UserData_Clear>:

static uint8_t UserData_Clear(void){
 8001a10:	b580      	push	{r7, lr}
 8001a12:	af00      	add	r7, sp, #0
	if( FLASH_ProgramWord((uint32_t)UserDataAddress, FLASH_USERDATA_INVALID) == FLASH_COMPLETE){
 8001a14:	4b0d      	ldr	r3, [pc, #52]	; (8001a4c <UserData_Clear+0x3c>)
 8001a16:	681b      	ldr	r3, [r3, #0]
 8001a18:	f04f 3150 	mov.w	r1, #1347440720	; 0x50505050
 8001a1c:	4618      	mov	r0, r3
 8001a1e:	f7ff fb87 	bl	8001130 <FLASH_ProgramWord>
 8001a22:	4603      	mov	r3, r0
 8001a24:	2b09      	cmp	r3, #9
 8001a26:	d109      	bne.n	8001a3c <UserData_Clear+0x2c>
		if( *(__IO uint32_t*)UserDataAddress != FLASH_USERDATA_INVALID){
 8001a28:	4b08      	ldr	r3, [pc, #32]	; (8001a4c <UserData_Clear+0x3c>)
 8001a2a:	681b      	ldr	r3, [r3, #0]
 8001a2c:	681b      	ldr	r3, [r3, #0]
 8001a2e:	f1b3 3f50 	cmp.w	r3, #1347440720	; 0x50505050
 8001a32:	d007      	beq.n	8001a44 <UserData_Clear+0x34>
			FLASH_Lock();
 8001a34:	f7ff fb0c 	bl	8001050 <FLASH_Lock>
//			printf("UserData_Clear error\n");
			return ERROR;
 8001a38:	2300      	movs	r3, #0
 8001a3a:	e004      	b.n	8001a46 <UserData_Clear+0x36>
		}
	} else {
	  /* Error occurred while writing data in Flash memory.
		 User can add here some code to deal with this error */
		FLASH_Lock();
 8001a3c:	f7ff fb08 	bl	8001050 <FLASH_Lock>
	//	printf("UserData_Clear error 2\n");
		return ERROR;
 8001a40:	2300      	movs	r3, #0
 8001a42:	e000      	b.n	8001a46 <UserData_Clear+0x36>
	}
	return SUCCESS;
 8001a44:	2301      	movs	r3, #1
//	UserDataAddress += USERDATA_BYTES_SIZE;
}
 8001a46:	4618      	mov	r0, r3
 8001a48:	bd80      	pop	{r7, pc}
 8001a4a:	bf00      	nop
 8001a4c:	20000070 	.word	0x20000070

08001a50 <UserData_Write>:

uint8_t UserData_Write(void){
 8001a50:	b580      	push	{r7, lr}
 8001a52:	b084      	sub	sp, #16
 8001a54:	af00      	add	r7, sp, #0
	/* Enable the flash control register access */
	FLASH_Unlock();
 8001a56:	f7ff fae3 	bl	8001020 <FLASH_Unlock>
	/* Erase the user Flash area ************************************************/
	/* area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR */

	/* Clear pending flags (if any) */
	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 8001a5a:	20f3      	movs	r0, #243	; 0xf3
 8001a5c:	f7ff fb9c 	bl	8001198 <FLASH_ClearFlag>
				  FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);

	/*Clear IsUsed in userdata*/
	if( UserData_Clear() != SUCCESS ){
 8001a60:	f7ff ffd6 	bl	8001a10 <UserData_Clear>
 8001a64:	4603      	mov	r3, r0
 8001a66:	2b01      	cmp	r3, #1
 8001a68:	d001      	beq.n	8001a6e <UserData_Write+0x1e>
	//	printf("Error clear\n");
		return ERROR;
 8001a6a:	2300      	movs	r3, #0
 8001a6c:	e03e      	b.n	8001aec <UserData_Write+0x9c>
	}
	UserDataAddress += USERDATA_BYTES_SIZE;
 8001a6e:	4b21      	ldr	r3, [pc, #132]	; (8001af4 <UserData_Write+0xa4>)
 8001a70:	681b      	ldr	r3, [r3, #0]
 8001a72:	3308      	adds	r3, #8
 8001a74:	4a1f      	ldr	r2, [pc, #124]	; (8001af4 <UserData_Write+0xa4>)
 8001a76:	6013      	str	r3, [r2, #0]

	if( UserDataAddress > USER_FLASH_FIRST_PAGE_ADDRESS + USERDATA_WORDS_SIZE * MAX_NUMBER_OF_USERDATA_IN_SECTOR){
 8001a78:	4b1e      	ldr	r3, [pc, #120]	; (8001af4 <UserData_Write+0xa4>)
 8001a7a:	681b      	ldr	r3, [r3, #0]
 8001a7c:	4a1e      	ldr	r2, [pc, #120]	; (8001af8 <UserData_Write+0xa8>)
 8001a7e:	4293      	cmp	r3, r2
 8001a80:	d904      	bls.n	8001a8c <UserData_Write+0x3c>
	//	printf("Sector is full to erase sector!\n");
		UserData_Erase();
 8001a82:	f000 f865 	bl	8001b50 <UserData_Erase>
		UserDataAddress = USER_FLASH_FIRST_PAGE_ADDRESS;
 8001a86:	4b1b      	ldr	r3, [pc, #108]	; (8001af4 <UserData_Write+0xa4>)
 8001a88:	4a1c      	ldr	r2, [pc, #112]	; (8001afc <UserData_Write+0xac>)
 8001a8a:	601a      	str	r2, [r3, #0]
	}
	// Write settings
	UserData.Used = FLASH_USERDATA_VALID;	//initialize valid block
 8001a8c:	4b1c      	ldr	r3, [pc, #112]	; (8001b00 <UserData_Write+0xb0>)
 8001a8e:	f04f 325a 	mov.w	r2, #1515870810	; 0x5a5a5a5a
 8001a92:	601a      	str	r2, [r3, #0]
	uint32_t *source_addr = (void *)&UserData;
 8001a94:	4b1a      	ldr	r3, [pc, #104]	; (8001b00 <UserData_Write+0xb0>)
 8001a96:	60fb      	str	r3, [r7, #12]
	uint32_t dest_addr = UserDataAddress;
 8001a98:	4b16      	ldr	r3, [pc, #88]	; (8001af4 <UserData_Write+0xa4>)
 8001a9a:	681b      	ldr	r3, [r3, #0]
 8001a9c:	60bb      	str	r3, [r7, #8]
	for (uint16_t i = 0; i < USERDATA_WORDS_SIZE; i++) {
 8001a9e:	2300      	movs	r3, #0
 8001aa0:	80fb      	strh	r3, [r7, #6]
 8001aa2:	e01f      	b.n	8001ae4 <UserData_Write+0x94>
		if( FLASH_ProgramWord(dest_addr, *source_addr) == FLASH_COMPLETE){
 8001aa4:	68fb      	ldr	r3, [r7, #12]
 8001aa6:	681b      	ldr	r3, [r3, #0]
 8001aa8:	4619      	mov	r1, r3
 8001aaa:	68b8      	ldr	r0, [r7, #8]
 8001aac:	f7ff fb40 	bl	8001130 <FLASH_ProgramWord>
 8001ab0:	4603      	mov	r3, r0
 8001ab2:	2b09      	cmp	r3, #9
 8001ab4:	d109      	bne.n	8001aca <UserData_Write+0x7a>
		//	printf("FLASH_COMPLETE\n");
			if( *((uint32_t*)dest_addr) != *source_addr){
 8001ab6:	68bb      	ldr	r3, [r7, #8]
 8001ab8:	681a      	ldr	r2, [r3, #0]
 8001aba:	68fb      	ldr	r3, [r7, #12]
 8001abc:	681b      	ldr	r3, [r3, #0]
 8001abe:	429a      	cmp	r2, r3
 8001ac0:	d007      	beq.n	8001ad2 <UserData_Write+0x82>
		//		printf("ERROR\n");
				FLASH_Lock();
 8001ac2:	f7ff fac5 	bl	8001050 <FLASH_Lock>
				return ERROR;
 8001ac6:	2300      	movs	r3, #0
 8001ac8:	e010      	b.n	8001aec <UserData_Write+0x9c>
		}
		else {
		  /* Error occurred while writing data in Flash memory.
			 User can add here some code to deal with this error */
	//		printf("ERROR2\n");
			FLASH_Lock();
 8001aca:	f7ff fac1 	bl	8001050 <FLASH_Lock>
			return ERROR;
 8001ace:	2300      	movs	r3, #0
 8001ad0:	e00c      	b.n	8001aec <UserData_Write+0x9c>
		}
		source_addr++;
 8001ad2:	68fb      	ldr	r3, [r7, #12]
 8001ad4:	3304      	adds	r3, #4
 8001ad6:	60fb      	str	r3, [r7, #12]
		dest_addr += WORD_SIZE;
 8001ad8:	68bb      	ldr	r3, [r7, #8]
 8001ada:	3304      	adds	r3, #4
 8001adc:	60bb      	str	r3, [r7, #8]
	for (uint16_t i = 0; i < USERDATA_WORDS_SIZE; i++) {
 8001ade:	88fb      	ldrh	r3, [r7, #6]
 8001ae0:	3301      	adds	r3, #1
 8001ae2:	80fb      	strh	r3, [r7, #6]
 8001ae4:	88fb      	ldrh	r3, [r7, #6]
 8001ae6:	2b01      	cmp	r3, #1
 8001ae8:	d9dc      	bls.n	8001aa4 <UserData_Write+0x54>
	}
//	printf("write success\n");
	return SUCCESS;
 8001aea:	2301      	movs	r3, #1
}
 8001aec:	4618      	mov	r0, r3
 8001aee:	3710      	adds	r7, #16
 8001af0:	46bd      	mov	sp, r7
 8001af2:	bd80      	pop	{r7, pc}
 8001af4:	20000070 	.word	0x20000070
 8001af8:	08030000 	.word	0x08030000
 8001afc:	08010000 	.word	0x08010000
 8001b00:	200001c8 	.word	0x200001c8

08001b04 <UserData_Read>:

static void UserData_Read( void ){
 8001b04:	b480      	push	{r7}
 8001b06:	b085      	sub	sp, #20
 8001b08:	af00      	add	r7, sp, #0
	//Read settings
	uint32_t *source_addr = (uint32_t *)UserDataAddress;
 8001b0a:	4b0f      	ldr	r3, [pc, #60]	; (8001b48 <UserData_Read+0x44>)
 8001b0c:	681b      	ldr	r3, [r3, #0]
 8001b0e:	60fb      	str	r3, [r7, #12]
	uint32_t *dest_addr = (void *)&UserData;
 8001b10:	4b0e      	ldr	r3, [pc, #56]	; (8001b4c <UserData_Read+0x48>)
 8001b12:	60bb      	str	r3, [r7, #8]
	for (uint16_t i=0; i < USERDATA_WORDS_SIZE; i++) {
 8001b14:	2300      	movs	r3, #0
 8001b16:	80fb      	strh	r3, [r7, #6]
 8001b18:	e00c      	b.n	8001b34 <UserData_Read+0x30>
		*dest_addr = *(__IO uint32_t*)source_addr;
 8001b1a:	68fb      	ldr	r3, [r7, #12]
 8001b1c:	681a      	ldr	r2, [r3, #0]
 8001b1e:	68bb      	ldr	r3, [r7, #8]
 8001b20:	601a      	str	r2, [r3, #0]
		source_addr++;
 8001b22:	68fb      	ldr	r3, [r7, #12]
 8001b24:	3304      	adds	r3, #4
 8001b26:	60fb      	str	r3, [r7, #12]
		dest_addr++;
 8001b28:	68bb      	ldr	r3, [r7, #8]
 8001b2a:	3304      	adds	r3, #4
 8001b2c:	60bb      	str	r3, [r7, #8]
	for (uint16_t i=0; i < USERDATA_WORDS_SIZE; i++) {
 8001b2e:	88fb      	ldrh	r3, [r7, #6]
 8001b30:	3301      	adds	r3, #1
 8001b32:	80fb      	strh	r3, [r7, #6]
 8001b34:	88fb      	ldrh	r3, [r7, #6]
 8001b36:	2b01      	cmp	r3, #1
 8001b38:	d9ef      	bls.n	8001b1a <UserData_Read+0x16>
	}
}
 8001b3a:	bf00      	nop
 8001b3c:	bf00      	nop
 8001b3e:	3714      	adds	r7, #20
 8001b40:	46bd      	mov	sp, r7
 8001b42:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b46:	4770      	bx	lr
 8001b48:	20000070 	.word	0x20000070
 8001b4c:	200001c8 	.word	0x200001c8

08001b50 <UserData_Erase>:

static void UserData_Erase(){
 8001b50:	b580      	push	{r7, lr}
 8001b52:	af00      	add	r7, sp, #0
	/* Enable the flash control register access */
	FLASH_Unlock();
 8001b54:	f7ff fa64 	bl	8001020 <FLASH_Unlock>

	FLASH_EraseSector(FLASH_Sector_5, VoltageRange_4);
 8001b58:	2103      	movs	r1, #3
 8001b5a:	2028      	movs	r0, #40	; 0x28
 8001b5c:	f7ff fa88 	bl	8001070 <FLASH_EraseSector>

	FLASH_Lock();
 8001b60:	f7ff fa76 	bl	8001050 <FLASH_Lock>
}
 8001b64:	bf00      	nop
 8001b66:	bd80      	pop	{r7, pc}

08001b68 <LedControl_Init>:
 * @brief  Initializes module led
 * @param  None
 * @retval None
 */
void
LedControl_Init(void) {
 8001b68:	b580      	push	{r7, lr}
 8001b6a:	af00      	add	r7, sp, #0
	// Initialize pins GPIO led
	LEDGPIO_Config();
 8001b6c:	f000 fa58 	bl	8002020 <LEDGPIO_Config>

	// Initialize TIMER led
	LEDTIM_Config();
 8001b70:	f000 faa0 	bl	80020b4 <LEDTIM_Config>
}
 8001b74:	bf00      	nop
 8001b76:	bd80      	pop	{r7, pc}

08001b78 <LedControl_SetColorIndividual>:
void
LedControl_SetColorIndividual(
	uint8_t led_id,
	led_color_t led_color,
	uint8_t led_level
) {
 8001b78:	b580      	push	{r7, lr}
 8001b7a:	b084      	sub	sp, #16
 8001b7c:	af00      	add	r7, sp, #0
 8001b7e:	4603      	mov	r3, r0
 8001b80:	71fb      	strb	r3, [r7, #7]
 8001b82:	460b      	mov	r3, r1
 8001b84:	71bb      	strb	r3, [r7, #6]
 8001b86:	4613      	mov	r3, r2
 8001b88:	717b      	strb	r3, [r7, #5]
	uint32_t channelPulse;

    if ((led_id >= NUM_OF_LED) || !isTypeLED(led_color) || (led_level > 100))
 8001b8a:	79fb      	ldrb	r3, [r7, #7]
 8001b8c:	2b02      	cmp	r3, #2
 8001b8e:	d85e      	bhi.n	8001c4e <LedControl_SetColorIndividual+0xd6>
 8001b90:	79bb      	ldrb	r3, [r7, #6]
 8001b92:	2b00      	cmp	r3, #0
 8001b94:	d005      	beq.n	8001ba2 <LedControl_SetColorIndividual+0x2a>
 8001b96:	79bb      	ldrb	r3, [r7, #6]
 8001b98:	2b01      	cmp	r3, #1
 8001b9a:	d002      	beq.n	8001ba2 <LedControl_SetColorIndividual+0x2a>
 8001b9c:	79bb      	ldrb	r3, [r7, #6]
 8001b9e:	2b02      	cmp	r3, #2
 8001ba0:	d155      	bne.n	8001c4e <LedControl_SetColorIndividual+0xd6>
 8001ba2:	797b      	ldrb	r3, [r7, #5]
 8001ba4:	2b64      	cmp	r3, #100	; 0x64
 8001ba6:	d852      	bhi.n	8001c4e <LedControl_SetColorIndividual+0xd6>
        return;
    
    // Get brightness current
    if (led_level == 0)
 8001ba8:	797b      	ldrb	r3, [r7, #5]
 8001baa:	2b00      	cmp	r3, #0
 8001bac:	d103      	bne.n	8001bb6 <LedControl_SetColorIndividual+0x3e>
    {
    	g_brightnessLed = 100;
 8001bae:	4b2a      	ldr	r3, [pc, #168]	; (8001c58 <LedControl_SetColorIndividual+0xe0>)
 8001bb0:	2264      	movs	r2, #100	; 0x64
 8001bb2:	701a      	strb	r2, [r3, #0]
 8001bb4:	e002      	b.n	8001bbc <LedControl_SetColorIndividual+0x44>
    }
    else
    {
    	g_brightnessLed = led_level;
 8001bb6:	4a28      	ldr	r2, [pc, #160]	; (8001c58 <LedControl_SetColorIndividual+0xe0>)
 8001bb8:	797b      	ldrb	r3, [r7, #5]
 8001bba:	7013      	strb	r3, [r2, #0]
    }

    // Convert value level to value pwm counter
    channelPulse = (((uint32_t) led_level * (LED_TIMER_PERIOD - 1)) / 100);
 8001bbc:	797b      	ldrb	r3, [r7, #5]
 8001bbe:	4a27      	ldr	r2, [pc, #156]	; (8001c5c <LedControl_SetColorIndividual+0xe4>)
 8001bc0:	6812      	ldr	r2, [r2, #0]
 8001bc2:	4927      	ldr	r1, [pc, #156]	; (8001c60 <LedControl_SetColorIndividual+0xe8>)
 8001bc4:	fba1 1202 	umull	r1, r2, r1, r2
 8001bc8:	0b92      	lsrs	r2, r2, #14
 8001bca:	3a02      	subs	r2, #2
 8001bcc:	fb02 f303 	mul.w	r3, r2, r3
 8001bd0:	4a24      	ldr	r2, [pc, #144]	; (8001c64 <LedControl_SetColorIndividual+0xec>)
 8001bd2:	fba2 2303 	umull	r2, r3, r2, r3
 8001bd6:	095b      	lsrs	r3, r3, #5
 8001bd8:	60fb      	str	r3, [r7, #12]

    if (led_id == LED_BOARD_ID)
 8001bda:	79fb      	ldrb	r3, [r7, #7]
 8001bdc:	2b00      	cmp	r3, #0
 8001bde:	d10c      	bne.n	8001bfa <LedControl_SetColorIndividual+0x82>
    {
    	if (led_level != 0)
 8001be0:	797b      	ldrb	r3, [r7, #5]
 8001be2:	2b00      	cmp	r3, #0
 8001be4:	d004      	beq.n	8001bf0 <LedControl_SetColorIndividual+0x78>
    	{
    		GPIO_SetBits(LED_BOARD_PORT, LED_BOARD_PIN);
 8001be6:	2120      	movs	r1, #32
 8001be8:	481f      	ldr	r0, [pc, #124]	; (8001c68 <LedControl_SetColorIndividual+0xf0>)
 8001bea:	f7fe fcfc 	bl	80005e6 <GPIO_SetBits>
 8001bee:	e02f      	b.n	8001c50 <LedControl_SetColorIndividual+0xd8>
    	}
    	else
    	{
    		GPIO_ResetBits(LED_BOARD_PORT, LED_BOARD_PIN);
 8001bf0:	2120      	movs	r1, #32
 8001bf2:	481d      	ldr	r0, [pc, #116]	; (8001c68 <LedControl_SetColorIndividual+0xf0>)
 8001bf4:	f7fe fd06 	bl	8000604 <GPIO_ResetBits>
 8001bf8:	e02a      	b.n	8001c50 <LedControl_SetColorIndividual+0xd8>
    	}
    }
    else if (led_id == LED_KIT_ID0)
 8001bfa:	79fb      	ldrb	r3, [r7, #7]
 8001bfc:	2b01      	cmp	r3, #1
 8001bfe:	d114      	bne.n	8001c2a <LedControl_SetColorIndividual+0xb2>
	{
    	if (led_color == LED_COLOR_RED)
 8001c00:	79bb      	ldrb	r3, [r7, #6]
 8001c02:	2b00      	cmp	r3, #0
 8001c04:	d104      	bne.n	8001c10 <LedControl_SetColorIndividual+0x98>
    	{
    		TIM_SetCompare1(TIM1, channelPulse);
 8001c06:	68f9      	ldr	r1, [r7, #12]
 8001c08:	4818      	ldr	r0, [pc, #96]	; (8001c6c <LedControl_SetColorIndividual+0xf4>)
 8001c0a:	f7ff f8f5 	bl	8000df8 <TIM_SetCompare1>
 8001c0e:	e01f      	b.n	8001c50 <LedControl_SetColorIndividual+0xd8>
    	}
    	else if (led_color == LED_COLOR_GREEN)
 8001c10:	79bb      	ldrb	r3, [r7, #6]
 8001c12:	2b01      	cmp	r3, #1
 8001c14:	d104      	bne.n	8001c20 <LedControl_SetColorIndividual+0xa8>
    	{
    		TIM_SetCompare4(TIM1, channelPulse);
 8001c16:	68f9      	ldr	r1, [r7, #12]
 8001c18:	4814      	ldr	r0, [pc, #80]	; (8001c6c <LedControl_SetColorIndividual+0xf4>)
 8001c1a:	f7ff f917 	bl	8000e4c <TIM_SetCompare4>
 8001c1e:	e017      	b.n	8001c50 <LedControl_SetColorIndividual+0xd8>
    	}
    	else /* (led_color == LED_COLOR_BLUE) */
    	{
			TIM_SetCompare3(TIM1, channelPulse);
 8001c20:	68f9      	ldr	r1, [r7, #12]
 8001c22:	4812      	ldr	r0, [pc, #72]	; (8001c6c <LedControl_SetColorIndividual+0xf4>)
 8001c24:	f7ff f904 	bl	8000e30 <TIM_SetCompare3>
 8001c28:	e012      	b.n	8001c50 <LedControl_SetColorIndividual+0xd8>
		}
	}
    else /* (led_id == LED_KIT_ID1) */
    {
    	if (led_color == LED_COLOR_RED)
 8001c2a:	79bb      	ldrb	r3, [r7, #6]
 8001c2c:	2b00      	cmp	r3, #0
 8001c2e:	d105      	bne.n	8001c3c <LedControl_SetColorIndividual+0xc4>
    	{
    		TIM_SetCompare2(TIM2, channelPulse);
 8001c30:	68f9      	ldr	r1, [r7, #12]
 8001c32:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8001c36:	f7ff f8ed 	bl	8000e14 <TIM_SetCompare2>
 8001c3a:	e009      	b.n	8001c50 <LedControl_SetColorIndividual+0xd8>
    	}
    	else if (led_color == LED_COLOR_GREEN)
 8001c3c:	79bb      	ldrb	r3, [r7, #6]
 8001c3e:	2b01      	cmp	r3, #1
 8001c40:	d106      	bne.n	8001c50 <LedControl_SetColorIndividual+0xd8>
    	{
    		TIM_SetCompare1(TIM2, channelPulse);
 8001c42:	68f9      	ldr	r1, [r7, #12]
 8001c44:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8001c48:	f7ff f8d6 	bl	8000df8 <TIM_SetCompare1>
 8001c4c:	e000      	b.n	8001c50 <LedControl_SetColorIndividual+0xd8>
        return;
 8001c4e:	bf00      	nop
    	}
    	else /* (led_color == LED_COLOR_BLUE) */
    	{
		}
    }
}
 8001c50:	3710      	adds	r7, #16
 8001c52:	46bd      	mov	sp, r7
 8001c54:	bd80      	pop	{r7, pc}
 8001c56:	bf00      	nop
 8001c58:	200001da 	.word	0x200001da
 8001c5c:	20000000 	.word	0x20000000
 8001c60:	eeb83a0d 	.word	0xeeb83a0d
 8001c64:	51eb851f 	.word	0x51eb851f
 8001c68:	40020000 	.word	0x40020000
 8001c6c:	40010000 	.word	0x40010000

08001c70 <LedControl_SetColorGeneral>:
void
LedControl_SetColorGeneral(
	uint8_t led_id,
	led_color_t led_color,
	uint8_t led_level
) {
 8001c70:	b580      	push	{r7, lr}
 8001c72:	b082      	sub	sp, #8
 8001c74:	af00      	add	r7, sp, #0
 8001c76:	4603      	mov	r3, r0
 8001c78:	71fb      	strb	r3, [r7, #7]
 8001c7a:	460b      	mov	r3, r1
 8001c7c:	71bb      	strb	r3, [r7, #6]
 8001c7e:	4613      	mov	r3, r2
 8001c80:	717b      	strb	r3, [r7, #5]
    switch (led_color) {
 8001c82:	79bb      	ldrb	r3, [r7, #6]
 8001c84:	2b05      	cmp	r3, #5
 8001c86:	f200 8081 	bhi.w	8001d8c <LedControl_SetColorGeneral+0x11c>
 8001c8a:	a201      	add	r2, pc, #4	; (adr r2, 8001c90 <LedControl_SetColorGeneral+0x20>)
 8001c8c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001c90:	08001ca9 	.word	0x08001ca9
 8001c94:	08001ccf 	.word	0x08001ccf
 8001c98:	08001cf5 	.word	0x08001cf5
 8001c9c:	08001d1b 	.word	0x08001d1b
 8001ca0:	08001d67 	.word	0x08001d67
 8001ca4:	08001d41 	.word	0x08001d41
        case LED_COLOR_RED:
        	LedControl_SetColorIndividual(led_id, LED_COLOR_RED, led_level);
 8001ca8:	797a      	ldrb	r2, [r7, #5]
 8001caa:	79fb      	ldrb	r3, [r7, #7]
 8001cac:	2100      	movs	r1, #0
 8001cae:	4618      	mov	r0, r3
 8001cb0:	f7ff ff62 	bl	8001b78 <LedControl_SetColorIndividual>
        	LedControl_SetColorIndividual(led_id, LED_COLOR_BLUE, 0);
 8001cb4:	79fb      	ldrb	r3, [r7, #7]
 8001cb6:	2200      	movs	r2, #0
 8001cb8:	2102      	movs	r1, #2
 8001cba:	4618      	mov	r0, r3
 8001cbc:	f7ff ff5c 	bl	8001b78 <LedControl_SetColorIndividual>
        	LedControl_SetColorIndividual(led_id, LED_COLOR_GREEN, 0);
 8001cc0:	79fb      	ldrb	r3, [r7, #7]
 8001cc2:	2200      	movs	r2, #0
 8001cc4:	2101      	movs	r1, #1
 8001cc6:	4618      	mov	r0, r3
 8001cc8:	f7ff ff56 	bl	8001b78 <LedControl_SetColorIndividual>
            break;
 8001ccc:	e05f      	b.n	8001d8e <LedControl_SetColorGeneral+0x11e>

        case LED_COLOR_GREEN:
        	LedControl_SetColorIndividual(led_id, LED_COLOR_GREEN, led_level);
 8001cce:	797a      	ldrb	r2, [r7, #5]
 8001cd0:	79fb      	ldrb	r3, [r7, #7]
 8001cd2:	2101      	movs	r1, #1
 8001cd4:	4618      	mov	r0, r3
 8001cd6:	f7ff ff4f 	bl	8001b78 <LedControl_SetColorIndividual>
        	LedControl_SetColorIndividual(led_id, LED_COLOR_RED, 0);
 8001cda:	79fb      	ldrb	r3, [r7, #7]
 8001cdc:	2200      	movs	r2, #0
 8001cde:	2100      	movs	r1, #0
 8001ce0:	4618      	mov	r0, r3
 8001ce2:	f7ff ff49 	bl	8001b78 <LedControl_SetColorIndividual>
        	LedControl_SetColorIndividual(led_id, LED_COLOR_BLUE, 0);
 8001ce6:	79fb      	ldrb	r3, [r7, #7]
 8001ce8:	2200      	movs	r2, #0
 8001cea:	2102      	movs	r1, #2
 8001cec:	4618      	mov	r0, r3
 8001cee:	f7ff ff43 	bl	8001b78 <LedControl_SetColorIndividual>
			break;
 8001cf2:	e04c      	b.n	8001d8e <LedControl_SetColorGeneral+0x11e>

        case LED_COLOR_BLUE:
        	LedControl_SetColorIndividual(led_id, LED_COLOR_BLUE, led_level);
 8001cf4:	797a      	ldrb	r2, [r7, #5]
 8001cf6:	79fb      	ldrb	r3, [r7, #7]
 8001cf8:	2102      	movs	r1, #2
 8001cfa:	4618      	mov	r0, r3
 8001cfc:	f7ff ff3c 	bl	8001b78 <LedControl_SetColorIndividual>
        	LedControl_SetColorIndividual(led_id, LED_COLOR_RED, 0);
 8001d00:	79fb      	ldrb	r3, [r7, #7]
 8001d02:	2200      	movs	r2, #0
 8001d04:	2100      	movs	r1, #0
 8001d06:	4618      	mov	r0, r3
 8001d08:	f7ff ff36 	bl	8001b78 <LedControl_SetColorIndividual>
        	LedControl_SetColorIndividual(led_id, LED_COLOR_GREEN, 0);
 8001d0c:	79fb      	ldrb	r3, [r7, #7]
 8001d0e:	2200      	movs	r2, #0
 8001d10:	2101      	movs	r1, #1
 8001d12:	4618      	mov	r0, r3
 8001d14:	f7ff ff30 	bl	8001b78 <LedControl_SetColorIndividual>
            break;
 8001d18:	e039      	b.n	8001d8e <LedControl_SetColorGeneral+0x11e>

        case LED_COLOR_WHITE:
        	LedControl_SetColorIndividual(led_id, LED_COLOR_BLUE, led_level);
 8001d1a:	797a      	ldrb	r2, [r7, #5]
 8001d1c:	79fb      	ldrb	r3, [r7, #7]
 8001d1e:	2102      	movs	r1, #2
 8001d20:	4618      	mov	r0, r3
 8001d22:	f7ff ff29 	bl	8001b78 <LedControl_SetColorIndividual>
        	LedControl_SetColorIndividual(led_id, LED_COLOR_RED, led_level);
 8001d26:	797a      	ldrb	r2, [r7, #5]
 8001d28:	79fb      	ldrb	r3, [r7, #7]
 8001d2a:	2100      	movs	r1, #0
 8001d2c:	4618      	mov	r0, r3
 8001d2e:	f7ff ff23 	bl	8001b78 <LedControl_SetColorIndividual>
        	LedControl_SetColorIndividual(led_id, LED_COLOR_GREEN, led_level);
 8001d32:	797a      	ldrb	r2, [r7, #5]
 8001d34:	79fb      	ldrb	r3, [r7, #7]
 8001d36:	2101      	movs	r1, #1
 8001d38:	4618      	mov	r0, r3
 8001d3a:	f7ff ff1d 	bl	8001b78 <LedControl_SetColorIndividual>
        	break;
 8001d3e:	e026      	b.n	8001d8e <LedControl_SetColorGeneral+0x11e>

        case LED_COLOR_YELLOW:
			LedControl_SetColorIndividual(led_id, LED_COLOR_BLUE, 0);
 8001d40:	79fb      	ldrb	r3, [r7, #7]
 8001d42:	2200      	movs	r2, #0
 8001d44:	2102      	movs	r1, #2
 8001d46:	4618      	mov	r0, r3
 8001d48:	f7ff ff16 	bl	8001b78 <LedControl_SetColorIndividual>
			LedControl_SetColorIndividual(led_id, LED_COLOR_RED, led_level);
 8001d4c:	797a      	ldrb	r2, [r7, #5]
 8001d4e:	79fb      	ldrb	r3, [r7, #7]
 8001d50:	2100      	movs	r1, #0
 8001d52:	4618      	mov	r0, r3
 8001d54:	f7ff ff10 	bl	8001b78 <LedControl_SetColorIndividual>
			LedControl_SetColorIndividual(led_id, LED_COLOR_GREEN, led_level);
 8001d58:	797a      	ldrb	r2, [r7, #5]
 8001d5a:	79fb      	ldrb	r3, [r7, #7]
 8001d5c:	2101      	movs	r1, #1
 8001d5e:	4618      	mov	r0, r3
 8001d60:	f7ff ff0a 	bl	8001b78 <LedControl_SetColorIndividual>
			break;
 8001d64:	e013      	b.n	8001d8e <LedControl_SetColorGeneral+0x11e>

        case LED_COLOR_BLACK:
			LedControl_SetColorIndividual(led_id, LED_COLOR_BLUE, 0);
 8001d66:	79fb      	ldrb	r3, [r7, #7]
 8001d68:	2200      	movs	r2, #0
 8001d6a:	2102      	movs	r1, #2
 8001d6c:	4618      	mov	r0, r3
 8001d6e:	f7ff ff03 	bl	8001b78 <LedControl_SetColorIndividual>
			LedControl_SetColorIndividual(led_id, LED_COLOR_RED, 0);
 8001d72:	79fb      	ldrb	r3, [r7, #7]
 8001d74:	2200      	movs	r2, #0
 8001d76:	2100      	movs	r1, #0
 8001d78:	4618      	mov	r0, r3
 8001d7a:	f7ff fefd 	bl	8001b78 <LedControl_SetColorIndividual>
			LedControl_SetColorIndividual(led_id, LED_COLOR_GREEN, 0);
 8001d7e:	79fb      	ldrb	r3, [r7, #7]
 8001d80:	2200      	movs	r2, #0
 8001d82:	2101      	movs	r1, #1
 8001d84:	4618      	mov	r0, r3
 8001d86:	f7ff fef7 	bl	8001b78 <LedControl_SetColorIndividual>
			break;
 8001d8a:	e000      	b.n	8001d8e <LedControl_SetColorGeneral+0x11e>

        default:
            break;
 8001d8c:	bf00      	nop
    }
}
 8001d8e:	bf00      	nop
 8001d90:	3708      	adds	r7, #8
 8001d92:	46bd      	mov	sp, r7
 8001d94:	bd80      	pop	{r7, pc}
 8001d96:	bf00      	nop

08001d98 <LedGetAllLastState>:
 * @func   LedGetLevelAllLed
 * @brief  Get color of all led
 * @param  None
 * @retval level
 */
static void LedGetAllLastState(void) {
 8001d98:	b480      	push	{r7}
 8001d9a:	af00      	add	r7, sp, #0

}
 8001d9c:	bf00      	nop
 8001d9e:	46bd      	mov	sp, r7
 8001da0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001da4:	4770      	bx	lr
	...

08001da8 <LedToggle>:
 * @param  led_id: identify of led
 *         led_color: color of led
 * @retval None
 */
static void LedToggle(uint8_t led_id, led_color_t led_color)
{
 8001da8:	b580      	push	{r7, lr}
 8001daa:	b084      	sub	sp, #16
 8001dac:	af00      	add	r7, sp, #0
 8001dae:	4603      	mov	r3, r0
 8001db0:	460a      	mov	r2, r1
 8001db2:	71fb      	strb	r3, [r7, #7]
 8001db4:	4613      	mov	r3, r2
 8001db6:	71bb      	strb	r3, [r7, #6]
    uint8_t led_level;
    static uint8_t bToggle = 0, bToggleAll = 0;

    if (led_id > LED_ALL_ID) return;
 8001db8:	79fb      	ldrb	r3, [r7, #7]
 8001dba:	2b03      	cmp	r3, #3
 8001dbc:	d838      	bhi.n	8001e30 <LedToggle+0x88>

    if (led_id == LED_ALL_ID) {
 8001dbe:	79fb      	ldrb	r3, [r7, #7]
 8001dc0:	2b03      	cmp	r3, #3
 8001dc2:	d11a      	bne.n	8001dfa <LedToggle+0x52>
        if (bToggleAll == 0)
 8001dc4:	4b1c      	ldr	r3, [pc, #112]	; (8001e38 <LedToggle+0x90>)
 8001dc6:	781b      	ldrb	r3, [r3, #0]
 8001dc8:	2b00      	cmp	r3, #0
 8001dca:	d103      	bne.n	8001dd4 <LedToggle+0x2c>
        {
        	led_level = g_brightnessLed;
 8001dcc:	4b1b      	ldr	r3, [pc, #108]	; (8001e3c <LedToggle+0x94>)
 8001dce:	781b      	ldrb	r3, [r3, #0]
 8001dd0:	73fb      	strb	r3, [r7, #15]
 8001dd2:	e001      	b.n	8001dd8 <LedToggle+0x30>
        }
        else /* (bToggleAll == 1) */
        {
        	led_level = 0;
 8001dd4:	2300      	movs	r3, #0
 8001dd6:	73fb      	strb	r3, [r7, #15]
        }
        bToggleAll = !bToggleAll;
 8001dd8:	4b17      	ldr	r3, [pc, #92]	; (8001e38 <LedToggle+0x90>)
 8001dda:	781b      	ldrb	r3, [r3, #0]
 8001ddc:	2b00      	cmp	r3, #0
 8001dde:	bf0c      	ite	eq
 8001de0:	2301      	moveq	r3, #1
 8001de2:	2300      	movne	r3, #0
 8001de4:	b2db      	uxtb	r3, r3
 8001de6:	461a      	mov	r2, r3
 8001de8:	4b13      	ldr	r3, [pc, #76]	; (8001e38 <LedToggle+0x90>)
 8001dea:	701a      	strb	r2, [r3, #0]
        LedControl_SetAllColor(led_color, led_level);
 8001dec:	7bfa      	ldrb	r2, [r7, #15]
 8001dee:	79bb      	ldrb	r3, [r7, #6]
 8001df0:	4611      	mov	r1, r2
 8001df2:	4618      	mov	r0, r3
 8001df4:	f000 f8f8 	bl	8001fe8 <LedControl_SetAllColor>
 8001df8:	e01b      	b.n	8001e32 <LedToggle+0x8a>
    }
    else {
        if (bToggle == 0)
 8001dfa:	4b11      	ldr	r3, [pc, #68]	; (8001e40 <LedToggle+0x98>)
 8001dfc:	781b      	ldrb	r3, [r3, #0]
 8001dfe:	2b00      	cmp	r3, #0
 8001e00:	d103      	bne.n	8001e0a <LedToggle+0x62>
        {
        	led_level = g_brightnessLed;
 8001e02:	4b0e      	ldr	r3, [pc, #56]	; (8001e3c <LedToggle+0x94>)
 8001e04:	781b      	ldrb	r3, [r3, #0]
 8001e06:	73fb      	strb	r3, [r7, #15]
 8001e08:	e001      	b.n	8001e0e <LedToggle+0x66>
        }
        else /* (bToggle == 1) */
        {
        	led_level = 0;
 8001e0a:	2300      	movs	r3, #0
 8001e0c:	73fb      	strb	r3, [r7, #15]
        }
        bToggle = !bToggle;
 8001e0e:	4b0c      	ldr	r3, [pc, #48]	; (8001e40 <LedToggle+0x98>)
 8001e10:	781b      	ldrb	r3, [r3, #0]
 8001e12:	2b00      	cmp	r3, #0
 8001e14:	bf0c      	ite	eq
 8001e16:	2301      	moveq	r3, #1
 8001e18:	2300      	movne	r3, #0
 8001e1a:	b2db      	uxtb	r3, r3
 8001e1c:	461a      	mov	r2, r3
 8001e1e:	4b08      	ldr	r3, [pc, #32]	; (8001e40 <LedToggle+0x98>)
 8001e20:	701a      	strb	r2, [r3, #0]
        LedControl_SetColorGeneral(led_id, led_color, led_level);
 8001e22:	7bfa      	ldrb	r2, [r7, #15]
 8001e24:	79b9      	ldrb	r1, [r7, #6]
 8001e26:	79fb      	ldrb	r3, [r7, #7]
 8001e28:	4618      	mov	r0, r3
 8001e2a:	f7ff ff21 	bl	8001c70 <LedControl_SetColorGeneral>
 8001e2e:	e000      	b.n	8001e32 <LedToggle+0x8a>
    if (led_id > LED_ALL_ID) return;
 8001e30:	bf00      	nop
    }
}
 8001e32:	3710      	adds	r7, #16
 8001e34:	46bd      	mov	sp, r7
 8001e36:	bd80      	pop	{r7, pc}
 8001e38:	200001db 	.word	0x200001db
 8001e3c:	200001da 	.word	0x200001da
 8001e40:	200001dc 	.word	0x200001dc

08001e44 <pFuncBlink>:
 * @brief  Blink led
 * @param  arg
 * @retval None
 */
static void pFuncBlink(void *arg)
{
 8001e44:	b580      	push	{r7, lr}
 8001e46:	b084      	sub	sp, #16
 8001e48:	af00      	add	r7, sp, #0
 8001e4a:	6078      	str	r0, [r7, #4]
    cmd_led_indicator_t *pLedinfor = (cmd_led_indicator_t *)arg;
 8001e4c:	687b      	ldr	r3, [r7, #4]
 8001e4e:	60fb      	str	r3, [r7, #12]

    if (pLedinfor->counter == 0) {
 8001e50:	68fb      	ldr	r3, [r7, #12]
 8001e52:	791b      	ldrb	r3, [r3, #4]
 8001e54:	2b00      	cmp	r3, #0
 8001e56:	d103      	bne.n	8001e60 <pFuncBlink+0x1c>
        BlinkStop(pLedinfor);
 8001e58:	68f8      	ldr	r0, [r7, #12]
 8001e5a:	f000 f84b 	bl	8001ef4 <BlinkStop>
        return;
 8001e5e:	e043      	b.n	8001ee8 <pFuncBlink+0xa4>
    }
    if ((pLedinfor->counter != BLINK_FOREVER) && (pLedinfor->counter != 0)) {
 8001e60:	68fb      	ldr	r3, [r7, #12]
 8001e62:	791b      	ldrb	r3, [r3, #4]
 8001e64:	2bff      	cmp	r3, #255	; 0xff
 8001e66:	d009      	beq.n	8001e7c <pFuncBlink+0x38>
 8001e68:	68fb      	ldr	r3, [r7, #12]
 8001e6a:	791b      	ldrb	r3, [r3, #4]
 8001e6c:	2b00      	cmp	r3, #0
 8001e6e:	d005      	beq.n	8001e7c <pFuncBlink+0x38>
    	pLedinfor->counter--;
 8001e70:	68fb      	ldr	r3, [r7, #12]
 8001e72:	791b      	ldrb	r3, [r3, #4]
 8001e74:	3b01      	subs	r3, #1
 8001e76:	b2da      	uxtb	r2, r3
 8001e78:	68fb      	ldr	r3, [r7, #12]
 8001e7a:	711a      	strb	r2, [r3, #4]
    }

    switch ((led_blink_type_t)pLedinfor->color)
 8001e7c:	68fb      	ldr	r3, [r7, #12]
 8001e7e:	78db      	ldrb	r3, [r3, #3]
 8001e80:	2b03      	cmp	r3, #3
 8001e82:	d830      	bhi.n	8001ee6 <pFuncBlink+0xa2>
 8001e84:	a201      	add	r2, pc, #4	; (adr r2, 8001e8c <pFuncBlink+0x48>)
 8001e86:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001e8a:	bf00      	nop
 8001e8c:	08001e9d 	.word	0x08001e9d
 8001e90:	08001eb9 	.word	0x08001eb9
 8001e94:	08001eab 	.word	0x08001eab
 8001e98:	08001ec7 	.word	0x08001ec7
    {
        case BLINK_RED:
        	LedToggle(pLedinfor->numID, LED_COLOR_RED);
 8001e9c:	68fb      	ldr	r3, [r7, #12]
 8001e9e:	789b      	ldrb	r3, [r3, #2]
 8001ea0:	2100      	movs	r1, #0
 8001ea2:	4618      	mov	r0, r3
 8001ea4:	f7ff ff80 	bl	8001da8 <LedToggle>
            break;
 8001ea8:	e014      	b.n	8001ed4 <pFuncBlink+0x90>

        case BLINK_GREEN:
        	LedToggle(pLedinfor->numID, LED_COLOR_GREEN);
 8001eaa:	68fb      	ldr	r3, [r7, #12]
 8001eac:	789b      	ldrb	r3, [r3, #2]
 8001eae:	2101      	movs	r1, #1
 8001eb0:	4618      	mov	r0, r3
 8001eb2:	f7ff ff79 	bl	8001da8 <LedToggle>
            break;
 8001eb6:	e00d      	b.n	8001ed4 <pFuncBlink+0x90>

        case BLINK_BLUE:
			LedToggle(pLedinfor->numID, LED_COLOR_BLUE);
 8001eb8:	68fb      	ldr	r3, [r7, #12]
 8001eba:	789b      	ldrb	r3, [r3, #2]
 8001ebc:	2102      	movs	r1, #2
 8001ebe:	4618      	mov	r0, r3
 8001ec0:	f7ff ff72 	bl	8001da8 <LedToggle>
			break;
 8001ec4:	e006      	b.n	8001ed4 <pFuncBlink+0x90>

        case BLINK_WHITE:
			LedToggle(pLedinfor->numID, LED_COLOR_WHITE);
 8001ec6:	68fb      	ldr	r3, [r7, #12]
 8001ec8:	789b      	ldrb	r3, [r3, #2]
 8001eca:	2103      	movs	r1, #3
 8001ecc:	4618      	mov	r0, r3
 8001ece:	f7ff ff6b 	bl	8001da8 <LedToggle>
			break;
 8001ed2:	bf00      	nop
        default:
            return;
    }

    /* Change period of timer */
    TimerChangePeriod(blinkTimer, pLedinfor->interval);
 8001ed4:	4b06      	ldr	r3, [pc, #24]	; (8001ef0 <pFuncBlink+0xac>)
 8001ed6:	781a      	ldrb	r2, [r3, #0]
 8001ed8:	68fb      	ldr	r3, [r7, #12]
 8001eda:	88db      	ldrh	r3, [r3, #6]
 8001edc:	4619      	mov	r1, r3
 8001ede:	4610      	mov	r0, r2
 8001ee0:	f000 fa7c 	bl	80023dc <TimerChangePeriod>
 8001ee4:	e000      	b.n	8001ee8 <pFuncBlink+0xa4>
            return;
 8001ee6:	bf00      	nop
}
 8001ee8:	3710      	adds	r7, #16
 8001eea:	46bd      	mov	sp, r7
 8001eec:	bd80      	pop	{r7, pc}
 8001eee:	bf00      	nop
 8001ef0:	20000074 	.word	0x20000074

08001ef4 <BlinkStop>:
 * @brief  Blink stop
 * @param  pLedinfor:
 * @retval None
 */
static void BlinkStop(cmd_led_indicator_t *pLedinfor)
{
 8001ef4:	b580      	push	{r7, lr}
 8001ef6:	b082      	sub	sp, #8
 8001ef8:	af00      	add	r7, sp, #0
 8001efa:	6078      	str	r0, [r7, #4]
    if (blinkTimer != NO_TIMER)
 8001efc:	4b19      	ldr	r3, [pc, #100]	; (8001f64 <BlinkStop+0x70>)
 8001efe:	781b      	ldrb	r3, [r3, #0]
 8001f00:	2bff      	cmp	r3, #255	; 0xff
 8001f02:	d007      	beq.n	8001f14 <BlinkStop+0x20>
    {
        TimerStop(blinkTimer);
 8001f04:	4b17      	ldr	r3, [pc, #92]	; (8001f64 <BlinkStop+0x70>)
 8001f06:	781b      	ldrb	r3, [r3, #0]
 8001f08:	4618      	mov	r0, r3
 8001f0a:	f000 fa83 	bl	8002414 <TimerStop>
        blinkTimer = NO_TIMER;
 8001f0e:	4b15      	ldr	r3, [pc, #84]	; (8001f64 <BlinkStop+0x70>)
 8001f10:	22ff      	movs	r2, #255	; 0xff
 8001f12:	701a      	strb	r2, [r3, #0]
    }

    if (pLedinfor->numID == LED_ALL_ID)
 8001f14:	687b      	ldr	r3, [r7, #4]
 8001f16:	789b      	ldrb	r3, [r3, #2]
 8001f18:	2b03      	cmp	r3, #3
 8001f1a:	d106      	bne.n	8001f2a <BlinkStop+0x36>
    {
        if (pLedinfor->laststate == 0xFF)
 8001f1c:	687b      	ldr	r3, [r7, #4]
 8001f1e:	7a1b      	ldrb	r3, [r3, #8]
 8001f20:	2bff      	cmp	r3, #255	; 0xff
 8001f22:	d112      	bne.n	8001f4a <BlinkStop+0x56>
        {
            LedGetAllLastState();
 8001f24:	f7ff ff38 	bl	8001d98 <LedGetAllLastState>
 8001f28:	e00f      	b.n	8001f4a <BlinkStop+0x56>
        }
    }
    else {
        if (pLedinfor->laststate == 0xFF)
 8001f2a:	687b      	ldr	r3, [r7, #4]
 8001f2c:	7a1b      	ldrb	r3, [r3, #8]
 8001f2e:	2bff      	cmp	r3, #255	; 0xff
 8001f30:	d102      	bne.n	8001f38 <BlinkStop+0x44>
        {
            LedGetAllLastState();
 8001f32:	f7ff ff31 	bl	8001d98 <LedGetAllLastState>
 8001f36:	e008      	b.n	8001f4a <BlinkStop+0x56>
        }
        else
        {
            LedControl_SetColorGeneral(pLedinfor->numID, (led_color_t)pLedinfor->laststate, g_brightnessLed);
 8001f38:	687b      	ldr	r3, [r7, #4]
 8001f3a:	7898      	ldrb	r0, [r3, #2]
 8001f3c:	687b      	ldr	r3, [r7, #4]
 8001f3e:	7a1b      	ldrb	r3, [r3, #8]
 8001f40:	4a09      	ldr	r2, [pc, #36]	; (8001f68 <BlinkStop+0x74>)
 8001f42:	7812      	ldrb	r2, [r2, #0]
 8001f44:	4619      	mov	r1, r3
 8001f46:	f7ff fe93 	bl	8001c70 <LedControl_SetColorGeneral>
        }
    }

    pLedinfor->counter = 0;
 8001f4a:	687b      	ldr	r3, [r7, #4]
 8001f4c:	2200      	movs	r2, #0
 8001f4e:	711a      	strb	r2, [r3, #4]
    pLedinfor->color = BLINK_COLOR_MAX;
 8001f50:	687b      	ldr	r3, [r7, #4]
 8001f52:	2204      	movs	r2, #4
 8001f54:	70da      	strb	r2, [r3, #3]
    pLedinfor->interval = 0;
 8001f56:	687b      	ldr	r3, [r7, #4]
 8001f58:	2200      	movs	r2, #0
 8001f5a:	80da      	strh	r2, [r3, #6]
}
 8001f5c:	bf00      	nop
 8001f5e:	3708      	adds	r7, #8
 8001f60:	46bd      	mov	sp, r7
 8001f62:	bd80      	pop	{r7, pc}
 8001f64:	20000074 	.word	0x20000074
 8001f68:	200001da 	.word	0x200001da

08001f6c <LedControl_BlinkStart>:
	uint8_t led_id,
	led_blink_type_t led_blink,
	uint8_t led_numRepeat,
	uint16_t led_interval,
	uint8_t led_lastState
) {
 8001f6c:	b590      	push	{r4, r7, lr}
 8001f6e:	b085      	sub	sp, #20
 8001f70:	af02      	add	r7, sp, #8
 8001f72:	4604      	mov	r4, r0
 8001f74:	4608      	mov	r0, r1
 8001f76:	4611      	mov	r1, r2
 8001f78:	461a      	mov	r2, r3
 8001f7a:	4623      	mov	r3, r4
 8001f7c:	71fb      	strb	r3, [r7, #7]
 8001f7e:	4603      	mov	r3, r0
 8001f80:	71bb      	strb	r3, [r7, #6]
 8001f82:	460b      	mov	r3, r1
 8001f84:	717b      	strb	r3, [r7, #5]
 8001f86:	4613      	mov	r3, r2
 8001f88:	807b      	strh	r3, [r7, #2]
	if ((led_id > NUM_OF_LED) || (led_blink >= BLINK_COLOR_MAX))
 8001f8a:	79fb      	ldrb	r3, [r7, #7]
 8001f8c:	2b03      	cmp	r3, #3
 8001f8e:	d81e      	bhi.n	8001fce <LedControl_BlinkStart+0x62>
 8001f90:	79bb      	ldrb	r3, [r7, #6]
 8001f92:	2b03      	cmp	r3, #3
 8001f94:	d81b      	bhi.n	8001fce <LedControl_BlinkStart+0x62>
		return;

	ledBlink.numID = led_id;
 8001f96:	4a10      	ldr	r2, [pc, #64]	; (8001fd8 <LedControl_BlinkStart+0x6c>)
 8001f98:	79fb      	ldrb	r3, [r7, #7]
 8001f9a:	7093      	strb	r3, [r2, #2]
	ledBlink.color = (uint8_t)led_blink;
 8001f9c:	4a0e      	ldr	r2, [pc, #56]	; (8001fd8 <LedControl_BlinkStart+0x6c>)
 8001f9e:	79bb      	ldrb	r3, [r7, #6]
 8001fa0:	70d3      	strb	r3, [r2, #3]
	ledBlink.counter = led_numRepeat;
 8001fa2:	4a0d      	ldr	r2, [pc, #52]	; (8001fd8 <LedControl_BlinkStart+0x6c>)
 8001fa4:	797b      	ldrb	r3, [r7, #5]
 8001fa6:	7113      	strb	r3, [r2, #4]
	ledBlink.interval = led_interval;
 8001fa8:	4a0b      	ldr	r2, [pc, #44]	; (8001fd8 <LedControl_BlinkStart+0x6c>)
 8001faa:	887b      	ldrh	r3, [r7, #2]
 8001fac:	80d3      	strh	r3, [r2, #6]
	ledBlink.laststate = led_lastState;
 8001fae:	4a0a      	ldr	r2, [pc, #40]	; (8001fd8 <LedControl_BlinkStart+0x6c>)
 8001fb0:	7e3b      	ldrb	r3, [r7, #24]
 8001fb2:	7213      	strb	r3, [r2, #8]

	blinkTimer = TimerStart("BlinkLed", 1, TIMER_REPEAT_FOREVER, pFuncBlink, &ledBlink);
 8001fb4:	4b08      	ldr	r3, [pc, #32]	; (8001fd8 <LedControl_BlinkStart+0x6c>)
 8001fb6:	9300      	str	r3, [sp, #0]
 8001fb8:	4b08      	ldr	r3, [pc, #32]	; (8001fdc <LedControl_BlinkStart+0x70>)
 8001fba:	22ff      	movs	r2, #255	; 0xff
 8001fbc:	2101      	movs	r1, #1
 8001fbe:	4808      	ldr	r0, [pc, #32]	; (8001fe0 <LedControl_BlinkStart+0x74>)
 8001fc0:	f000 f9aa 	bl	8002318 <TimerStart>
 8001fc4:	4603      	mov	r3, r0
 8001fc6:	461a      	mov	r2, r3
 8001fc8:	4b06      	ldr	r3, [pc, #24]	; (8001fe4 <LedControl_BlinkStart+0x78>)
 8001fca:	701a      	strb	r2, [r3, #0]
 8001fcc:	e000      	b.n	8001fd0 <LedControl_BlinkStart+0x64>
		return;
 8001fce:	bf00      	nop
}
 8001fd0:	370c      	adds	r7, #12
 8001fd2:	46bd      	mov	sp, r7
 8001fd4:	bd90      	pop	{r4, r7, pc}
 8001fd6:	bf00      	nop
 8001fd8:	200001d0 	.word	0x200001d0
 8001fdc:	08001e45 	.word	0x08001e45
 8001fe0:	0800690c 	.word	0x0800690c
 8001fe4:	20000074 	.word	0x20000074

08001fe8 <LedControl_SetAllColor>:
 */
void
LedControl_SetAllColor(
	uint8_t led_color,
	uint8_t led_level
) {
 8001fe8:	b580      	push	{r7, lr}
 8001fea:	b084      	sub	sp, #16
 8001fec:	af00      	add	r7, sp, #0
 8001fee:	4603      	mov	r3, r0
 8001ff0:	460a      	mov	r2, r1
 8001ff2:	71fb      	strb	r3, [r7, #7]
 8001ff4:	4613      	mov	r3, r2
 8001ff6:	71bb      	strb	r3, [r7, #6]
    for (uint8_t i = 0; i < NUM_OF_LED; i++) {
 8001ff8:	2300      	movs	r3, #0
 8001ffa:	73fb      	strb	r3, [r7, #15]
 8001ffc:	e008      	b.n	8002010 <LedControl_SetAllColor+0x28>
    	LedControl_SetColorGeneral(i, led_color, led_level);
 8001ffe:	79ba      	ldrb	r2, [r7, #6]
 8002000:	79f9      	ldrb	r1, [r7, #7]
 8002002:	7bfb      	ldrb	r3, [r7, #15]
 8002004:	4618      	mov	r0, r3
 8002006:	f7ff fe33 	bl	8001c70 <LedControl_SetColorGeneral>
    for (uint8_t i = 0; i < NUM_OF_LED; i++) {
 800200a:	7bfb      	ldrb	r3, [r7, #15]
 800200c:	3301      	adds	r3, #1
 800200e:	73fb      	strb	r3, [r7, #15]
 8002010:	7bfb      	ldrb	r3, [r7, #15]
 8002012:	2b02      	cmp	r3, #2
 8002014:	d9f3      	bls.n	8001ffe <LedControl_SetAllColor+0x16>
    }
}
 8002016:	bf00      	nop
 8002018:	bf00      	nop
 800201a:	3710      	adds	r7, #16
 800201c:	46bd      	mov	sp, r7
 800201e:	bd80      	pop	{r7, pc}

08002020 <LEDGPIO_Config>:
  * @brief  Configure GPIO for led
  * @param  None
  * @retval None
  */
static void LEDGPIO_Config(void)
{
 8002020:	b580      	push	{r7, lr}
 8002022:	b082      	sub	sp, #8
 8002024:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOA, GPIOB Clocks enable */
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB, ENABLE);
 8002026:	2101      	movs	r1, #1
 8002028:	2003      	movs	r0, #3
 800202a:	f7fe fc09 	bl	8000840 <RCC_AHB1PeriphClockCmd>

	/* GPIOA Configuration: Channel 0, 1, 3, 10 and 11 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = LED1_GREEN_PIN | LED1_BLUE_PIN | LED2_RED_PIN | LED2_GREEN_PIN;
 800202e:	f640 4303 	movw	r3, #3075	; 0xc03
 8002032:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002034:	2302      	movs	r3, #2
 8002036:	713b      	strb	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 8002038:	2303      	movs	r3, #3
 800203a:	717b      	strb	r3, [r7, #5]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800203c:	2300      	movs	r3, #0
 800203e:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 8002040:	2301      	movs	r3, #1
 8002042:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002044:	463b      	mov	r3, r7
 8002046:	4619      	mov	r1, r3
 8002048:	4818      	ldr	r0, [pc, #96]	; (80020ac <LEDGPIO_Config+0x8c>)
 800204a:	f7fe fa23 	bl	8000494 <GPIO_Init>

	GPIO_PinAFConfig(GPIOA, GPIO_PinSource0, GPIO_AF_TIM2);
 800204e:	2201      	movs	r2, #1
 8002050:	2100      	movs	r1, #0
 8002052:	4816      	ldr	r0, [pc, #88]	; (80020ac <LEDGPIO_Config+0x8c>)
 8002054:	f7fe fafd 	bl	8000652 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource1, GPIO_AF_TIM2);
 8002058:	2201      	movs	r2, #1
 800205a:	2101      	movs	r1, #1
 800205c:	4813      	ldr	r0, [pc, #76]	; (80020ac <LEDGPIO_Config+0x8c>)
 800205e:	f7fe faf8 	bl	8000652 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_TIM1);
 8002062:	2201      	movs	r2, #1
 8002064:	210b      	movs	r1, #11
 8002066:	4811      	ldr	r0, [pc, #68]	; (80020ac <LEDGPIO_Config+0x8c>)
 8002068:	f7fe faf3 	bl	8000652 <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource10, GPIO_AF_TIM1);
 800206c:	2201      	movs	r2, #1
 800206e:	210a      	movs	r1, #10
 8002070:	480e      	ldr	r0, [pc, #56]	; (80020ac <LEDGPIO_Config+0x8c>)
 8002072:	f7fe faee 	bl	8000652 <GPIO_PinAFConfig>

	/* GPIOB Configuration: Channel 13 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = LED1_RED_PIN;
 8002076:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800207a:	603b      	str	r3, [r7, #0]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800207c:	463b      	mov	r3, r7
 800207e:	4619      	mov	r1, r3
 8002080:	480b      	ldr	r0, [pc, #44]	; (80020b0 <LEDGPIO_Config+0x90>)
 8002082:	f7fe fa07 	bl	8000494 <GPIO_Init>

	GPIO_PinAFConfig(GPIOB, GPIO_PinSource13, GPIO_AF_TIM1);
 8002086:	2201      	movs	r2, #1
 8002088:	210d      	movs	r1, #13
 800208a:	4809      	ldr	r0, [pc, #36]	; (80020b0 <LEDGPIO_Config+0x90>)
 800208c:	f7fe fae1 	bl	8000652 <GPIO_PinAFConfig>

	/* GPIOA Configuration: Board STM32 */
	GPIO_InitStructure.GPIO_Pin = LED_BOARD_PIN;
 8002090:	2320      	movs	r3, #32
 8002092:	603b      	str	r3, [r7, #0]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002094:	2301      	movs	r3, #1
 8002096:	713b      	strb	r3, [r7, #4]
	GPIO_Init(LED_BOARD_PORT, &GPIO_InitStructure);
 8002098:	463b      	mov	r3, r7
 800209a:	4619      	mov	r1, r3
 800209c:	4803      	ldr	r0, [pc, #12]	; (80020ac <LEDGPIO_Config+0x8c>)
 800209e:	f7fe f9f9 	bl	8000494 <GPIO_Init>
}
 80020a2:	bf00      	nop
 80020a4:	3708      	adds	r7, #8
 80020a6:	46bd      	mov	sp, r7
 80020a8:	bd80      	pop	{r7, pc}
 80020aa:	bf00      	nop
 80020ac:	40020000 	.word	0x40020000
 80020b0:	40020400 	.word	0x40020400

080020b4 <LEDTIM_Config>:
  * @brief  Configure the TIM1 and TIM2 Pins.
  * @param  None
  * @retval None
  */
static void LEDTIM_Config(void)
{
 80020b4:	b580      	push	{r7, lr}
 80020b6:	b08a      	sub	sp, #40	; 0x28
 80020b8:	af00      	add	r7, sp, #0
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	TIM_OCInitTypeDef  TIM_OCInitStructure;
	uint16_t ChannelPulse = 0;
 80020ba:	2300      	movs	r3, #0
 80020bc:	84fb      	strh	r3, [r7, #38]	; 0x26

	/* Compute CCR1 value to generate a duty cycle at 50% for channel 1 and 1N */
	ChannelPulse = (uint16_t) (((uint32_t) 0 * (LED_TIMER_PERIOD - 1)) / 100);
 80020be:	2300      	movs	r3, #0
 80020c0:	84fb      	strh	r3, [r7, #38]	; 0x26

	/* TIM1 and TIM2 clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
 80020c2:	2101      	movs	r1, #1
 80020c4:	2001      	movs	r0, #1
 80020c6:	f7fe fbfb 	bl	80008c0 <RCC_APB2PeriphClockCmd>
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
 80020ca:	2101      	movs	r1, #1
 80020cc:	2001      	movs	r0, #1
 80020ce:	f7fe fbd7 	bl	8000880 <RCC_APB1PeriphClockCmd>

	/* Time Base configuration */
	TIM_TimeBaseStructure.TIM_Prescaler = 0;
 80020d2:	2300      	movs	r3, #0
 80020d4:	833b      	strh	r3, [r7, #24]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80020d6:	2300      	movs	r3, #0
 80020d8:	837b      	strh	r3, [r7, #26]
	TIM_TimeBaseStructure.TIM_Period = LED_TIMER_PERIOD;
 80020da:	4b2e      	ldr	r3, [pc, #184]	; (8002194 <LEDTIM_Config+0xe0>)
 80020dc:	681b      	ldr	r3, [r3, #0]
 80020de:	4a2e      	ldr	r2, [pc, #184]	; (8002198 <LEDTIM_Config+0xe4>)
 80020e0:	fba2 2303 	umull	r2, r3, r2, r3
 80020e4:	0b9b      	lsrs	r3, r3, #14
 80020e6:	3b01      	subs	r3, #1
 80020e8:	61fb      	str	r3, [r7, #28]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80020ea:	2300      	movs	r3, #0
 80020ec:	843b      	strh	r3, [r7, #32]
	TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
 80020ee:	2300      	movs	r3, #0
 80020f0:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
 80020f4:	f107 0318 	add.w	r3, r7, #24
 80020f8:	4619      	mov	r1, r3
 80020fa:	4828      	ldr	r0, [pc, #160]	; (800219c <LEDTIM_Config+0xe8>)
 80020fc:	f7fe fc00 	bl	8000900 <TIM_TimeBaseInit>
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 8002100:	f107 0318 	add.w	r3, r7, #24
 8002104:	4619      	mov	r1, r3
 8002106:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800210a:	f7fe fbf9 	bl	8000900 <TIM_TimeBaseInit>

	/* Channel 1, 2, 3 and 4 Configuration in PWM mode */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
 800210e:	2370      	movs	r3, #112	; 0x70
 8002110:	80bb      	strh	r3, [r7, #4]
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002112:	2301      	movs	r3, #1
 8002114:	80fb      	strh	r3, [r7, #6]
	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
 8002116:	2304      	movs	r3, #4
 8002118:	813b      	strh	r3, [r7, #8]
	TIM_OCInitStructure.TIM_Pulse = ChannelPulse;
 800211a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800211c:	60fb      	str	r3, [r7, #12]
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
 800211e:	2302      	movs	r3, #2
 8002120:	823b      	strh	r3, [r7, #16]
	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
 8002122:	2300      	movs	r3, #0
 8002124:	827b      	strh	r3, [r7, #18]
	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
 8002126:	f44f 7380 	mov.w	r3, #256	; 0x100
 800212a:	82bb      	strh	r3, [r7, #20]
	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;
 800212c:	2300      	movs	r3, #0
 800212e:	82fb      	strh	r3, [r7, #22]

	TIM_OC1Init(TIM1, &TIM_OCInitStructure);
 8002130:	1d3b      	adds	r3, r7, #4
 8002132:	4619      	mov	r1, r3
 8002134:	4819      	ldr	r0, [pc, #100]	; (800219c <LEDTIM_Config+0xe8>)
 8002136:	f7fe fc6f 	bl	8000a18 <TIM_OC1Init>
	TIM_OC3Init(TIM1, &TIM_OCInitStructure);
 800213a:	1d3b      	adds	r3, r7, #4
 800213c:	4619      	mov	r1, r3
 800213e:	4817      	ldr	r0, [pc, #92]	; (800219c <LEDTIM_Config+0xe8>)
 8002140:	f7fe fd6c 	bl	8000c1c <TIM_OC3Init>
	TIM_OC4Init(TIM1, &TIM_OCInitStructure);
 8002144:	1d3b      	adds	r3, r7, #4
 8002146:	4619      	mov	r1, r3
 8002148:	4814      	ldr	r0, [pc, #80]	; (800219c <LEDTIM_Config+0xe8>)
 800214a:	f7fe fded 	bl	8000d28 <TIM_OC4Init>

	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
 800214e:	1d3b      	adds	r3, r7, #4
 8002150:	4619      	mov	r1, r3
 8002152:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002156:	f7fe fc5f 	bl	8000a18 <TIM_OC1Init>
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
 800215a:	1d3b      	adds	r3, r7, #4
 800215c:	4619      	mov	r1, r3
 800215e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002162:	f7fe fcd3 	bl	8000b0c <TIM_OC2Init>

	/* TIM1 and TIM2 counter enable */
	TIM_Cmd(TIM1, ENABLE);
 8002166:	2101      	movs	r1, #1
 8002168:	480c      	ldr	r0, [pc, #48]	; (800219c <LEDTIM_Config+0xe8>)
 800216a:	f7fe fc35 	bl	80009d8 <TIM_Cmd>
	TIM_Cmd(TIM2, ENABLE);
 800216e:	2101      	movs	r1, #1
 8002170:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002174:	f7fe fc30 	bl	80009d8 <TIM_Cmd>

	/* TIM1 and TIM2 Main Output Enable */
	TIM_CtrlPWMOutputs(TIM1, ENABLE);
 8002178:	2101      	movs	r1, #1
 800217a:	4808      	ldr	r0, [pc, #32]	; (800219c <LEDTIM_Config+0xe8>)
 800217c:	f7fe fe74 	bl	8000e68 <TIM_CtrlPWMOutputs>
	TIM_CtrlPWMOutputs(TIM2, ENABLE);
 8002180:	2101      	movs	r1, #1
 8002182:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002186:	f7fe fe6f 	bl	8000e68 <TIM_CtrlPWMOutputs>
}
 800218a:	bf00      	nop
 800218c:	3728      	adds	r7, #40	; 0x28
 800218e:	46bd      	mov	sp, r7
 8002190:	bd80      	pop	{r7, pc}
 8002192:	bf00      	nop
 8002194:	20000000 	.word	0x20000000
 8002198:	eeb83a0d 	.word	0xeeb83a0d
 800219c:	40010000 	.word	0x40010000

080021a0 <EventSchedulerInit>:
 * @retval None
 */
void
EventSchedulerInit(
    app_state_callback func
) {
 80021a0:	b580      	push	{r7, lr}
 80021a2:	b082      	sub	sp, #8
 80021a4:	af00      	add	r7, sp, #0
 80021a6:	6078      	str	r0, [r7, #4]
    if (func != NULL) {
 80021a8:	687b      	ldr	r3, [r7, #4]
 80021aa:	2b00      	cmp	r3, #0
 80021ac:	d009      	beq.n	80021c2 <EventSchedulerInit+0x22>
        pAppStateFunc = func;
 80021ae:	4a07      	ldr	r2, [pc, #28]	; (80021cc <EventSchedulerInit+0x2c>)
 80021b0:	687b      	ldr	r3, [r7, #4]
 80021b2:	6013      	str	r3, [r2, #0]
        bufInit(pBuffEvent, &eventQueue, sizeof(uint8_t), SIZE_EVENT_QUEUE);
 80021b4:	f44f 7380 	mov.w	r3, #256	; 0x100
 80021b8:	2201      	movs	r2, #1
 80021ba:	4905      	ldr	r1, [pc, #20]	; (80021d0 <EventSchedulerInit+0x30>)
 80021bc:	4805      	ldr	r0, [pc, #20]	; (80021d4 <EventSchedulerInit+0x34>)
 80021be:	f003 fa69 	bl	8005694 <bufInit>
    }
}
 80021c2:	bf00      	nop
 80021c4:	3708      	adds	r7, #8
 80021c6:	46bd      	mov	sp, r7
 80021c8:	bd80      	pop	{r7, pc}
 80021ca:	bf00      	nop
 80021cc:	200001e0 	.word	0x200001e0
 80021d0:	200002e4 	.word	0x200002e4
 80021d4:	200001e4 	.word	0x200001e4

080021d8 <EventSchedulerAdd>:
 * @retval None
 */
type_status_t
EventSchedulerAdd(
    const uint8_t pvItemToQueue
) {
 80021d8:	b580      	push	{r7, lr}
 80021da:	b082      	sub	sp, #8
 80021dc:	af00      	add	r7, sp, #0
 80021de:	4603      	mov	r3, r0
 80021e0:	71fb      	strb	r3, [r7, #7]
    if (bufEnDat(&eventQueue, (uint8_t *)&pvItemToQueue) == ERR_OK) {
 80021e2:	1dfb      	adds	r3, r7, #7
 80021e4:	4619      	mov	r1, r3
 80021e6:	4806      	ldr	r0, [pc, #24]	; (8002200 <EventSchedulerAdd+0x28>)
 80021e8:	f003 faba 	bl	8005760 <bufEnDat>
 80021ec:	4603      	mov	r3, r0
 80021ee:	2b00      	cmp	r3, #0
 80021f0:	d101      	bne.n	80021f6 <EventSchedulerAdd+0x1e>
        return SUCCESS1;
 80021f2:	2301      	movs	r3, #1
 80021f4:	e000      	b.n	80021f8 <EventSchedulerAdd+0x20>
    }
    
    return FAIL;
 80021f6:	2300      	movs	r3, #0
}
 80021f8:	4618      	mov	r0, r3
 80021fa:	3708      	adds	r7, #8
 80021fc:	46bd      	mov	sp, r7
 80021fe:	bd80      	pop	{r7, pc}
 8002200:	200002e4 	.word	0x200002e4

08002204 <processEventScheduler>:
 * @brief  Proccess event in queue
 * @param  None
 * @retval None
 */
void
processEventScheduler(void) {
 8002204:	b580      	push	{r7, lr}
 8002206:	b082      	sub	sp, #8
 8002208:	af00      	add	r7, sp, #0
	uint8_t event;
    
    if (pAppStateFunc != NULL) {
 800220a:	4b0a      	ldr	r3, [pc, #40]	; (8002234 <processEventScheduler+0x30>)
 800220c:	681b      	ldr	r3, [r3, #0]
 800220e:	2b00      	cmp	r3, #0
 8002210:	d00c      	beq.n	800222c <processEventScheduler+0x28>
        if (bufDeDat(&eventQueue, (uint8_t *)&event) == ERR_OK) {
 8002212:	1dfb      	adds	r3, r7, #7
 8002214:	4619      	mov	r1, r3
 8002216:	4808      	ldr	r0, [pc, #32]	; (8002238 <processEventScheduler+0x34>)
 8002218:	f003 faf2 	bl	8005800 <bufDeDat>
 800221c:	4603      	mov	r3, r0
 800221e:	2b00      	cmp	r3, #0
 8002220:	d104      	bne.n	800222c <processEventScheduler+0x28>
            pAppStateFunc(event);
 8002222:	4b04      	ldr	r3, [pc, #16]	; (8002234 <processEventScheduler+0x30>)
 8002224:	681b      	ldr	r3, [r3, #0]
 8002226:	79fa      	ldrb	r2, [r7, #7]
 8002228:	4610      	mov	r0, r2
 800222a:	4798      	blx	r3
        }
    }
}
 800222c:	bf00      	nop
 800222e:	3708      	adds	r7, #8
 8002230:	46bd      	mov	sp, r7
 8002232:	bd80      	pop	{r7, pc}
 8002234:	200001e0 	.word	0x200001e0
 8002238:	200002e4 	.word	0x200002e4

0800223c <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800223c:	b480      	push	{r7}
 800223e:	b083      	sub	sp, #12
 8002240:	af00      	add	r7, sp, #0
 8002242:	4603      	mov	r3, r0
 8002244:	6039      	str	r1, [r7, #0]
 8002246:	71fb      	strb	r3, [r7, #7]
  if((int32_t)IRQn < 0) {
 8002248:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800224c:	2b00      	cmp	r3, #0
 800224e:	da0b      	bge.n	8002268 <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002250:	683b      	ldr	r3, [r7, #0]
 8002252:	b2da      	uxtb	r2, r3
 8002254:	490c      	ldr	r1, [pc, #48]	; (8002288 <NVIC_SetPriority+0x4c>)
 8002256:	79fb      	ldrb	r3, [r7, #7]
 8002258:	f003 030f 	and.w	r3, r3, #15
 800225c:	3b04      	subs	r3, #4
 800225e:	0112      	lsls	r2, r2, #4
 8002260:	b2d2      	uxtb	r2, r2
 8002262:	440b      	add	r3, r1
 8002264:	761a      	strb	r2, [r3, #24]
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8002266:	e009      	b.n	800227c <NVIC_SetPriority+0x40>
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002268:	683b      	ldr	r3, [r7, #0]
 800226a:	b2da      	uxtb	r2, r3
 800226c:	4907      	ldr	r1, [pc, #28]	; (800228c <NVIC_SetPriority+0x50>)
 800226e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8002272:	0112      	lsls	r2, r2, #4
 8002274:	b2d2      	uxtb	r2, r2
 8002276:	440b      	add	r3, r1
 8002278:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800227c:	bf00      	nop
 800227e:	370c      	adds	r7, #12
 8002280:	46bd      	mov	sp, r7
 8002282:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002286:	4770      	bx	lr
 8002288:	e000ed00 	.word	0xe000ed00
 800228c:	e000e100 	.word	0xe000e100

08002290 <SysTick_Config>:
    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
    must contain a vendor-specific implementation of this function.

 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8002290:	b580      	push	{r7, lr}
 8002292:	b082      	sub	sp, #8
 8002294:	af00      	add	r7, sp, #0
 8002296:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
 8002298:	687b      	ldr	r3, [r7, #4]
 800229a:	3b01      	subs	r3, #1
 800229c:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80022a0:	d301      	bcc.n	80022a6 <SysTick_Config+0x16>
 80022a2:	2301      	movs	r3, #1
 80022a4:	e00f      	b.n	80022c6 <SysTick_Config+0x36>

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80022a6:	4a0a      	ldr	r2, [pc, #40]	; (80022d0 <SysTick_Config+0x40>)
 80022a8:	687b      	ldr	r3, [r7, #4]
 80022aa:	3b01      	subs	r3, #1
 80022ac:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80022ae:	210f      	movs	r1, #15
 80022b0:	f04f 30ff 	mov.w	r0, #4294967295
 80022b4:	f7ff ffc2 	bl	800223c <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80022b8:	4b05      	ldr	r3, [pc, #20]	; (80022d0 <SysTick_Config+0x40>)
 80022ba:	2200      	movs	r2, #0
 80022bc:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80022be:	4b04      	ldr	r3, [pc, #16]	; (80022d0 <SysTick_Config+0x40>)
 80022c0:	2207      	movs	r2, #7
 80022c2:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80022c4:	2300      	movs	r3, #0
}
 80022c6:	4618      	mov	r0, r3
 80022c8:	3708      	adds	r7, #8
 80022ca:	46bd      	mov	sp, r7
 80022cc:	bd80      	pop	{r7, pc}
 80022ce:	bf00      	nop
 80022d0:	e000e010 	.word	0xe000e010

080022d4 <TimerInit>:
 * @brief  None
 * @param  None
 * @retval None
 */
void
TimerInit(void) {
 80022d4:	b580      	push	{r7, lr}
 80022d6:	b084      	sub	sp, #16
 80022d8:	af00      	add	r7, sp, #0
    RCC_ClocksTypeDef RCC_Clocks;

    RCC_GetClocksFreq(&RCC_Clocks);
 80022da:	463b      	mov	r3, r7
 80022dc:	4618      	mov	r0, r3
 80022de:	f7fe fa01 	bl	80006e4 <RCC_GetClocksFreq>
    SysTick_Config(RCC_Clocks.SYSCLK_Frequency/1000);
 80022e2:	683b      	ldr	r3, [r7, #0]
 80022e4:	4a0a      	ldr	r2, [pc, #40]	; (8002310 <TimerInit+0x3c>)
 80022e6:	fba2 2303 	umull	r2, r3, r2, r3
 80022ea:	099b      	lsrs	r3, r3, #6
 80022ec:	4618      	mov	r0, r3
 80022ee:	f7ff ffcf 	bl	8002290 <SysTick_Config>
    NVIC_SetPriority(SysTick_IRQn, 1);
 80022f2:	2101      	movs	r1, #1
 80022f4:	f04f 30ff 	mov.w	r0, #4294967295
 80022f8:	f7ff ffa0 	bl	800223c <NVIC_SetPriority>
    memsetl((uint8_t *)g_pTimerHandle, 0, sizeof(g_pTimerHandle));
 80022fc:	f44f 72c0 	mov.w	r2, #384	; 0x180
 8002300:	2100      	movs	r1, #0
 8002302:	4804      	ldr	r0, [pc, #16]	; (8002314 <TimerInit+0x40>)
 8002304:	f003 fac1 	bl	800588a <memsetl>
    DBG_TIMER_SEND_STR("$ TimerInit\n");
}
 8002308:	bf00      	nop
 800230a:	3710      	adds	r7, #16
 800230c:	46bd      	mov	sp, r7
 800230e:	bd80      	pop	{r7, pc}
 8002310:	10624dd3 	.word	0x10624dd3
 8002314:	200002f4 	.word	0x200002f4

08002318 <TimerStart>:
    char* name,
	uint32_t wMilSecTick,
	uint8_t byRepeats,
	void (*callback)(void *),
    void *pcallbackData
) {   
 8002318:	b590      	push	{r4, r7, lr}
 800231a:	b087      	sub	sp, #28
 800231c:	af00      	add	r7, sp, #0
 800231e:	60f8      	str	r0, [r7, #12]
 8002320:	60b9      	str	r1, [r7, #8]
 8002322:	603b      	str	r3, [r7, #0]
 8002324:	4613      	mov	r3, r2
 8002326:	71fb      	strb	r3, [r7, #7]
    for (uint8_t i = 0; i < MAX_TIMER; i++)
 8002328:	2300      	movs	r3, #0
 800232a:	75fb      	strb	r3, [r7, #23]
 800232c:	e04c      	b.n	80023c8 <TimerStart+0xb0>
    {
        if (g_pTimerHandle[i].callbackFunc == NULL)
 800232e:	7dfa      	ldrb	r2, [r7, #23]
 8002330:	4929      	ldr	r1, [pc, #164]	; (80023d8 <TimerStart+0xc0>)
 8002332:	4613      	mov	r3, r2
 8002334:	005b      	lsls	r3, r3, #1
 8002336:	4413      	add	r3, r2
 8002338:	00db      	lsls	r3, r3, #3
 800233a:	440b      	add	r3, r1
 800233c:	3310      	adds	r3, #16
 800233e:	681b      	ldr	r3, [r3, #0]
 8002340:	2b00      	cmp	r3, #0
 8002342:	d13e      	bne.n	80023c2 <TimerStart+0xaa>
        {
            g_pTimerHandle[i].name = name;
 8002344:	7dfa      	ldrb	r2, [r7, #23]
 8002346:	4924      	ldr	r1, [pc, #144]	; (80023d8 <TimerStart+0xc0>)
 8002348:	4613      	mov	r3, r2
 800234a:	005b      	lsls	r3, r3, #1
 800234c:	4413      	add	r3, r2
 800234e:	00db      	lsls	r3, r3, #3
 8002350:	440b      	add	r3, r1
 8002352:	68fa      	ldr	r2, [r7, #12]
 8002354:	601a      	str	r2, [r3, #0]
            g_pTimerHandle[i].callbackFunc = callback;
 8002356:	7dfa      	ldrb	r2, [r7, #23]
 8002358:	491f      	ldr	r1, [pc, #124]	; (80023d8 <TimerStart+0xc0>)
 800235a:	4613      	mov	r3, r2
 800235c:	005b      	lsls	r3, r3, #1
 800235e:	4413      	add	r3, r2
 8002360:	00db      	lsls	r3, r3, #3
 8002362:	440b      	add	r3, r1
 8002364:	3310      	adds	r3, #16
 8002366:	683a      	ldr	r2, [r7, #0]
 8002368:	601a      	str	r2, [r3, #0]
            g_pTimerHandle[i].repeats = byRepeats;
 800236a:	7dfa      	ldrb	r2, [r7, #23]
 800236c:	491a      	ldr	r1, [pc, #104]	; (80023d8 <TimerStart+0xc0>)
 800236e:	4613      	mov	r3, r2
 8002370:	005b      	lsls	r3, r3, #1
 8002372:	4413      	add	r3, r2
 8002374:	00db      	lsls	r3, r3, #3
 8002376:	440b      	add	r3, r1
 8002378:	330c      	adds	r3, #12
 800237a:	79fa      	ldrb	r2, [r7, #7]
 800237c:	701a      	strb	r2, [r3, #0]
            g_pTimerHandle[i].pCallbackData = pcallbackData;
 800237e:	7dfa      	ldrb	r2, [r7, #23]
 8002380:	4915      	ldr	r1, [pc, #84]	; (80023d8 <TimerStart+0xc0>)
 8002382:	4613      	mov	r3, r2
 8002384:	005b      	lsls	r3, r3, #1
 8002386:	4413      	add	r3, r2
 8002388:	00db      	lsls	r3, r3, #3
 800238a:	440b      	add	r3, r1
 800238c:	3314      	adds	r3, #20
 800238e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8002390:	601a      	str	r2, [r3, #0]
            g_pTimerHandle[i].milSecStart = GetMilSecTick();
 8002392:	7dfc      	ldrb	r4, [r7, #23]
 8002394:	f000 f88e 	bl	80024b4 <GetMilSecTick>
 8002398:	4602      	mov	r2, r0
 800239a:	490f      	ldr	r1, [pc, #60]	; (80023d8 <TimerStart+0xc0>)
 800239c:	4623      	mov	r3, r4
 800239e:	005b      	lsls	r3, r3, #1
 80023a0:	4423      	add	r3, r4
 80023a2:	00db      	lsls	r3, r3, #3
 80023a4:	440b      	add	r3, r1
 80023a6:	3304      	adds	r3, #4
 80023a8:	601a      	str	r2, [r3, #0]
            g_pTimerHandle[i].milSecTimeout = wMilSecTick;
 80023aa:	7dfa      	ldrb	r2, [r7, #23]
 80023ac:	490a      	ldr	r1, [pc, #40]	; (80023d8 <TimerStart+0xc0>)
 80023ae:	4613      	mov	r3, r2
 80023b0:	005b      	lsls	r3, r3, #1
 80023b2:	4413      	add	r3, r2
 80023b4:	00db      	lsls	r3, r3, #3
 80023b6:	440b      	add	r3, r1
 80023b8:	3308      	adds	r3, #8
 80023ba:	68ba      	ldr	r2, [r7, #8]
 80023bc:	601a      	str	r2, [r3, #0]
            DBG_TIMER_SEND_NUM(g_pTimerHandle[i].repeats);
            DBG_TIMER_SEND_STR(", timeCall = ");
            DBG_TIMER_SEND_NUM(wMilSecTick);
            DBG_TIMER_SEND_STR("\n");

            return i;
 80023be:	7dfb      	ldrb	r3, [r7, #23]
 80023c0:	e006      	b.n	80023d0 <TimerStart+0xb8>
    for (uint8_t i = 0; i < MAX_TIMER; i++)
 80023c2:	7dfb      	ldrb	r3, [r7, #23]
 80023c4:	3301      	adds	r3, #1
 80023c6:	75fb      	strb	r3, [r7, #23]
 80023c8:	7dfb      	ldrb	r3, [r7, #23]
 80023ca:	2b0f      	cmp	r3, #15
 80023cc:	d9af      	bls.n	800232e <TimerStart+0x16>
        }
    }
    
    return NO_TIMER;
 80023ce:	23ff      	movs	r3, #255	; 0xff
}
 80023d0:	4618      	mov	r0, r3
 80023d2:	371c      	adds	r7, #28
 80023d4:	46bd      	mov	sp, r7
 80023d6:	bd90      	pop	{r4, r7, pc}
 80023d8:	200002f4 	.word	0x200002f4

080023dc <TimerChangePeriod>:
 */
void
TimerChangePeriod(
    uint8_t byTimerId,
    uint32_t dwMilSecTick
) {
 80023dc:	b480      	push	{r7}
 80023de:	b083      	sub	sp, #12
 80023e0:	af00      	add	r7, sp, #0
 80023e2:	4603      	mov	r3, r0
 80023e4:	6039      	str	r1, [r7, #0]
 80023e6:	71fb      	strb	r3, [r7, #7]
    if (byTimerId == NO_TIMER) return; 
 80023e8:	79fb      	ldrb	r3, [r7, #7]
 80023ea:	2bff      	cmp	r3, #255	; 0xff
 80023ec:	d00a      	beq.n	8002404 <TimerChangePeriod+0x28>
    g_pTimerHandle[byTimerId].milSecTimeout = dwMilSecTick;
 80023ee:	79fa      	ldrb	r2, [r7, #7]
 80023f0:	4907      	ldr	r1, [pc, #28]	; (8002410 <TimerChangePeriod+0x34>)
 80023f2:	4613      	mov	r3, r2
 80023f4:	005b      	lsls	r3, r3, #1
 80023f6:	4413      	add	r3, r2
 80023f8:	00db      	lsls	r3, r3, #3
 80023fa:	440b      	add	r3, r1
 80023fc:	3308      	adds	r3, #8
 80023fe:	683a      	ldr	r2, [r7, #0]
 8002400:	601a      	str	r2, [r3, #0]
 8002402:	e000      	b.n	8002406 <TimerChangePeriod+0x2a>
    if (byTimerId == NO_TIMER) return; 
 8002404:	bf00      	nop
}
 8002406:	370c      	adds	r7, #12
 8002408:	46bd      	mov	sp, r7
 800240a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800240e:	4770      	bx	lr
 8002410:	200002f4 	.word	0x200002f4

08002414 <TimerStop>:
 * @retval None
 */
uint8_t
TimerStop(
    uint8_t byTimerId
) {   
 8002414:	b480      	push	{r7}
 8002416:	b083      	sub	sp, #12
 8002418:	af00      	add	r7, sp, #0
 800241a:	4603      	mov	r3, r0
 800241c:	71fb      	strb	r3, [r7, #7]
    if ((byTimerId >= MAX_TIMER) || (g_pTimerHandle[byTimerId].callbackFunc == NULL))
 800241e:	79fb      	ldrb	r3, [r7, #7]
 8002420:	2b0f      	cmp	r3, #15
 8002422:	d80a      	bhi.n	800243a <TimerStop+0x26>
 8002424:	79fa      	ldrb	r2, [r7, #7]
 8002426:	4922      	ldr	r1, [pc, #136]	; (80024b0 <TimerStop+0x9c>)
 8002428:	4613      	mov	r3, r2
 800242a:	005b      	lsls	r3, r3, #1
 800242c:	4413      	add	r3, r2
 800242e:	00db      	lsls	r3, r3, #3
 8002430:	440b      	add	r3, r1
 8002432:	3310      	adds	r3, #16
 8002434:	681b      	ldr	r3, [r3, #0]
 8002436:	2b00      	cmp	r3, #0
 8002438:	d101      	bne.n	800243e <TimerStop+0x2a>
        return 0;
 800243a:	2300      	movs	r3, #0
 800243c:	e031      	b.n	80024a2 <TimerStop+0x8e>
    DBG_TIMER_SEND_STR(g_pTimerHandle[byTimerId].name);
    DBG_TIMER_SEND_STR(" Id = "); 
    DBG_TIMER_SEND_NUM(byTimerId);
    DBG_TIMER_SEND_STR("\n");
    
    g_pTimerHandle[byTimerId].name = NULL;
 800243e:	79fa      	ldrb	r2, [r7, #7]
 8002440:	491b      	ldr	r1, [pc, #108]	; (80024b0 <TimerStop+0x9c>)
 8002442:	4613      	mov	r3, r2
 8002444:	005b      	lsls	r3, r3, #1
 8002446:	4413      	add	r3, r2
 8002448:	00db      	lsls	r3, r3, #3
 800244a:	440b      	add	r3, r1
 800244c:	2200      	movs	r2, #0
 800244e:	601a      	str	r2, [r3, #0]
    g_pTimerHandle[byTimerId].callbackFunc = NULL;
 8002450:	79fa      	ldrb	r2, [r7, #7]
 8002452:	4917      	ldr	r1, [pc, #92]	; (80024b0 <TimerStop+0x9c>)
 8002454:	4613      	mov	r3, r2
 8002456:	005b      	lsls	r3, r3, #1
 8002458:	4413      	add	r3, r2
 800245a:	00db      	lsls	r3, r3, #3
 800245c:	440b      	add	r3, r1
 800245e:	3310      	adds	r3, #16
 8002460:	2200      	movs	r2, #0
 8002462:	601a      	str	r2, [r3, #0]
    g_pTimerHandle[byTimerId].repeats = 0;
 8002464:	79fa      	ldrb	r2, [r7, #7]
 8002466:	4912      	ldr	r1, [pc, #72]	; (80024b0 <TimerStop+0x9c>)
 8002468:	4613      	mov	r3, r2
 800246a:	005b      	lsls	r3, r3, #1
 800246c:	4413      	add	r3, r2
 800246e:	00db      	lsls	r3, r3, #3
 8002470:	440b      	add	r3, r1
 8002472:	330c      	adds	r3, #12
 8002474:	2200      	movs	r2, #0
 8002476:	701a      	strb	r2, [r3, #0]
    g_pTimerHandle[byTimerId].milSecTimeout = 0;
 8002478:	79fa      	ldrb	r2, [r7, #7]
 800247a:	490d      	ldr	r1, [pc, #52]	; (80024b0 <TimerStop+0x9c>)
 800247c:	4613      	mov	r3, r2
 800247e:	005b      	lsls	r3, r3, #1
 8002480:	4413      	add	r3, r2
 8002482:	00db      	lsls	r3, r3, #3
 8002484:	440b      	add	r3, r1
 8002486:	3308      	adds	r3, #8
 8002488:	2200      	movs	r2, #0
 800248a:	601a      	str	r2, [r3, #0]
    g_pTimerHandle[byTimerId].milSecStart = 0;
 800248c:	79fa      	ldrb	r2, [r7, #7]
 800248e:	4908      	ldr	r1, [pc, #32]	; (80024b0 <TimerStop+0x9c>)
 8002490:	4613      	mov	r3, r2
 8002492:	005b      	lsls	r3, r3, #1
 8002494:	4413      	add	r3, r2
 8002496:	00db      	lsls	r3, r3, #3
 8002498:	440b      	add	r3, r1
 800249a:	3304      	adds	r3, #4
 800249c:	2200      	movs	r2, #0
 800249e:	601a      	str	r2, [r3, #0]
    
    return 1;
 80024a0:	2301      	movs	r3, #1
}
 80024a2:	4618      	mov	r0, r3
 80024a4:	370c      	adds	r7, #12
 80024a6:	46bd      	mov	sp, r7
 80024a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024ac:	4770      	bx	lr
 80024ae:	bf00      	nop
 80024b0:	200002f4 	.word	0x200002f4

080024b4 <GetMilSecTick>:
 * @brief  None
 * @param  None
 * @retval None
 */
uint32_t
GetMilSecTick(void) {
 80024b4:	b480      	push	{r7}
 80024b6:	af00      	add	r7, sp, #0
    return g_wMilSecTickTimer;
 80024b8:	4b03      	ldr	r3, [pc, #12]	; (80024c8 <GetMilSecTick+0x14>)
 80024ba:	681b      	ldr	r3, [r3, #0]
}
 80024bc:	4618      	mov	r0, r3
 80024be:	46bd      	mov	sp, r7
 80024c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80024c4:	4770      	bx	lr
 80024c6:	bf00      	nop
 80024c8:	20000474 	.word	0x20000474

080024cc <processTimerScheduler>:
 * @brief  None
 * @param  None
 * @retval None
 */
void
processTimerScheduler(void) {
 80024cc:	b580      	push	{r7, lr}
 80024ce:	b084      	sub	sp, #16
 80024d0:	af00      	add	r7, sp, #0
    void (*callbackfunc)(void *);
    void *pPrameter;
    
    for (uint8_t i = 0; i < MAX_TIMER; i++)
 80024d2:	2300      	movs	r3, #0
 80024d4:	73fb      	strb	r3, [r7, #15]
 80024d6:	e068      	b.n	80025aa <processTimerScheduler+0xde>
    {
        if ((g_pTimerHandle[i].callbackFunc != NULL) && TimeExpired(i))
 80024d8:	7bfa      	ldrb	r2, [r7, #15]
 80024da:	4938      	ldr	r1, [pc, #224]	; (80025bc <processTimerScheduler+0xf0>)
 80024dc:	4613      	mov	r3, r2
 80024de:	005b      	lsls	r3, r3, #1
 80024e0:	4413      	add	r3, r2
 80024e2:	00db      	lsls	r3, r3, #3
 80024e4:	440b      	add	r3, r1
 80024e6:	3310      	adds	r3, #16
 80024e8:	681b      	ldr	r3, [r3, #0]
 80024ea:	2b00      	cmp	r3, #0
 80024ec:	d05a      	beq.n	80025a4 <processTimerScheduler+0xd8>
 80024ee:	7bfb      	ldrb	r3, [r7, #15]
 80024f0:	4618      	mov	r0, r3
 80024f2:	f000 f865 	bl	80025c0 <TimeExpired>
 80024f6:	4603      	mov	r3, r0
 80024f8:	2b00      	cmp	r3, #0
 80024fa:	d053      	beq.n	80025a4 <processTimerScheduler+0xd8>
        {
            callbackfunc = g_pTimerHandle[i].callbackFunc;
 80024fc:	7bfa      	ldrb	r2, [r7, #15]
 80024fe:	492f      	ldr	r1, [pc, #188]	; (80025bc <processTimerScheduler+0xf0>)
 8002500:	4613      	mov	r3, r2
 8002502:	005b      	lsls	r3, r3, #1
 8002504:	4413      	add	r3, r2
 8002506:	00db      	lsls	r3, r3, #3
 8002508:	440b      	add	r3, r1
 800250a:	3310      	adds	r3, #16
 800250c:	681b      	ldr	r3, [r3, #0]
 800250e:	60bb      	str	r3, [r7, #8]
            pPrameter = g_pTimerHandle[i].pCallbackData;
 8002510:	7bfa      	ldrb	r2, [r7, #15]
 8002512:	492a      	ldr	r1, [pc, #168]	; (80025bc <processTimerScheduler+0xf0>)
 8002514:	4613      	mov	r3, r2
 8002516:	005b      	lsls	r3, r3, #1
 8002518:	4413      	add	r3, r2
 800251a:	00db      	lsls	r3, r3, #3
 800251c:	440b      	add	r3, r1
 800251e:	3314      	adds	r3, #20
 8002520:	681b      	ldr	r3, [r3, #0]
 8002522:	607b      	str	r3, [r7, #4]
            DBG_TIMER_SEND_NUM(g_pTimerHandle[i].repeats);
            DBG_TIMER_SEND_STR(", CB = ");
            DBG_TIMER_SEND_NUM((uint32_t)callbackfunc);
            DBG_TIMER_SEND_STR("\n");
            
            if ((g_pTimerHandle[i].repeats != TIMER_REPEAT_FOREVER) && \
 8002524:	7bfa      	ldrb	r2, [r7, #15]
 8002526:	4925      	ldr	r1, [pc, #148]	; (80025bc <processTimerScheduler+0xf0>)
 8002528:	4613      	mov	r3, r2
 800252a:	005b      	lsls	r3, r3, #1
 800252c:	4413      	add	r3, r2
 800252e:	00db      	lsls	r3, r3, #3
 8002530:	440b      	add	r3, r1
 8002532:	330c      	adds	r3, #12
 8002534:	781b      	ldrb	r3, [r3, #0]
 8002536:	b2db      	uxtb	r3, r3
 8002538:	2bff      	cmp	r3, #255	; 0xff
 800253a:	d020      	beq.n	800257e <processTimerScheduler+0xb2>
                (g_pTimerHandle[i].repeats != TIMER_REPEAT_ONE_TIME))
 800253c:	7bfa      	ldrb	r2, [r7, #15]
 800253e:	491f      	ldr	r1, [pc, #124]	; (80025bc <processTimerScheduler+0xf0>)
 8002540:	4613      	mov	r3, r2
 8002542:	005b      	lsls	r3, r3, #1
 8002544:	4413      	add	r3, r2
 8002546:	00db      	lsls	r3, r3, #3
 8002548:	440b      	add	r3, r1
 800254a:	330c      	adds	r3, #12
 800254c:	781b      	ldrb	r3, [r3, #0]
 800254e:	b2db      	uxtb	r3, r3
            if ((g_pTimerHandle[i].repeats != TIMER_REPEAT_FOREVER) && \
 8002550:	2b00      	cmp	r3, #0
 8002552:	d014      	beq.n	800257e <processTimerScheduler+0xb2>
                 g_pTimerHandle[i].repeats--;
 8002554:	7bfa      	ldrb	r2, [r7, #15]
 8002556:	4919      	ldr	r1, [pc, #100]	; (80025bc <processTimerScheduler+0xf0>)
 8002558:	4613      	mov	r3, r2
 800255a:	005b      	lsls	r3, r3, #1
 800255c:	4413      	add	r3, r2
 800255e:	00db      	lsls	r3, r3, #3
 8002560:	440b      	add	r3, r1
 8002562:	330c      	adds	r3, #12
 8002564:	781b      	ldrb	r3, [r3, #0]
 8002566:	b2db      	uxtb	r3, r3
 8002568:	3b01      	subs	r3, #1
 800256a:	b2d8      	uxtb	r0, r3
 800256c:	4913      	ldr	r1, [pc, #76]	; (80025bc <processTimerScheduler+0xf0>)
 800256e:	4613      	mov	r3, r2
 8002570:	005b      	lsls	r3, r3, #1
 8002572:	4413      	add	r3, r2
 8002574:	00db      	lsls	r3, r3, #3
 8002576:	440b      	add	r3, r1
 8002578:	330c      	adds	r3, #12
 800257a:	4602      	mov	r2, r0
 800257c:	701a      	strb	r2, [r3, #0]
            
            if (g_pTimerHandle[i].repeats == TIMER_REPEAT_ONE_TIME) {
 800257e:	7bfa      	ldrb	r2, [r7, #15]
 8002580:	490e      	ldr	r1, [pc, #56]	; (80025bc <processTimerScheduler+0xf0>)
 8002582:	4613      	mov	r3, r2
 8002584:	005b      	lsls	r3, r3, #1
 8002586:	4413      	add	r3, r2
 8002588:	00db      	lsls	r3, r3, #3
 800258a:	440b      	add	r3, r1
 800258c:	330c      	adds	r3, #12
 800258e:	781b      	ldrb	r3, [r3, #0]
 8002590:	b2db      	uxtb	r3, r3
 8002592:	2b00      	cmp	r3, #0
 8002594:	d103      	bne.n	800259e <processTimerScheduler+0xd2>
                 DBG_TIMER_SEND_STR("$ CANCEL \n");
                 TimerStop(i);
 8002596:	7bfb      	ldrb	r3, [r7, #15]
 8002598:	4618      	mov	r0, r3
 800259a:	f7ff ff3b 	bl	8002414 <TimerStop>
            }
            
            callbackfunc(pPrameter);
 800259e:	68bb      	ldr	r3, [r7, #8]
 80025a0:	6878      	ldr	r0, [r7, #4]
 80025a2:	4798      	blx	r3
    for (uint8_t i = 0; i < MAX_TIMER; i++)
 80025a4:	7bfb      	ldrb	r3, [r7, #15]
 80025a6:	3301      	adds	r3, #1
 80025a8:	73fb      	strb	r3, [r7, #15]
 80025aa:	7bfb      	ldrb	r3, [r7, #15]
 80025ac:	2b0f      	cmp	r3, #15
 80025ae:	d993      	bls.n	80024d8 <processTimerScheduler+0xc>
        }
    }
}
 80025b0:	bf00      	nop
 80025b2:	bf00      	nop
 80025b4:	3710      	adds	r7, #16
 80025b6:	46bd      	mov	sp, r7
 80025b8:	bd80      	pop	{r7, pc}
 80025ba:	bf00      	nop
 80025bc:	200002f4 	.word	0x200002f4

080025c0 <TimeExpired>:
 * @retval TRUE or FALSE
 */
uint8_t
TimeExpired(
    uint8_t byTimerId
) {
 80025c0:	b580      	push	{r7, lr}
 80025c2:	b084      	sub	sp, #16
 80025c4:	af00      	add	r7, sp, #0
 80025c6:	4603      	mov	r3, r0
 80025c8:	71fb      	strb	r3, [r7, #7]
    uint32_t wMilSecTick;
    uint32_t wDeltaMilSec = 0;
 80025ca:	2300      	movs	r3, #0
 80025cc:	60fb      	str	r3, [r7, #12]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80025ce:	b672      	cpsid	i
}
 80025d0:	bf00      	nop
    
    __disable_irq();
    wMilSecTick = GetMilSecTick();
 80025d2:	f7ff ff6f 	bl	80024b4 <GetMilSecTick>
 80025d6:	60b8      	str	r0, [r7, #8]
    if ((byTimerId >= MAX_TIMER) || (g_pTimerHandle[byTimerId].callbackFunc == NULL))
 80025d8:	79fb      	ldrb	r3, [r7, #7]
 80025da:	2b0f      	cmp	r3, #15
 80025dc:	d80a      	bhi.n	80025f4 <TimeExpired+0x34>
 80025de:	79fa      	ldrb	r2, [r7, #7]
 80025e0:	492b      	ldr	r1, [pc, #172]	; (8002690 <TimeExpired+0xd0>)
 80025e2:	4613      	mov	r3, r2
 80025e4:	005b      	lsls	r3, r3, #1
 80025e6:	4413      	add	r3, r2
 80025e8:	00db      	lsls	r3, r3, #3
 80025ea:	440b      	add	r3, r1
 80025ec:	3310      	adds	r3, #16
 80025ee:	681b      	ldr	r3, [r3, #0]
 80025f0:	2b00      	cmp	r3, #0
 80025f2:	d103      	bne.n	80025fc <TimeExpired+0x3c>
  __ASM volatile ("cpsie i" : : : "memory");
 80025f4:	b662      	cpsie	i
}
 80025f6:	bf00      	nop
    {
    	__enable_irq();
        return 0;
 80025f8:	2300      	movs	r3, #0
 80025fa:	e044      	b.n	8002686 <TimeExpired+0xc6>
    }
      
    if (wMilSecTick >= g_pTimerHandle[byTimerId].milSecStart) 
 80025fc:	79fa      	ldrb	r2, [r7, #7]
 80025fe:	4924      	ldr	r1, [pc, #144]	; (8002690 <TimeExpired+0xd0>)
 8002600:	4613      	mov	r3, r2
 8002602:	005b      	lsls	r3, r3, #1
 8002604:	4413      	add	r3, r2
 8002606:	00db      	lsls	r3, r3, #3
 8002608:	440b      	add	r3, r1
 800260a:	3304      	adds	r3, #4
 800260c:	681b      	ldr	r3, [r3, #0]
 800260e:	68ba      	ldr	r2, [r7, #8]
 8002610:	429a      	cmp	r2, r3
 8002612:	d30c      	bcc.n	800262e <TimeExpired+0x6e>
    {
        wDeltaMilSec = wMilSecTick - g_pTimerHandle[byTimerId].milSecStart;
 8002614:	79fa      	ldrb	r2, [r7, #7]
 8002616:	491e      	ldr	r1, [pc, #120]	; (8002690 <TimeExpired+0xd0>)
 8002618:	4613      	mov	r3, r2
 800261a:	005b      	lsls	r3, r3, #1
 800261c:	4413      	add	r3, r2
 800261e:	00db      	lsls	r3, r3, #3
 8002620:	440b      	add	r3, r1
 8002622:	3304      	adds	r3, #4
 8002624:	681b      	ldr	r3, [r3, #0]
 8002626:	68ba      	ldr	r2, [r7, #8]
 8002628:	1ad3      	subs	r3, r2, r3
 800262a:	60fb      	str	r3, [r7, #12]
 800262c:	e00e      	b.n	800264c <TimeExpired+0x8c>
    } 
    else
    {
        wDeltaMilSec = g_pTimerHandle[byTimerId].milSecStart - wMilSecTick;
 800262e:	79fa      	ldrb	r2, [r7, #7]
 8002630:	4917      	ldr	r1, [pc, #92]	; (8002690 <TimeExpired+0xd0>)
 8002632:	4613      	mov	r3, r2
 8002634:	005b      	lsls	r3, r3, #1
 8002636:	4413      	add	r3, r2
 8002638:	00db      	lsls	r3, r3, #3
 800263a:	440b      	add	r3, r1
 800263c:	3304      	adds	r3, #4
 800263e:	681a      	ldr	r2, [r3, #0]
 8002640:	68bb      	ldr	r3, [r7, #8]
 8002642:	1ad3      	subs	r3, r2, r3
 8002644:	60fb      	str	r3, [r7, #12]
        wDeltaMilSec = 0xFFFFFFFFU - wDeltaMilSec;
 8002646:	68fb      	ldr	r3, [r7, #12]
 8002648:	43db      	mvns	r3, r3
 800264a:	60fb      	str	r3, [r7, #12]
    }
    
    if (wDeltaMilSec < g_pTimerHandle[byTimerId].milSecTimeout)
 800264c:	79fa      	ldrb	r2, [r7, #7]
 800264e:	4910      	ldr	r1, [pc, #64]	; (8002690 <TimeExpired+0xd0>)
 8002650:	4613      	mov	r3, r2
 8002652:	005b      	lsls	r3, r3, #1
 8002654:	4413      	add	r3, r2
 8002656:	00db      	lsls	r3, r3, #3
 8002658:	440b      	add	r3, r1
 800265a:	3308      	adds	r3, #8
 800265c:	681b      	ldr	r3, [r3, #0]
 800265e:	68fa      	ldr	r2, [r7, #12]
 8002660:	429a      	cmp	r2, r3
 8002662:	d203      	bcs.n	800266c <TimeExpired+0xac>
  __ASM volatile ("cpsie i" : : : "memory");
 8002664:	b662      	cpsie	i
}
 8002666:	bf00      	nop
    {
    	__enable_irq();
        return 0;
 8002668:	2300      	movs	r3, #0
 800266a:	e00c      	b.n	8002686 <TimeExpired+0xc6>
    }
    
    g_pTimerHandle[byTimerId].milSecStart = wMilSecTick;
 800266c:	79fa      	ldrb	r2, [r7, #7]
 800266e:	4908      	ldr	r1, [pc, #32]	; (8002690 <TimeExpired+0xd0>)
 8002670:	4613      	mov	r3, r2
 8002672:	005b      	lsls	r3, r3, #1
 8002674:	4413      	add	r3, r2
 8002676:	00db      	lsls	r3, r3, #3
 8002678:	440b      	add	r3, r1
 800267a:	3304      	adds	r3, #4
 800267c:	68ba      	ldr	r2, [r7, #8]
 800267e:	601a      	str	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 8002680:	b662      	cpsie	i
}
 8002682:	bf00      	nop
    
    __enable_irq();
    
    return 1;
 8002684:	2301      	movs	r3, #1
}
 8002686:	4618      	mov	r0, r3
 8002688:	3710      	adds	r7, #16
 800268a:	46bd      	mov	sp, r7
 800268c:	bd80      	pop	{r7, pc}
 800268e:	bf00      	nop
 8002690:	200002f4 	.word	0x200002f4

08002694 <SysTick_Handler>:
 * @brief  None
 * @param  None
 * @retval None
 */
void
SysTick_Handler(void) {
 8002694:	b480      	push	{r7}
 8002696:	af00      	add	r7, sp, #0
    g_wMilSecTickTimer++;
 8002698:	4b04      	ldr	r3, [pc, #16]	; (80026ac <SysTick_Handler+0x18>)
 800269a:	681b      	ldr	r3, [r3, #0]
 800269c:	3301      	adds	r3, #1
 800269e:	4a03      	ldr	r2, [pc, #12]	; (80026ac <SysTick_Handler+0x18>)
 80026a0:	6013      	str	r3, [r2, #0]
}
 80026a2:	bf00      	nop
 80026a4:	46bd      	mov	sp, r7
 80026a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80026aa:	4770      	bx	lr
 80026ac:	20000474 	.word	0x20000474

080026b0 <USART2_IRQHandler>:
 *   This parameter can be one of the following values:
 *   UART1_IDX, UART2_IDX
 * @retval None
 */
void
USART2_IRQHandler(void) {
 80026b0:	b580      	push	{r7, lr}
 80026b2:	b082      	sub	sp, #8
 80026b4:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 80026b6:	b672      	cpsid	i
}
 80026b8:	bf00      	nop
	__disable_irq();
    if (USART_GetITStatus(USART2, USART_IT_RXNE) == SET) {
 80026ba:	f240 5125 	movw	r1, #1317	; 0x525
 80026be:	480f      	ldr	r0, [pc, #60]	; (80026fc <USART2_IRQHandler+0x4c>)
 80026c0:	f7fe fc08 	bl	8000ed4 <USART_GetITStatus>
 80026c4:	4603      	mov	r3, r0
 80026c6:	2b01      	cmp	r3, #1
 80026c8:	d112      	bne.n	80026f0 <USART2_IRQHandler+0x40>
        buffqueue_p pUartBuffQueueRx = (buffqueue_p) g_pUartQueueRx[0];
 80026ca:	4b0d      	ldr	r3, [pc, #52]	; (8002700 <USART2_IRQHandler+0x50>)
 80026cc:	681b      	ldr	r3, [r3, #0]
 80026ce:	607b      	str	r3, [r7, #4]
        uint8_t byReceiverData = USART_ReceiveData(USART2);
 80026d0:	480a      	ldr	r0, [pc, #40]	; (80026fc <USART2_IRQHandler+0x4c>)
 80026d2:	f7fe fbef 	bl	8000eb4 <USART_ReceiveData>
 80026d6:	4603      	mov	r3, r0
 80026d8:	b2db      	uxtb	r3, r3
 80026da:	70fb      	strb	r3, [r7, #3]
        if (bufEnDat(pUartBuffQueueRx, &byReceiverData) == ERR_BUF_FULL) {}
 80026dc:	1cfb      	adds	r3, r7, #3
 80026de:	4619      	mov	r1, r3
 80026e0:	6878      	ldr	r0, [r7, #4]
 80026e2:	f003 f83d 	bl	8005760 <bufEnDat>
        USART_ClearITPendingBit(USART2, USART_IT_RXNE);
 80026e6:	f240 5125 	movw	r1, #1317	; 0x525
 80026ea:	4804      	ldr	r0, [pc, #16]	; (80026fc <USART2_IRQHandler+0x4c>)
 80026ec:	f7fe fc4d 	bl	8000f8a <USART_ClearITPendingBit>
  __ASM volatile ("cpsie i" : : : "memory");
 80026f0:	b662      	cpsie	i
}
 80026f2:	bf00      	nop
    }
    __enable_irq();
}
 80026f4:	bf00      	nop
 80026f6:	3708      	adds	r7, #8
 80026f8:	46bd      	mov	sp, r7
 80026fa:	bd80      	pop	{r7, pc}
 80026fc:	40004400 	.word	0x40004400
 8002700:	20000478 	.word	0x20000478

08002704 <delayMicroseconds>:
//ucg_int_t get_tx(void) { return tx; };
//ucg_int_t get_ty(void) { return ty; };
//ucg_t *get_ucg(void) { return &ucg; };

static void delayMicroseconds(uint32_t microseconds)
{
 8002704:	b480      	push	{r7}
 8002706:	b083      	sub	sp, #12
 8002708:	af00      	add	r7, sp, #0
 800270a:	6078      	str	r0, [r7, #4]
//	}
//	uint32_t i;
//	for( i = 0; i < microseconds; i++ )
//	{
//	}
}
 800270c:	bf00      	nop
 800270e:	370c      	adds	r7, #12
 8002710:	46bd      	mov	sp, r7
 8002712:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002716:	4770      	bx	lr

08002718 <ucg_gpio_init>:

static void ucg_gpio_init(void) {
 8002718:	b580      	push	{r7, lr}
 800271a:	b082      	sub	sp, #8
 800271c:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStructure;

	/* GPIOA, GPIOB and GPIOC Clocks enable */
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB | RCC_AHB1Periph_GPIOC, ENABLE);
 800271e:	2101      	movs	r1, #1
 8002720:	2007      	movs	r0, #7
 8002722:	f7fe f88d 	bl	8000840 <RCC_AHB1PeriphClockCmd>

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002726:	2301      	movs	r3, #1
 8002728:	713b      	strb	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
 800272a:	2303      	movs	r3, #3
 800272c:	717b      	strb	r3, [r7, #5]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800272e:	2300      	movs	r3, #0
 8002730:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8002732:	2300      	movs	r3, #0
 8002734:	71fb      	strb	r3, [r7, #7]

	GPIO_InitStructure.GPIO_Pin = SPI1_SCK_PIN | SPI1_MOSI_PIN | SPI1_RS_PIN | SPI1_MODE_PIN;
 8002736:	f44f 7368 	mov.w	r3, #928	; 0x3a0
 800273a:	603b      	str	r3, [r7, #0]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800273c:	463b      	mov	r3, r7
 800273e:	4619      	mov	r1, r3
 8002740:	480a      	ldr	r0, [pc, #40]	; (800276c <ucg_gpio_init+0x54>)
 8002742:	f7fd fea7 	bl	8000494 <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = SPI1_CS_PIN | SPI1_ENABLE_PIN;
 8002746:	f44f 6388 	mov.w	r3, #1088	; 0x440
 800274a:	603b      	str	r3, [r7, #0]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800274c:	463b      	mov	r3, r7
 800274e:	4619      	mov	r1, r3
 8002750:	4807      	ldr	r0, [pc, #28]	; (8002770 <ucg_gpio_init+0x58>)
 8002752:	f7fd fe9f 	bl	8000494 <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = SPI1_RST_PIN;
 8002756:	2380      	movs	r3, #128	; 0x80
 8002758:	603b      	str	r3, [r7, #0]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 800275a:	463b      	mov	r3, r7
 800275c:	4619      	mov	r1, r3
 800275e:	4805      	ldr	r0, [pc, #20]	; (8002774 <ucg_gpio_init+0x5c>)
 8002760:	f7fd fe98 	bl	8000494 <GPIO_Init>
}
 8002764:	bf00      	nop
 8002766:	3708      	adds	r7, #8
 8002768:	46bd      	mov	sp, r7
 800276a:	bd80      	pop	{r7, pc}
 800276c:	40020000 	.word	0x40020000
 8002770:	40020400 	.word	0x40020400
 8002774:	40020800 	.word	0x40020800

08002778 <ucg_com_arduino_send_generic_SW_SPI>:

static void ucg_com_arduino_send_generic_SW_SPI(ucg_t *ucg, uint8_t data)
{
 8002778:	b580      	push	{r7, lr}
 800277a:	b084      	sub	sp, #16
 800277c:	af00      	add	r7, sp, #0
 800277e:	6078      	str	r0, [r7, #4]
 8002780:	460b      	mov	r3, r1
 8002782:	70fb      	strb	r3, [r7, #3]
  uint8_t i = 8;
 8002784:	2308      	movs	r3, #8
 8002786:	73fb      	strb	r3, [r7, #15]

  do
  {
    if ( data & 128 )
 8002788:	f997 3003 	ldrsb.w	r3, [r7, #3]
 800278c:	2b00      	cmp	r3, #0
 800278e:	da05      	bge.n	800279c <ucg_com_arduino_send_generic_SW_SPI+0x24>
    {
      GPIO_WriteBit(SPI1_MOSI_PORT, SPI1_MOSI_PIN, 1);
 8002790:	2201      	movs	r2, #1
 8002792:	2180      	movs	r1, #128	; 0x80
 8002794:	4814      	ldr	r0, [pc, #80]	; (80027e8 <ucg_com_arduino_send_generic_SW_SPI+0x70>)
 8002796:	f7fd ff44 	bl	8000622 <GPIO_WriteBit>
 800279a:	e004      	b.n	80027a6 <ucg_com_arduino_send_generic_SW_SPI+0x2e>
    }
    else
    {
      GPIO_WriteBit(SPI1_MOSI_PORT, SPI1_MOSI_PIN, 0);
 800279c:	2200      	movs	r2, #0
 800279e:	2180      	movs	r1, #128	; 0x80
 80027a0:	4811      	ldr	r0, [pc, #68]	; (80027e8 <ucg_com_arduino_send_generic_SW_SPI+0x70>)
 80027a2:	f7fd ff3e 	bl	8000622 <GPIO_WriteBit>
    }
    // no delay required, also Arduino Due is slow enough
    // delay required for ESP32
    delayMicroseconds(1);
 80027a6:	2001      	movs	r0, #1
 80027a8:	f7ff ffac 	bl	8002704 <delayMicroseconds>
    GPIO_WriteBit(SPI1_SCK_PORT, SPI1_SCK_PIN, 1);
 80027ac:	2201      	movs	r2, #1
 80027ae:	2120      	movs	r1, #32
 80027b0:	480d      	ldr	r0, [pc, #52]	; (80027e8 <ucg_com_arduino_send_generic_SW_SPI+0x70>)
 80027b2:	f7fd ff36 	bl	8000622 <GPIO_WriteBit>
    delayMicroseconds(1);
 80027b6:	2001      	movs	r0, #1
 80027b8:	f7ff ffa4 	bl	8002704 <delayMicroseconds>
    i--;
 80027bc:	7bfb      	ldrb	r3, [r7, #15]
 80027be:	3b01      	subs	r3, #1
 80027c0:	73fb      	strb	r3, [r7, #15]
    GPIO_WriteBit(SPI1_SCK_PORT, SPI1_SCK_PIN, 0);
 80027c2:	2200      	movs	r2, #0
 80027c4:	2120      	movs	r1, #32
 80027c6:	4808      	ldr	r0, [pc, #32]	; (80027e8 <ucg_com_arduino_send_generic_SW_SPI+0x70>)
 80027c8:	f7fd ff2b 	bl	8000622 <GPIO_WriteBit>
    delayMicroseconds(1);
 80027cc:	2001      	movs	r0, #1
 80027ce:	f7ff ff99 	bl	8002704 <delayMicroseconds>
    data <<= 1;
 80027d2:	78fb      	ldrb	r3, [r7, #3]
 80027d4:	005b      	lsls	r3, r3, #1
 80027d6:	70fb      	strb	r3, [r7, #3]
  } while( i > 0 );
 80027d8:	7bfb      	ldrb	r3, [r7, #15]
 80027da:	2b00      	cmp	r3, #0
 80027dc:	d1d4      	bne.n	8002788 <ucg_com_arduino_send_generic_SW_SPI+0x10>
}
 80027de:	bf00      	nop
 80027e0:	bf00      	nop
 80027e2:	3710      	adds	r7, #16
 80027e4:	46bd      	mov	sp, r7
 80027e6:	bd80      	pop	{r7, pc}
 80027e8:	40020000 	.word	0x40020000

080027ec <ucg_com_arduino_generic_SW_SPI>:

static int16_t ucg_com_arduino_generic_SW_SPI(ucg_t *ucg, int16_t msg, uint16_t arg, uint8_t *data)
{
 80027ec:	b580      	push	{r7, lr}
 80027ee:	b084      	sub	sp, #16
 80027f0:	af00      	add	r7, sp, #0
 80027f2:	60f8      	str	r0, [r7, #12]
 80027f4:	607b      	str	r3, [r7, #4]
 80027f6:	460b      	mov	r3, r1
 80027f8:	817b      	strh	r3, [r7, #10]
 80027fa:	4613      	mov	r3, r2
 80027fc:	813b      	strh	r3, [r7, #8]
  switch(msg)
 80027fe:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8002802:	3b0a      	subs	r3, #10
 8002804:	2b0b      	cmp	r3, #11
 8002806:	f200 80dc 	bhi.w	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>
 800280a:	a201      	add	r2, pc, #4	; (adr r2, 8002810 <ucg_com_arduino_generic_SW_SPI+0x24>)
 800280c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8002810:	08002841 	.word	0x08002841
 8002814:	080029c3 	.word	0x080029c3
 8002818:	08002893 	.word	0x08002893
 800281c:	0800289d 	.word	0x0800289d
 8002820:	080028ad 	.word	0x080028ad
 8002824:	080028bd 	.word	0x080028bd
 8002828:	080028cf 	.word	0x080028cf
 800282c:	080028ef 	.word	0x080028ef
 8002830:	08002917 	.word	0x08002917
 8002834:	0800294d 	.word	0x0800294d
 8002838:	0800296b 	.word	0x0800296b
 800283c:	080029bb 	.word	0x080029bb
      /* "data" is a pointer to ucg_com_info_t structure with the following information: */
      /*	((ucg_com_info_t *)data)->serial_clk_speed value in nanoseconds */
      /*	((ucg_com_info_t *)data)->parallel_clk_speed value in nanoseconds */
    
      /* setup pins */
      ucg_gpio_init();
 8002840:	f7ff ff6a 	bl	8002718 <ucg_gpio_init>

      GPIO_WriteBit(SPI1_MOSI_PORT, SPI1_MOSI_PIN, 1);
 8002844:	2201      	movs	r2, #1
 8002846:	2180      	movs	r1, #128	; 0x80
 8002848:	4860      	ldr	r0, [pc, #384]	; (80029cc <ucg_com_arduino_generic_SW_SPI+0x1e0>)
 800284a:	f7fd feea 	bl	8000622 <GPIO_WriteBit>
      GPIO_WriteBit(SPI1_CS_PORT, SPI1_CS_PIN, 1);
 800284e:	2201      	movs	r2, #1
 8002850:	2140      	movs	r1, #64	; 0x40
 8002852:	485f      	ldr	r0, [pc, #380]	; (80029d0 <ucg_com_arduino_generic_SW_SPI+0x1e4>)
 8002854:	f7fd fee5 	bl	8000622 <GPIO_WriteBit>
      GPIO_WriteBit(SPI1_RST_PORT, SPI1_RST_PIN, 1);
 8002858:	2201      	movs	r2, #1
 800285a:	2180      	movs	r1, #128	; 0x80
 800285c:	485d      	ldr	r0, [pc, #372]	; (80029d4 <ucg_com_arduino_generic_SW_SPI+0x1e8>)
 800285e:	f7fd fee0 	bl	8000622 <GPIO_WriteBit>
      GPIO_WriteBit(SPI1_RS_PORT, SPI1_RS_PIN, 1);
 8002862:	2201      	movs	r2, #1
 8002864:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002868:	4858      	ldr	r0, [pc, #352]	; (80029cc <ucg_com_arduino_generic_SW_SPI+0x1e0>)
 800286a:	f7fd feda 	bl	8000622 <GPIO_WriteBit>
      GPIO_WriteBit(SPI1_SCK_PORT, SPI1_SCK_PIN, 0);
 800286e:	2200      	movs	r2, #0
 8002870:	2120      	movs	r1, #32
 8002872:	4856      	ldr	r0, [pc, #344]	; (80029cc <ucg_com_arduino_generic_SW_SPI+0x1e0>)
 8002874:	f7fd fed5 	bl	8000622 <GPIO_WriteBit>
      GPIO_WriteBit(SPI1_ENABLE_PORT, SPI1_ENABLE_PIN, 1);
 8002878:	2201      	movs	r2, #1
 800287a:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800287e:	4854      	ldr	r0, [pc, #336]	; (80029d0 <ucg_com_arduino_generic_SW_SPI+0x1e4>)
 8002880:	f7fd fecf 	bl	8000622 <GPIO_WriteBit>
      GPIO_WriteBit(SPI1_MODE_PORT, SPI1_MODE_PIN, 1);
 8002884:	2201      	movs	r2, #1
 8002886:	f44f 7180 	mov.w	r1, #256	; 0x100
 800288a:	4850      	ldr	r0, [pc, #320]	; (80029cc <ucg_com_arduino_generic_SW_SPI+0x1e0>)
 800288c:	f7fd fec9 	bl	8000622 <GPIO_WriteBit>
      break;
 8002890:	e097      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_POWER_DOWN:
      break;

    case UCG_COM_MSG_DELAY:
      delayMicroseconds(arg);
 8002892:	893b      	ldrh	r3, [r7, #8]
 8002894:	4618      	mov	r0, r3
 8002896:	f7ff ff35 	bl	8002704 <delayMicroseconds>
      break;
 800289a:	e092      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_CHANGE_RESET_LINE:
      GPIO_WriteBit(SPI1_RST_PORT, SPI1_RST_PIN, arg);
 800289c:	893b      	ldrh	r3, [r7, #8]
 800289e:	b2db      	uxtb	r3, r3
 80028a0:	461a      	mov	r2, r3
 80028a2:	2180      	movs	r1, #128	; 0x80
 80028a4:	484b      	ldr	r0, [pc, #300]	; (80029d4 <ucg_com_arduino_generic_SW_SPI+0x1e8>)
 80028a6:	f7fd febc 	bl	8000622 <GPIO_WriteBit>
      break;
 80028aa:	e08a      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_CHANGE_CS_LINE:
	  GPIO_WriteBit(SPI1_CS_PORT, SPI1_CS_PIN, arg);
 80028ac:	893b      	ldrh	r3, [r7, #8]
 80028ae:	b2db      	uxtb	r3, r3
 80028b0:	461a      	mov	r2, r3
 80028b2:	2140      	movs	r1, #64	; 0x40
 80028b4:	4846      	ldr	r0, [pc, #280]	; (80029d0 <ucg_com_arduino_generic_SW_SPI+0x1e4>)
 80028b6:	f7fd feb4 	bl	8000622 <GPIO_WriteBit>
      break;
 80028ba:	e082      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_CHANGE_CD_LINE:
      GPIO_WriteBit(SPI1_RS_PORT, SPI1_RS_PIN, arg);
 80028bc:	893b      	ldrh	r3, [r7, #8]
 80028be:	b2db      	uxtb	r3, r3
 80028c0:	461a      	mov	r2, r3
 80028c2:	f44f 7100 	mov.w	r1, #512	; 0x200
 80028c6:	4841      	ldr	r0, [pc, #260]	; (80029cc <ucg_com_arduino_generic_SW_SPI+0x1e0>)
 80028c8:	f7fd feab 	bl	8000622 <GPIO_WriteBit>
      break;
 80028cc:	e079      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_SEND_BYTE:
      ucg_com_arduino_send_generic_SW_SPI(ucg, arg);
 80028ce:	893b      	ldrh	r3, [r7, #8]
 80028d0:	b2db      	uxtb	r3, r3
 80028d2:	4619      	mov	r1, r3
 80028d4:	68f8      	ldr	r0, [r7, #12]
 80028d6:	f7ff ff4f 	bl	8002778 <ucg_com_arduino_send_generic_SW_SPI>
      break;
 80028da:	e072      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_REPEAT_1_BYTE:
      while( arg > 0 ) {
	    ucg_com_arduino_send_generic_SW_SPI(ucg, data[0]);
 80028dc:	687b      	ldr	r3, [r7, #4]
 80028de:	781b      	ldrb	r3, [r3, #0]
 80028e0:	4619      	mov	r1, r3
 80028e2:	68f8      	ldr	r0, [r7, #12]
 80028e4:	f7ff ff48 	bl	8002778 <ucg_com_arduino_send_generic_SW_SPI>
	    arg--;
 80028e8:	893b      	ldrh	r3, [r7, #8]
 80028ea:	3b01      	subs	r3, #1
 80028ec:	813b      	strh	r3, [r7, #8]
      while( arg > 0 ) {
 80028ee:	893b      	ldrh	r3, [r7, #8]
 80028f0:	2b00      	cmp	r3, #0
 80028f2:	d1f3      	bne.n	80028dc <ucg_com_arduino_generic_SW_SPI+0xf0>
      }
      break;
 80028f4:	e065      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_REPEAT_2_BYTES:
      while( arg > 0 ) {
		ucg_com_arduino_send_generic_SW_SPI(ucg, data[0]);
 80028f6:	687b      	ldr	r3, [r7, #4]
 80028f8:	781b      	ldrb	r3, [r3, #0]
 80028fa:	4619      	mov	r1, r3
 80028fc:	68f8      	ldr	r0, [r7, #12]
 80028fe:	f7ff ff3b 	bl	8002778 <ucg_com_arduino_send_generic_SW_SPI>
		ucg_com_arduino_send_generic_SW_SPI(ucg, data[1]);
 8002902:	687b      	ldr	r3, [r7, #4]
 8002904:	3301      	adds	r3, #1
 8002906:	781b      	ldrb	r3, [r3, #0]
 8002908:	4619      	mov	r1, r3
 800290a:	68f8      	ldr	r0, [r7, #12]
 800290c:	f7ff ff34 	bl	8002778 <ucg_com_arduino_send_generic_SW_SPI>
		arg--;
 8002910:	893b      	ldrh	r3, [r7, #8]
 8002912:	3b01      	subs	r3, #1
 8002914:	813b      	strh	r3, [r7, #8]
      while( arg > 0 ) {
 8002916:	893b      	ldrh	r3, [r7, #8]
 8002918:	2b00      	cmp	r3, #0
 800291a:	d1ec      	bne.n	80028f6 <ucg_com_arduino_generic_SW_SPI+0x10a>
      }
      break;
 800291c:	e051      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_REPEAT_3_BYTES:
      while( arg > 0 ) {
		ucg_com_arduino_send_generic_SW_SPI(ucg, data[0]);
 800291e:	687b      	ldr	r3, [r7, #4]
 8002920:	781b      	ldrb	r3, [r3, #0]
 8002922:	4619      	mov	r1, r3
 8002924:	68f8      	ldr	r0, [r7, #12]
 8002926:	f7ff ff27 	bl	8002778 <ucg_com_arduino_send_generic_SW_SPI>
		ucg_com_arduino_send_generic_SW_SPI(ucg, data[1]);
 800292a:	687b      	ldr	r3, [r7, #4]
 800292c:	3301      	adds	r3, #1
 800292e:	781b      	ldrb	r3, [r3, #0]
 8002930:	4619      	mov	r1, r3
 8002932:	68f8      	ldr	r0, [r7, #12]
 8002934:	f7ff ff20 	bl	8002778 <ucg_com_arduino_send_generic_SW_SPI>
		ucg_com_arduino_send_generic_SW_SPI(ucg, data[2]);
 8002938:	687b      	ldr	r3, [r7, #4]
 800293a:	3302      	adds	r3, #2
 800293c:	781b      	ldrb	r3, [r3, #0]
 800293e:	4619      	mov	r1, r3
 8002940:	68f8      	ldr	r0, [r7, #12]
 8002942:	f7ff ff19 	bl	8002778 <ucg_com_arduino_send_generic_SW_SPI>
		arg--;
 8002946:	893b      	ldrh	r3, [r7, #8]
 8002948:	3b01      	subs	r3, #1
 800294a:	813b      	strh	r3, [r7, #8]
      while( arg > 0 ) {
 800294c:	893b      	ldrh	r3, [r7, #8]
 800294e:	2b00      	cmp	r3, #0
 8002950:	d1e5      	bne.n	800291e <ucg_com_arduino_generic_SW_SPI+0x132>
      }
      break;
 8002952:	e036      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_SEND_STR:
      while( arg > 0 ) {
		ucg_com_arduino_send_generic_SW_SPI(ucg, *data++);
 8002954:	687b      	ldr	r3, [r7, #4]
 8002956:	1c5a      	adds	r2, r3, #1
 8002958:	607a      	str	r2, [r7, #4]
 800295a:	781b      	ldrb	r3, [r3, #0]
 800295c:	4619      	mov	r1, r3
 800295e:	68f8      	ldr	r0, [r7, #12]
 8002960:	f7ff ff0a 	bl	8002778 <ucg_com_arduino_send_generic_SW_SPI>
		arg--;
 8002964:	893b      	ldrh	r3, [r7, #8]
 8002966:	3b01      	subs	r3, #1
 8002968:	813b      	strh	r3, [r7, #8]
      while( arg > 0 ) {
 800296a:	893b      	ldrh	r3, [r7, #8]
 800296c:	2b00      	cmp	r3, #0
 800296e:	d1f1      	bne.n	8002954 <ucg_com_arduino_generic_SW_SPI+0x168>
      }
      break;
 8002970:	e027      	b.n	80029c2 <ucg_com_arduino_generic_SW_SPI+0x1d6>

    case UCG_COM_MSG_SEND_CD_DATA_SEQUENCE:
      while(arg > 0)
      {
		if ( *data != 0 )
 8002972:	687b      	ldr	r3, [r7, #4]
 8002974:	781b      	ldrb	r3, [r3, #0]
 8002976:	2b00      	cmp	r3, #0
 8002978:	d010      	beq.n	800299c <ucg_com_arduino_generic_SW_SPI+0x1b0>
		{
		  if ( *data == 1 )
 800297a:	687b      	ldr	r3, [r7, #4]
 800297c:	781b      	ldrb	r3, [r3, #0]
 800297e:	2b01      	cmp	r3, #1
 8002980:	d106      	bne.n	8002990 <ucg_com_arduino_generic_SW_SPI+0x1a4>
		  {
			GPIO_WriteBit(SPI1_RS_PORT, SPI1_RS_PIN, 0);
 8002982:	2200      	movs	r2, #0
 8002984:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002988:	4810      	ldr	r0, [pc, #64]	; (80029cc <ucg_com_arduino_generic_SW_SPI+0x1e0>)
 800298a:	f7fd fe4a 	bl	8000622 <GPIO_WriteBit>
 800298e:	e005      	b.n	800299c <ucg_com_arduino_generic_SW_SPI+0x1b0>
		  }
		  else
		  {
			GPIO_WriteBit(SPI1_RS_PORT, SPI1_RS_PIN, 1);
 8002990:	2201      	movs	r2, #1
 8002992:	f44f 7100 	mov.w	r1, #512	; 0x200
 8002996:	480d      	ldr	r0, [pc, #52]	; (80029cc <ucg_com_arduino_generic_SW_SPI+0x1e0>)
 8002998:	f7fd fe43 	bl	8000622 <GPIO_WriteBit>
		  }
		}
		data++;
 800299c:	687b      	ldr	r3, [r7, #4]
 800299e:	3301      	adds	r3, #1
 80029a0:	607b      	str	r3, [r7, #4]
		ucg_com_arduino_send_generic_SW_SPI(ucg, *data);
 80029a2:	687b      	ldr	r3, [r7, #4]
 80029a4:	781b      	ldrb	r3, [r3, #0]
 80029a6:	4619      	mov	r1, r3
 80029a8:	68f8      	ldr	r0, [r7, #12]
 80029aa:	f7ff fee5 	bl	8002778 <ucg_com_arduino_send_generic_SW_SPI>
		data++;
 80029ae:	687b      	ldr	r3, [r7, #4]
 80029b0:	3301      	adds	r3, #1
 80029b2:	607b      	str	r3, [r7, #4]
		arg--;
 80029b4:	893b      	ldrh	r3, [r7, #8]
 80029b6:	3b01      	subs	r3, #1
 80029b8:	813b      	strh	r3, [r7, #8]
      while(arg > 0)
 80029ba:	893b      	ldrh	r3, [r7, #8]
 80029bc:	2b00      	cmp	r3, #0
 80029be:	d1d8      	bne.n	8002972 <ucg_com_arduino_generic_SW_SPI+0x186>
      }
      break;
 80029c0:	bf00      	nop
  }
  return 1;
 80029c2:	2301      	movs	r3, #1
}
 80029c4:	4618      	mov	r0, r3
 80029c6:	3710      	adds	r7, #16
 80029c8:	46bd      	mov	sp, r7
 80029ca:	bd80      	pop	{r7, pc}
 80029cc:	40020000 	.word	0x40020000
 80029d0:	40020400 	.word	0x40020400
 80029d4:	40020800 	.word	0x40020800

080029d8 <Ucglib4WireSWSPI_begin>:

void Ucglib4WireSWSPI_begin(ucg_t *ucg, uint8_t is_transparent)
{ 
 80029d8:	b580      	push	{r7, lr}
 80029da:	b082      	sub	sp, #8
 80029dc:	af00      	add	r7, sp, #0
 80029de:	6078      	str	r0, [r7, #4]
 80029e0:	460b      	mov	r3, r1
 80029e2:	70fb      	strb	r3, [r7, #3]
  ucg_Init(ucg, ucg_dev_st7735_18x128x128, ucg_ext_st7735_18, ucg_com_arduino_generic_SW_SPI);
 80029e4:	4b07      	ldr	r3, [pc, #28]	; (8002a04 <Ucglib4WireSWSPI_begin+0x2c>)
 80029e6:	4a08      	ldr	r2, [pc, #32]	; (8002a08 <Ucglib4WireSWSPI_begin+0x30>)
 80029e8:	4908      	ldr	r1, [pc, #32]	; (8002a0c <Ucglib4WireSWSPI_begin+0x34>)
 80029ea:	6878      	ldr	r0, [r7, #4]
 80029ec:	f002 f83c 	bl	8004a68 <ucg_Init>
  ucg_SetFontMode(ucg, is_transparent);
 80029f0:	78fb      	ldrb	r3, [r7, #3]
 80029f2:	4619      	mov	r1, r3
 80029f4:	6878      	ldr	r0, [r7, #4]
 80029f6:	f001 fe20 	bl	800463a <ucg_SetFontMode>
}
 80029fa:	bf00      	nop
 80029fc:	3708      	adds	r7, #8
 80029fe:	46bd      	mov	sp, r7
 8002a00:	bd80      	pop	{r7, pc}
 8002a02:	bf00      	nop
 8002a04:	080027ed 	.word	0x080027ed
 8002a08:	08003d4d 	.word	0x08003d4d
 8002a0c:	08003e91 	.word	0x08003e91

08002a10 <ucg_DrawBox>:
*/

#include "ucg.h"

void ucg_DrawBox(ucg_t *ucg, ucg_int_t x, ucg_int_t y, ucg_int_t w, ucg_int_t h)
{
 8002a10:	b580      	push	{r7, lr}
 8002a12:	b084      	sub	sp, #16
 8002a14:	af00      	add	r7, sp, #0
 8002a16:	60f8      	str	r0, [r7, #12]
 8002a18:	4608      	mov	r0, r1
 8002a1a:	4611      	mov	r1, r2
 8002a1c:	461a      	mov	r2, r3
 8002a1e:	4603      	mov	r3, r0
 8002a20:	817b      	strh	r3, [r7, #10]
 8002a22:	460b      	mov	r3, r1
 8002a24:	813b      	strh	r3, [r7, #8]
 8002a26:	4613      	mov	r3, r2
 8002a28:	80fb      	strh	r3, [r7, #6]
  while( h > 0 )
 8002a2a:	e014      	b.n	8002a56 <ucg_DrawBox+0x46>
  {
    ucg_DrawHLine(ucg, x, y, w);
 8002a2c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8002a30:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8002a34:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 8002a38:	68f8      	ldr	r0, [r7, #12]
 8002a3a:	f002 f887 	bl	8004b4c <ucg_DrawHLine>
    h--;
 8002a3e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8002a42:	b29b      	uxth	r3, r3
 8002a44:	3b01      	subs	r3, #1
 8002a46:	b29b      	uxth	r3, r3
 8002a48:	833b      	strh	r3, [r7, #24]
    y++;
 8002a4a:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8002a4e:	b29b      	uxth	r3, r3
 8002a50:	3301      	adds	r3, #1
 8002a52:	b29b      	uxth	r3, r3
 8002a54:	813b      	strh	r3, [r7, #8]
  while( h > 0 )
 8002a56:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8002a5a:	2b00      	cmp	r3, #0
 8002a5c:	dce6      	bgt.n	8002a2c <ucg_DrawBox+0x1c>
  }  
}
 8002a5e:	bf00      	nop
 8002a60:	bf00      	nop
 8002a62:	3710      	adds	r7, #16
 8002a64:	46bd      	mov	sp, r7
 8002a66:	bd80      	pop	{r7, pc}

08002a68 <ucg_ClearScreen>:
  - clear the screen with black color
  - reset clip range to max
  - set draw color to white
*/
void ucg_ClearScreen(ucg_t *ucg)
{
 8002a68:	b580      	push	{r7, lr}
 8002a6a:	b084      	sub	sp, #16
 8002a6c:	af02      	add	r7, sp, #8
 8002a6e:	6078      	str	r0, [r7, #4]
  ucg_SetColor(ucg, 0, 0, 0, 0);
 8002a70:	2300      	movs	r3, #0
 8002a72:	9300      	str	r3, [sp, #0]
 8002a74:	2300      	movs	r3, #0
 8002a76:	2200      	movs	r2, #0
 8002a78:	2100      	movs	r1, #0
 8002a7a:	6878      	ldr	r0, [r7, #4]
 8002a7c:	f002 f95f 	bl	8004d3e <ucg_SetColor>
  ucg_SetMaxClipRange(ucg);
 8002a80:	6878      	ldr	r0, [r7, #4]
 8002a82:	f001 f9be 	bl	8003e02 <ucg_SetMaxClipRange>
  ucg_DrawBox(ucg, 0, 0, ucg_GetWidth(ucg), ucg_GetHeight(ucg));
 8002a86:	687b      	ldr	r3, [r7, #4]
 8002a88:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8002a8c:	687b      	ldr	r3, [r7, #4]
 8002a8e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8002a92:	9300      	str	r3, [sp, #0]
 8002a94:	4613      	mov	r3, r2
 8002a96:	2200      	movs	r2, #0
 8002a98:	2100      	movs	r1, #0
 8002a9a:	6878      	ldr	r0, [r7, #4]
 8002a9c:	f7ff ffb8 	bl	8002a10 <ucg_DrawBox>
  ucg_SetColor(ucg, 0, 255, 255, 255);
 8002aa0:	23ff      	movs	r3, #255	; 0xff
 8002aa2:	9300      	str	r3, [sp, #0]
 8002aa4:	23ff      	movs	r3, #255	; 0xff
 8002aa6:	22ff      	movs	r2, #255	; 0xff
 8002aa8:	2100      	movs	r1, #0
 8002aaa:	6878      	ldr	r0, [r7, #4]
 8002aac:	f002 f947 	bl	8004d3e <ucg_SetColor>
}
 8002ab0:	bf00      	nop
 8002ab2:	3708      	adds	r7, #8
 8002ab4:	46bd      	mov	sp, r7
 8002ab6:	bd80      	pop	{r7, pc}

08002ab8 <ucg_DrawFrame>:
}


/* restrictions: w > 0 && h > 0 */
void ucg_DrawFrame(ucg_t *ucg, ucg_int_t x, ucg_int_t y, ucg_int_t w, ucg_int_t h)
{
 8002ab8:	b580      	push	{r7, lr}
 8002aba:	b086      	sub	sp, #24
 8002abc:	af00      	add	r7, sp, #0
 8002abe:	60f8      	str	r0, [r7, #12]
 8002ac0:	4608      	mov	r0, r1
 8002ac2:	4611      	mov	r1, r2
 8002ac4:	461a      	mov	r2, r3
 8002ac6:	4603      	mov	r3, r0
 8002ac8:	817b      	strh	r3, [r7, #10]
 8002aca:	460b      	mov	r3, r1
 8002acc:	813b      	strh	r3, [r7, #8]
 8002ace:	4613      	mov	r3, r2
 8002ad0:	80fb      	strh	r3, [r7, #6]
  ucg_int_t xtmp = x;
 8002ad2:	897b      	ldrh	r3, [r7, #10]
 8002ad4:	82fb      	strh	r3, [r7, #22]
  
  ucg_DrawHLine(ucg, x, y, w);
 8002ad6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8002ada:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8002ade:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 8002ae2:	68f8      	ldr	r0, [r7, #12]
 8002ae4:	f002 f832 	bl	8004b4c <ucg_DrawHLine>
  ucg_DrawVLine(ucg, x, y, h);
 8002ae8:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8002aec:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8002af0:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 8002af4:	68f8      	ldr	r0, [r7, #12]
 8002af6:	f002 f847 	bl	8004b88 <ucg_DrawVLine>
  x+=w;
 8002afa:	897a      	ldrh	r2, [r7, #10]
 8002afc:	88fb      	ldrh	r3, [r7, #6]
 8002afe:	4413      	add	r3, r2
 8002b00:	b29b      	uxth	r3, r3
 8002b02:	817b      	strh	r3, [r7, #10]
  x--;
 8002b04:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8002b08:	b29b      	uxth	r3, r3
 8002b0a:	3b01      	subs	r3, #1
 8002b0c:	b29b      	uxth	r3, r3
 8002b0e:	817b      	strh	r3, [r7, #10]
  ucg_DrawVLine(ucg, x, y, h);
 8002b10:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8002b14:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8002b18:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 8002b1c:	68f8      	ldr	r0, [r7, #12]
 8002b1e:	f002 f833 	bl	8004b88 <ucg_DrawVLine>
  y+=h;
 8002b22:	893a      	ldrh	r2, [r7, #8]
 8002b24:	8c3b      	ldrh	r3, [r7, #32]
 8002b26:	4413      	add	r3, r2
 8002b28:	b29b      	uxth	r3, r3
 8002b2a:	813b      	strh	r3, [r7, #8]
  y--;
 8002b2c:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8002b30:	b29b      	uxth	r3, r3
 8002b32:	3b01      	subs	r3, #1
 8002b34:	b29b      	uxth	r3, r3
 8002b36:	813b      	strh	r3, [r7, #8]
  ucg_DrawHLine(ucg, xtmp, y, w);
 8002b38:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8002b3c:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8002b40:	f9b7 1016 	ldrsh.w	r1, [r7, #22]
 8002b44:	68f8      	ldr	r0, [r7, #12]
 8002b46:	f002 f801 	bl	8004b4c <ucg_DrawHLine>
}
 8002b4a:	bf00      	nop
 8002b4c:	3718      	adds	r7, #24
 8002b4e:	46bd      	mov	sp, r7
 8002b50:	bd80      	pop	{r7, pc}

08002b52 <ucg_ccs_init>:
/*
  Setup change from "start" to "end" with a specified amount of "steps".
  After calling this procedure, ccs->current will contain the "start" value.
*/
void ucg_ccs_init(ucg_ccs_t *ccs, uint8_t start, uint8_t end, ucg_int_t steps)
{
 8002b52:	b480      	push	{r7}
 8002b54:	b083      	sub	sp, #12
 8002b56:	af00      	add	r7, sp, #0
 8002b58:	6078      	str	r0, [r7, #4]
 8002b5a:	4608      	mov	r0, r1
 8002b5c:	4611      	mov	r1, r2
 8002b5e:	461a      	mov	r2, r3
 8002b60:	4603      	mov	r3, r0
 8002b62:	70fb      	strb	r3, [r7, #3]
 8002b64:	460b      	mov	r3, r1
 8002b66:	70bb      	strb	r3, [r7, #2]
 8002b68:	4613      	mov	r3, r2
 8002b6a:	803b      	strh	r3, [r7, #0]
  ccs->start = start;
 8002b6c:	687b      	ldr	r3, [r7, #4]
 8002b6e:	78fa      	ldrb	r2, [r7, #3]
 8002b70:	705a      	strb	r2, [r3, #1]
  ccs->num = end-start;
 8002b72:	78bb      	ldrb	r3, [r7, #2]
 8002b74:	b29a      	uxth	r2, r3
 8002b76:	78fb      	ldrb	r3, [r7, #3]
 8002b78:	b29b      	uxth	r3, r3
 8002b7a:	1ad3      	subs	r3, r2, r3
 8002b7c:	b29b      	uxth	r3, r3
 8002b7e:	b21a      	sxth	r2, r3
 8002b80:	687b      	ldr	r3, [r7, #4]
 8002b82:	809a      	strh	r2, [r3, #4]
  ccs->den = steps-1;
 8002b84:	883b      	ldrh	r3, [r7, #0]
 8002b86:	3b01      	subs	r3, #1
 8002b88:	b29b      	uxth	r3, r3
 8002b8a:	b21a      	sxth	r2, r3
 8002b8c:	687b      	ldr	r3, [r7, #4]
 8002b8e:	811a      	strh	r2, [r3, #8]
  ccs->dir = 1;
 8002b90:	687b      	ldr	r3, [r7, #4]
 8002b92:	2201      	movs	r2, #1
 8002b94:	805a      	strh	r2, [r3, #2]
  
  ccs->quot = ccs->num / ccs->den;
 8002b96:	687b      	ldr	r3, [r7, #4]
 8002b98:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8002b9c:	461a      	mov	r2, r3
 8002b9e:	687b      	ldr	r3, [r7, #4]
 8002ba0:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8002ba4:	fb92 f3f3 	sdiv	r3, r2, r3
 8002ba8:	b21a      	sxth	r2, r3
 8002baa:	687b      	ldr	r3, [r7, #4]
 8002bac:	80da      	strh	r2, [r3, #6]
  if ( ccs->num < 0 )
 8002bae:	687b      	ldr	r3, [r7, #4]
 8002bb0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8002bb4:	2b00      	cmp	r3, #0
 8002bb6:	da0c      	bge.n	8002bd2 <ucg_ccs_init+0x80>
  {
    ccs->num = -ccs->num;
 8002bb8:	687b      	ldr	r3, [r7, #4]
 8002bba:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8002bbe:	b29b      	uxth	r3, r3
 8002bc0:	425b      	negs	r3, r3
 8002bc2:	b29b      	uxth	r3, r3
 8002bc4:	b21a      	sxth	r2, r3
 8002bc6:	687b      	ldr	r3, [r7, #4]
 8002bc8:	809a      	strh	r2, [r3, #4]
    ccs->dir = -1;
 8002bca:	687b      	ldr	r3, [r7, #4]
 8002bcc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002bd0:	805a      	strh	r2, [r3, #2]
  }
  ccs->rem = ccs->num % ccs->den;
 8002bd2:	687b      	ldr	r3, [r7, #4]
 8002bd4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8002bd8:	687a      	ldr	r2, [r7, #4]
 8002bda:	f9b2 2008 	ldrsh.w	r2, [r2, #8]
 8002bde:	fb93 f1f2 	sdiv	r1, r3, r2
 8002be2:	fb01 f202 	mul.w	r2, r1, r2
 8002be6:	1a9b      	subs	r3, r3, r2
 8002be8:	b21a      	sxth	r2, r3
 8002bea:	687b      	ldr	r3, [r7, #4]
 8002bec:	815a      	strh	r2, [r3, #10]
  
  ccs->frac = ccs->den/2;
 8002bee:	687b      	ldr	r3, [r7, #4]
 8002bf0:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8002bf4:	0fda      	lsrs	r2, r3, #31
 8002bf6:	4413      	add	r3, r2
 8002bf8:	105b      	asrs	r3, r3, #1
 8002bfa:	b21a      	sxth	r2, r3
 8002bfc:	687b      	ldr	r3, [r7, #4]
 8002bfe:	819a      	strh	r2, [r3, #12]
  ccs->current = start;
 8002c00:	687b      	ldr	r3, [r7, #4]
 8002c02:	78fa      	ldrb	r2, [r7, #3]
 8002c04:	701a      	strb	r2, [r3, #0]
}
 8002c06:	bf00      	nop
 8002c08:	370c      	adds	r7, #12
 8002c0a:	46bd      	mov	sp, r7
 8002c0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c10:	4770      	bx	lr

08002c12 <ucg_ccs_step>:
/*
  Make one step towards the "end" value. 
  ccs->curront will contain the updated value.
*/
void ucg_ccs_step(ucg_ccs_t *ccs)
{
 8002c12:	b480      	push	{r7}
 8002c14:	b083      	sub	sp, #12
 8002c16:	af00      	add	r7, sp, #0
 8002c18:	6078      	str	r0, [r7, #4]
  
  ccs->current += ccs->quot;
 8002c1a:	687b      	ldr	r3, [r7, #4]
 8002c1c:	781a      	ldrb	r2, [r3, #0]
 8002c1e:	687b      	ldr	r3, [r7, #4]
 8002c20:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8002c24:	b2db      	uxtb	r3, r3
 8002c26:	4413      	add	r3, r2
 8002c28:	b2da      	uxtb	r2, r3
 8002c2a:	687b      	ldr	r3, [r7, #4]
 8002c2c:	701a      	strb	r2, [r3, #0]
  ccs->frac += ccs->rem;
 8002c2e:	687b      	ldr	r3, [r7, #4]
 8002c30:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8002c34:	b29a      	uxth	r2, r3
 8002c36:	687b      	ldr	r3, [r7, #4]
 8002c38:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8002c3c:	b29b      	uxth	r3, r3
 8002c3e:	4413      	add	r3, r2
 8002c40:	b29b      	uxth	r3, r3
 8002c42:	b21a      	sxth	r2, r3
 8002c44:	687b      	ldr	r3, [r7, #4]
 8002c46:	819a      	strh	r2, [r3, #12]
  if ( ccs->frac >= ccs->den )
 8002c48:	687b      	ldr	r3, [r7, #4]
 8002c4a:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 8002c4e:	687b      	ldr	r3, [r7, #4]
 8002c50:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8002c54:	429a      	cmp	r2, r3
 8002c56:	db16      	blt.n	8002c86 <ucg_ccs_step+0x74>
  {
    ccs->current += ccs->dir;
 8002c58:	687b      	ldr	r3, [r7, #4]
 8002c5a:	781a      	ldrb	r2, [r3, #0]
 8002c5c:	687b      	ldr	r3, [r7, #4]
 8002c5e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8002c62:	b2db      	uxtb	r3, r3
 8002c64:	4413      	add	r3, r2
 8002c66:	b2da      	uxtb	r2, r3
 8002c68:	687b      	ldr	r3, [r7, #4]
 8002c6a:	701a      	strb	r2, [r3, #0]
    ccs->frac -= ccs->den;
 8002c6c:	687b      	ldr	r3, [r7, #4]
 8002c6e:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8002c72:	b29a      	uxth	r2, r3
 8002c74:	687b      	ldr	r3, [r7, #4]
 8002c76:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8002c7a:	b29b      	uxth	r3, r3
 8002c7c:	1ad3      	subs	r3, r2, r3
 8002c7e:	b29b      	uxth	r3, r3
 8002c80:	b21a      	sxth	r2, r3
 8002c82:	687b      	ldr	r3, [r7, #4]
 8002c84:	819a      	strh	r2, [r3, #12]
  }  
}
 8002c86:	bf00      	nop
 8002c88:	370c      	adds	r7, #12
 8002c8a:	46bd      	mov	sp, r7
 8002c8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c90:	4770      	bx	lr

08002c92 <ucg_ccs_seek>:
  
  Seek to the specified "pos"ition.
  "pos" must be between 0 and "end"-1
*/
void ucg_ccs_seek(ucg_ccs_t *ccs, ucg_int_t pos)
{
 8002c92:	b480      	push	{r7}
 8002c94:	b085      	sub	sp, #20
 8002c96:	af00      	add	r7, sp, #0
 8002c98:	6078      	str	r0, [r7, #4]
 8002c9a:	460b      	mov	r3, r1
 8002c9c:	807b      	strh	r3, [r7, #2]
  ucg_int_t p;
  ccs->current = ccs->quot;
 8002c9e:	687b      	ldr	r3, [r7, #4]
 8002ca0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8002ca4:	b2da      	uxtb	r2, r3
 8002ca6:	687b      	ldr	r3, [r7, #4]
 8002ca8:	701a      	strb	r2, [r3, #0]
  ccs->current *= pos;
 8002caa:	687b      	ldr	r3, [r7, #4]
 8002cac:	781a      	ldrb	r2, [r3, #0]
 8002cae:	887b      	ldrh	r3, [r7, #2]
 8002cb0:	b2db      	uxtb	r3, r3
 8002cb2:	fb12 f303 	smulbb	r3, r2, r3
 8002cb6:	b2da      	uxtb	r2, r3
 8002cb8:	687b      	ldr	r3, [r7, #4]
 8002cba:	701a      	strb	r2, [r3, #0]
  p = ccs->rem * pos  + ccs->den/2;
 8002cbc:	687b      	ldr	r3, [r7, #4]
 8002cbe:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8002cc2:	b29a      	uxth	r2, r3
 8002cc4:	887b      	ldrh	r3, [r7, #2]
 8002cc6:	fb12 f303 	smulbb	r3, r2, r3
 8002cca:	b29a      	uxth	r2, r3
 8002ccc:	687b      	ldr	r3, [r7, #4]
 8002cce:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8002cd2:	0fd9      	lsrs	r1, r3, #31
 8002cd4:	440b      	add	r3, r1
 8002cd6:	105b      	asrs	r3, r3, #1
 8002cd8:	b21b      	sxth	r3, r3
 8002cda:	b29b      	uxth	r3, r3
 8002cdc:	4413      	add	r3, r2
 8002cde:	b29b      	uxth	r3, r3
 8002ce0:	81fb      	strh	r3, [r7, #14]
  if ( ccs->dir >= 0 )
 8002ce2:	687b      	ldr	r3, [r7, #4]
 8002ce4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8002ce8:	2b00      	cmp	r3, #0
 8002cea:	db0e      	blt.n	8002d0a <ucg_ccs_seek+0x78>
    ccs->current += p / ccs->den;
 8002cec:	687b      	ldr	r3, [r7, #4]
 8002cee:	781a      	ldrb	r2, [r3, #0]
 8002cf0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8002cf4:	6879      	ldr	r1, [r7, #4]
 8002cf6:	f9b1 1008 	ldrsh.w	r1, [r1, #8]
 8002cfa:	fb93 f3f1 	sdiv	r3, r3, r1
 8002cfe:	b2db      	uxtb	r3, r3
 8002d00:	4413      	add	r3, r2
 8002d02:	b2da      	uxtb	r2, r3
 8002d04:	687b      	ldr	r3, [r7, #4]
 8002d06:	701a      	strb	r2, [r3, #0]
 8002d08:	e00d      	b.n	8002d26 <ucg_ccs_seek+0x94>
  else
    ccs->current -= p / ccs->den;
 8002d0a:	687b      	ldr	r3, [r7, #4]
 8002d0c:	781a      	ldrb	r2, [r3, #0]
 8002d0e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8002d12:	6879      	ldr	r1, [r7, #4]
 8002d14:	f9b1 1008 	ldrsh.w	r1, [r1, #8]
 8002d18:	fb93 f3f1 	sdiv	r3, r3, r1
 8002d1c:	b2db      	uxtb	r3, r3
 8002d1e:	1ad3      	subs	r3, r2, r3
 8002d20:	b2da      	uxtb	r2, r3
 8002d22:	687b      	ldr	r3, [r7, #4]
 8002d24:	701a      	strb	r2, [r3, #0]
  ccs->frac = p % ccs->den;
 8002d26:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8002d2a:	687a      	ldr	r2, [r7, #4]
 8002d2c:	f9b2 2008 	ldrsh.w	r2, [r2, #8]
 8002d30:	fb93 f1f2 	sdiv	r1, r3, r2
 8002d34:	fb01 f202 	mul.w	r2, r1, r2
 8002d38:	1a9b      	subs	r3, r3, r2
 8002d3a:	b21a      	sxth	r2, r3
 8002d3c:	687b      	ldr	r3, [r7, #4]
 8002d3e:	819a      	strh	r2, [r3, #12]
  ccs->current += ccs->start;
 8002d40:	687b      	ldr	r3, [r7, #4]
 8002d42:	781a      	ldrb	r2, [r3, #0]
 8002d44:	687b      	ldr	r3, [r7, #4]
 8002d46:	785b      	ldrb	r3, [r3, #1]
 8002d48:	4413      	add	r3, r2
 8002d4a:	b2da      	uxtb	r2, r3
 8002d4c:	687b      	ldr	r3, [r7, #4]
 8002d4e:	701a      	strb	r2, [r3, #0]
}
 8002d50:	bf00      	nop
 8002d52:	3714      	adds	r7, #20
 8002d54:	46bd      	mov	sp, r7
 8002d56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d5a:	4770      	bx	lr

08002d5c <ucg_draw_circle_section>:
#include "ucg.h"

static void ucg_draw_circle_section(ucg_t *ucg, ucg_int_t x, ucg_int_t y, ucg_int_t x0, ucg_int_t y0, uint8_t option) UCG_NOINLINE;

static void ucg_draw_circle_section(ucg_t *ucg, ucg_int_t x, ucg_int_t y, ucg_int_t x0, ucg_int_t y0, uint8_t option)
{
 8002d5c:	b580      	push	{r7, lr}
 8002d5e:	b084      	sub	sp, #16
 8002d60:	af00      	add	r7, sp, #0
 8002d62:	60f8      	str	r0, [r7, #12]
 8002d64:	4608      	mov	r0, r1
 8002d66:	4611      	mov	r1, r2
 8002d68:	461a      	mov	r2, r3
 8002d6a:	4603      	mov	r3, r0
 8002d6c:	817b      	strh	r3, [r7, #10]
 8002d6e:	460b      	mov	r3, r1
 8002d70:	813b      	strh	r3, [r7, #8]
 8002d72:	4613      	mov	r3, r2
 8002d74:	80fb      	strh	r3, [r7, #6]
    /* upper right */
    if ( option & UCG_DRAW_UPPER_RIGHT )
 8002d76:	7f3b      	ldrb	r3, [r7, #28]
 8002d78:	f003 0301 	and.w	r3, r3, #1
 8002d7c:	2b00      	cmp	r3, #0
 8002d7e:	d01b      	beq.n	8002db8 <ucg_draw_circle_section+0x5c>
    {
      ucg_DrawPixel(ucg, x0 + x, y0 - y);
 8002d80:	88fa      	ldrh	r2, [r7, #6]
 8002d82:	897b      	ldrh	r3, [r7, #10]
 8002d84:	4413      	add	r3, r2
 8002d86:	b29b      	uxth	r3, r3
 8002d88:	b219      	sxth	r1, r3
 8002d8a:	8b3a      	ldrh	r2, [r7, #24]
 8002d8c:	893b      	ldrh	r3, [r7, #8]
 8002d8e:	1ad3      	subs	r3, r2, r3
 8002d90:	b29b      	uxth	r3, r3
 8002d92:	b21b      	sxth	r3, r3
 8002d94:	461a      	mov	r2, r3
 8002d96:	68f8      	ldr	r0, [r7, #12]
 8002d98:	f001 ffff 	bl	8004d9a <ucg_DrawPixel>
      ucg_DrawPixel(ucg, x0 + y, y0 - x);
 8002d9c:	88fa      	ldrh	r2, [r7, #6]
 8002d9e:	893b      	ldrh	r3, [r7, #8]
 8002da0:	4413      	add	r3, r2
 8002da2:	b29b      	uxth	r3, r3
 8002da4:	b219      	sxth	r1, r3
 8002da6:	8b3a      	ldrh	r2, [r7, #24]
 8002da8:	897b      	ldrh	r3, [r7, #10]
 8002daa:	1ad3      	subs	r3, r2, r3
 8002dac:	b29b      	uxth	r3, r3
 8002dae:	b21b      	sxth	r3, r3
 8002db0:	461a      	mov	r2, r3
 8002db2:	68f8      	ldr	r0, [r7, #12]
 8002db4:	f001 fff1 	bl	8004d9a <ucg_DrawPixel>
    }
    
    /* upper left */
    if ( option & UCG_DRAW_UPPER_LEFT )
 8002db8:	7f3b      	ldrb	r3, [r7, #28]
 8002dba:	f003 0302 	and.w	r3, r3, #2
 8002dbe:	2b00      	cmp	r3, #0
 8002dc0:	d01b      	beq.n	8002dfa <ucg_draw_circle_section+0x9e>
    {
      ucg_DrawPixel(ucg, x0 - x, y0 - y);
 8002dc2:	88fa      	ldrh	r2, [r7, #6]
 8002dc4:	897b      	ldrh	r3, [r7, #10]
 8002dc6:	1ad3      	subs	r3, r2, r3
 8002dc8:	b29b      	uxth	r3, r3
 8002dca:	b219      	sxth	r1, r3
 8002dcc:	8b3a      	ldrh	r2, [r7, #24]
 8002dce:	893b      	ldrh	r3, [r7, #8]
 8002dd0:	1ad3      	subs	r3, r2, r3
 8002dd2:	b29b      	uxth	r3, r3
 8002dd4:	b21b      	sxth	r3, r3
 8002dd6:	461a      	mov	r2, r3
 8002dd8:	68f8      	ldr	r0, [r7, #12]
 8002dda:	f001 ffde 	bl	8004d9a <ucg_DrawPixel>
      ucg_DrawPixel(ucg, x0 - y, y0 - x);
 8002dde:	88fa      	ldrh	r2, [r7, #6]
 8002de0:	893b      	ldrh	r3, [r7, #8]
 8002de2:	1ad3      	subs	r3, r2, r3
 8002de4:	b29b      	uxth	r3, r3
 8002de6:	b219      	sxth	r1, r3
 8002de8:	8b3a      	ldrh	r2, [r7, #24]
 8002dea:	897b      	ldrh	r3, [r7, #10]
 8002dec:	1ad3      	subs	r3, r2, r3
 8002dee:	b29b      	uxth	r3, r3
 8002df0:	b21b      	sxth	r3, r3
 8002df2:	461a      	mov	r2, r3
 8002df4:	68f8      	ldr	r0, [r7, #12]
 8002df6:	f001 ffd0 	bl	8004d9a <ucg_DrawPixel>
    }
    
    /* lower right */
    if ( option & UCG_DRAW_LOWER_RIGHT )
 8002dfa:	7f3b      	ldrb	r3, [r7, #28]
 8002dfc:	f003 0308 	and.w	r3, r3, #8
 8002e00:	2b00      	cmp	r3, #0
 8002e02:	d01b      	beq.n	8002e3c <ucg_draw_circle_section+0xe0>
    {
      ucg_DrawPixel(ucg, x0 + x, y0 + y);
 8002e04:	88fa      	ldrh	r2, [r7, #6]
 8002e06:	897b      	ldrh	r3, [r7, #10]
 8002e08:	4413      	add	r3, r2
 8002e0a:	b29b      	uxth	r3, r3
 8002e0c:	b219      	sxth	r1, r3
 8002e0e:	8b3a      	ldrh	r2, [r7, #24]
 8002e10:	893b      	ldrh	r3, [r7, #8]
 8002e12:	4413      	add	r3, r2
 8002e14:	b29b      	uxth	r3, r3
 8002e16:	b21b      	sxth	r3, r3
 8002e18:	461a      	mov	r2, r3
 8002e1a:	68f8      	ldr	r0, [r7, #12]
 8002e1c:	f001 ffbd 	bl	8004d9a <ucg_DrawPixel>
      ucg_DrawPixel(ucg, x0 + y, y0 + x);
 8002e20:	88fa      	ldrh	r2, [r7, #6]
 8002e22:	893b      	ldrh	r3, [r7, #8]
 8002e24:	4413      	add	r3, r2
 8002e26:	b29b      	uxth	r3, r3
 8002e28:	b219      	sxth	r1, r3
 8002e2a:	8b3a      	ldrh	r2, [r7, #24]
 8002e2c:	897b      	ldrh	r3, [r7, #10]
 8002e2e:	4413      	add	r3, r2
 8002e30:	b29b      	uxth	r3, r3
 8002e32:	b21b      	sxth	r3, r3
 8002e34:	461a      	mov	r2, r3
 8002e36:	68f8      	ldr	r0, [r7, #12]
 8002e38:	f001 ffaf 	bl	8004d9a <ucg_DrawPixel>
    }
    
    /* lower left */
    if ( option & UCG_DRAW_LOWER_LEFT )
 8002e3c:	7f3b      	ldrb	r3, [r7, #28]
 8002e3e:	f003 0304 	and.w	r3, r3, #4
 8002e42:	2b00      	cmp	r3, #0
 8002e44:	d01b      	beq.n	8002e7e <ucg_draw_circle_section+0x122>
    {
      ucg_DrawPixel(ucg, x0 - x, y0 + y);
 8002e46:	88fa      	ldrh	r2, [r7, #6]
 8002e48:	897b      	ldrh	r3, [r7, #10]
 8002e4a:	1ad3      	subs	r3, r2, r3
 8002e4c:	b29b      	uxth	r3, r3
 8002e4e:	b219      	sxth	r1, r3
 8002e50:	8b3a      	ldrh	r2, [r7, #24]
 8002e52:	893b      	ldrh	r3, [r7, #8]
 8002e54:	4413      	add	r3, r2
 8002e56:	b29b      	uxth	r3, r3
 8002e58:	b21b      	sxth	r3, r3
 8002e5a:	461a      	mov	r2, r3
 8002e5c:	68f8      	ldr	r0, [r7, #12]
 8002e5e:	f001 ff9c 	bl	8004d9a <ucg_DrawPixel>
      ucg_DrawPixel(ucg, x0 - y, y0 + x);
 8002e62:	88fa      	ldrh	r2, [r7, #6]
 8002e64:	893b      	ldrh	r3, [r7, #8]
 8002e66:	1ad3      	subs	r3, r2, r3
 8002e68:	b29b      	uxth	r3, r3
 8002e6a:	b219      	sxth	r1, r3
 8002e6c:	8b3a      	ldrh	r2, [r7, #24]
 8002e6e:	897b      	ldrh	r3, [r7, #10]
 8002e70:	4413      	add	r3, r2
 8002e72:	b29b      	uxth	r3, r3
 8002e74:	b21b      	sxth	r3, r3
 8002e76:	461a      	mov	r2, r3
 8002e78:	68f8      	ldr	r0, [r7, #12]
 8002e7a:	f001 ff8e 	bl	8004d9a <ucg_DrawPixel>
    }
}
 8002e7e:	bf00      	nop
 8002e80:	3710      	adds	r7, #16
 8002e82:	46bd      	mov	sp, r7
 8002e84:	bd80      	pop	{r7, pc}

08002e86 <ucg_draw_circle>:

void ucg_draw_circle(ucg_t *ucg, ucg_int_t x0, ucg_int_t y0, ucg_int_t rad, uint8_t option)
{
 8002e86:	b580      	push	{r7, lr}
 8002e88:	b08a      	sub	sp, #40	; 0x28
 8002e8a:	af02      	add	r7, sp, #8
 8002e8c:	60f8      	str	r0, [r7, #12]
 8002e8e:	4608      	mov	r0, r1
 8002e90:	4611      	mov	r1, r2
 8002e92:	461a      	mov	r2, r3
 8002e94:	4603      	mov	r3, r0
 8002e96:	817b      	strh	r3, [r7, #10]
 8002e98:	460b      	mov	r3, r1
 8002e9a:	813b      	strh	r3, [r7, #8]
 8002e9c:	4613      	mov	r3, r2
 8002e9e:	80fb      	strh	r3, [r7, #6]
    ucg_int_t ddF_x;
    ucg_int_t ddF_y;
    ucg_int_t x;
    ucg_int_t y;

    f = 1;
 8002ea0:	2301      	movs	r3, #1
 8002ea2:	83fb      	strh	r3, [r7, #30]
    f -= rad;
 8002ea4:	8bfa      	ldrh	r2, [r7, #30]
 8002ea6:	88fb      	ldrh	r3, [r7, #6]
 8002ea8:	1ad3      	subs	r3, r2, r3
 8002eaa:	b29b      	uxth	r3, r3
 8002eac:	83fb      	strh	r3, [r7, #30]
    ddF_x = 1;
 8002eae:	2301      	movs	r3, #1
 8002eb0:	83bb      	strh	r3, [r7, #28]
    ddF_y = 0;
 8002eb2:	2300      	movs	r3, #0
 8002eb4:	837b      	strh	r3, [r7, #26]
    ddF_y -= rad;
 8002eb6:	8b7a      	ldrh	r2, [r7, #26]
 8002eb8:	88fb      	ldrh	r3, [r7, #6]
 8002eba:	1ad3      	subs	r3, r2, r3
 8002ebc:	b29b      	uxth	r3, r3
 8002ebe:	837b      	strh	r3, [r7, #26]
    ddF_y *= 2;
 8002ec0:	8b7b      	ldrh	r3, [r7, #26]
 8002ec2:	005b      	lsls	r3, r3, #1
 8002ec4:	b29b      	uxth	r3, r3
 8002ec6:	837b      	strh	r3, [r7, #26]
    x = 0;
 8002ec8:	2300      	movs	r3, #0
 8002eca:	833b      	strh	r3, [r7, #24]
    y = rad;
 8002ecc:	88fb      	ldrh	r3, [r7, #6]
 8002ece:	82fb      	strh	r3, [r7, #22]

    ucg_draw_circle_section(ucg, x, y, x0, y0, option);
 8002ed0:	f9b7 000a 	ldrsh.w	r0, [r7, #10]
 8002ed4:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8002ed8:	f9b7 1018 	ldrsh.w	r1, [r7, #24]
 8002edc:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8002ee0:	9301      	str	r3, [sp, #4]
 8002ee2:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8002ee6:	9300      	str	r3, [sp, #0]
 8002ee8:	4603      	mov	r3, r0
 8002eea:	68f8      	ldr	r0, [r7, #12]
 8002eec:	f7ff ff36 	bl	8002d5c <ucg_draw_circle_section>
    
    while ( x < y )
 8002ef0:	e031      	b.n	8002f56 <ucg_draw_circle+0xd0>
    {
      if (f >= 0) 
 8002ef2:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8002ef6:	2b00      	cmp	r3, #0
 8002ef8:	db0e      	blt.n	8002f18 <ucg_draw_circle+0x92>
      {
        y--;
 8002efa:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8002efe:	b29b      	uxth	r3, r3
 8002f00:	3b01      	subs	r3, #1
 8002f02:	b29b      	uxth	r3, r3
 8002f04:	82fb      	strh	r3, [r7, #22]
        ddF_y += 2;
 8002f06:	8b7b      	ldrh	r3, [r7, #26]
 8002f08:	3302      	adds	r3, #2
 8002f0a:	b29b      	uxth	r3, r3
 8002f0c:	837b      	strh	r3, [r7, #26]
        f += ddF_y;
 8002f0e:	8bfa      	ldrh	r2, [r7, #30]
 8002f10:	8b7b      	ldrh	r3, [r7, #26]
 8002f12:	4413      	add	r3, r2
 8002f14:	b29b      	uxth	r3, r3
 8002f16:	83fb      	strh	r3, [r7, #30]
      }
      x++;
 8002f18:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8002f1c:	b29b      	uxth	r3, r3
 8002f1e:	3301      	adds	r3, #1
 8002f20:	b29b      	uxth	r3, r3
 8002f22:	833b      	strh	r3, [r7, #24]
      ddF_x += 2;
 8002f24:	8bbb      	ldrh	r3, [r7, #28]
 8002f26:	3302      	adds	r3, #2
 8002f28:	b29b      	uxth	r3, r3
 8002f2a:	83bb      	strh	r3, [r7, #28]
      f += ddF_x;
 8002f2c:	8bfa      	ldrh	r2, [r7, #30]
 8002f2e:	8bbb      	ldrh	r3, [r7, #28]
 8002f30:	4413      	add	r3, r2
 8002f32:	b29b      	uxth	r3, r3
 8002f34:	83fb      	strh	r3, [r7, #30]

      ucg_draw_circle_section(ucg, x, y, x0, y0, option);    
 8002f36:	f9b7 000a 	ldrsh.w	r0, [r7, #10]
 8002f3a:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8002f3e:	f9b7 1018 	ldrsh.w	r1, [r7, #24]
 8002f42:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8002f46:	9301      	str	r3, [sp, #4]
 8002f48:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8002f4c:	9300      	str	r3, [sp, #0]
 8002f4e:	4603      	mov	r3, r0
 8002f50:	68f8      	ldr	r0, [r7, #12]
 8002f52:	f7ff ff03 	bl	8002d5c <ucg_draw_circle_section>
    while ( x < y )
 8002f56:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 8002f5a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8002f5e:	429a      	cmp	r2, r3
 8002f60:	dbc7      	blt.n	8002ef2 <ucg_draw_circle+0x6c>
    }
}
 8002f62:	bf00      	nop
 8002f64:	bf00      	nop
 8002f66:	3720      	adds	r7, #32
 8002f68:	46bd      	mov	sp, r7
 8002f6a:	bd80      	pop	{r7, pc}

08002f6c <ucg_DrawCircle>:

void ucg_DrawCircle(ucg_t *ucg, ucg_int_t x0, ucg_int_t y0, ucg_int_t rad, uint8_t option)
{
 8002f6c:	b580      	push	{r7, lr}
 8002f6e:	b086      	sub	sp, #24
 8002f70:	af02      	add	r7, sp, #8
 8002f72:	60f8      	str	r0, [r7, #12]
 8002f74:	4608      	mov	r0, r1
 8002f76:	4611      	mov	r1, r2
 8002f78:	461a      	mov	r2, r3
 8002f7a:	4603      	mov	r3, r0
 8002f7c:	817b      	strh	r3, [r7, #10]
 8002f7e:	460b      	mov	r3, r1
 8002f80:	813b      	strh	r3, [r7, #8]
 8002f82:	4613      	mov	r3, r2
 8002f84:	80fb      	strh	r3, [r7, #6]
      return;    
  }
  */
  
  /* draw circle */
  ucg_draw_circle(ucg, x0, y0, rad, option);
 8002f86:	f9b7 0006 	ldrsh.w	r0, [r7, #6]
 8002f8a:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8002f8e:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 8002f92:	7e3b      	ldrb	r3, [r7, #24]
 8002f94:	9300      	str	r3, [sp, #0]
 8002f96:	4603      	mov	r3, r0
 8002f98:	68f8      	ldr	r0, [r7, #12]
 8002f9a:	f7ff ff74 	bl	8002e86 <ucg_draw_circle>
}
 8002f9e:	bf00      	nop
 8002fa0:	3710      	adds	r7, #16
 8002fa2:	46bd      	mov	sp, r7
 8002fa4:	bd80      	pop	{r7, pc}

08002fa6 <ucg_clip_is_x_visible>:

static ucg_int_t ucg_clip_is_x_visible(ucg_t *ucg) UCG_NOINLINE;
static ucg_int_t ucg_clip_is_y_visible(ucg_t *ucg) UCG_NOINLINE;

static ucg_int_t ucg_clip_is_x_visible(ucg_t *ucg)
{
 8002fa6:	b480      	push	{r7}
 8002fa8:	b085      	sub	sp, #20
 8002faa:	af00      	add	r7, sp, #0
 8002fac:	6078      	str	r0, [r7, #4]
  ucg_int_t t;
  t = ucg->arg.pixel.pos.x;
 8002fae:	687b      	ldr	r3, [r7, #4]
 8002fb0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8002fb2:	81fb      	strh	r3, [r7, #14]
  t -= ucg->clip_box.ul.x;
 8002fb4:	89fa      	ldrh	r2, [r7, #14]
 8002fb6:	687b      	ldr	r3, [r7, #4]
 8002fb8:	f9b3 3070 	ldrsh.w	r3, [r3, #112]	; 0x70
 8002fbc:	b29b      	uxth	r3, r3
 8002fbe:	1ad3      	subs	r3, r2, r3
 8002fc0:	b29b      	uxth	r3, r3
 8002fc2:	81fb      	strh	r3, [r7, #14]
  if ( t < 0 )
 8002fc4:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8002fc8:	2b00      	cmp	r3, #0
 8002fca:	da01      	bge.n	8002fd0 <ucg_clip_is_x_visible+0x2a>
    return 0;
 8002fcc:	2300      	movs	r3, #0
 8002fce:	e009      	b.n	8002fe4 <ucg_clip_is_x_visible+0x3e>
  if ( t >= ucg->clip_box.size.w )
 8002fd0:	687b      	ldr	r3, [r7, #4]
 8002fd2:	f9b3 3074 	ldrsh.w	r3, [r3, #116]	; 0x74
 8002fd6:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8002fda:	429a      	cmp	r2, r3
 8002fdc:	db01      	blt.n	8002fe2 <ucg_clip_is_x_visible+0x3c>
    return 0;
 8002fde:	2300      	movs	r3, #0
 8002fe0:	e000      	b.n	8002fe4 <ucg_clip_is_x_visible+0x3e>
  
  return 1;
 8002fe2:	2301      	movs	r3, #1
}
 8002fe4:	4618      	mov	r0, r3
 8002fe6:	3714      	adds	r7, #20
 8002fe8:	46bd      	mov	sp, r7
 8002fea:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002fee:	4770      	bx	lr

08002ff0 <ucg_clip_is_y_visible>:

static ucg_int_t ucg_clip_is_y_visible(ucg_t *ucg)
{
 8002ff0:	b480      	push	{r7}
 8002ff2:	b085      	sub	sp, #20
 8002ff4:	af00      	add	r7, sp, #0
 8002ff6:	6078      	str	r0, [r7, #4]
  ucg_int_t t;
  t = ucg->arg.pixel.pos.y;
 8002ff8:	687b      	ldr	r3, [r7, #4]
 8002ffa:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8002ffc:	81fb      	strh	r3, [r7, #14]
  t -= ucg->clip_box.ul.y;
 8002ffe:	89fa      	ldrh	r2, [r7, #14]
 8003000:	687b      	ldr	r3, [r7, #4]
 8003002:	f9b3 3072 	ldrsh.w	r3, [r3, #114]	; 0x72
 8003006:	b29b      	uxth	r3, r3
 8003008:	1ad3      	subs	r3, r2, r3
 800300a:	b29b      	uxth	r3, r3
 800300c:	81fb      	strh	r3, [r7, #14]
  if ( t < 0 )
 800300e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8003012:	2b00      	cmp	r3, #0
 8003014:	da01      	bge.n	800301a <ucg_clip_is_y_visible+0x2a>
    return 0;
 8003016:	2300      	movs	r3, #0
 8003018:	e009      	b.n	800302e <ucg_clip_is_y_visible+0x3e>
  if ( t >= ucg->clip_box.size.h )
 800301a:	687b      	ldr	r3, [r7, #4]
 800301c:	f9b3 3076 	ldrsh.w	r3, [r3, #118]	; 0x76
 8003020:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8003024:	429a      	cmp	r2, r3
 8003026:	db01      	blt.n	800302c <ucg_clip_is_y_visible+0x3c>
    return 0;
 8003028:	2300      	movs	r3, #0
 800302a:	e000      	b.n	800302e <ucg_clip_is_y_visible+0x3e>
  
  return 1;
 800302c:	2301      	movs	r3, #1
}
 800302e:	4618      	mov	r0, r3
 8003030:	3714      	adds	r7, #20
 8003032:	46bd      	mov	sp, r7
 8003034:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003038:	4770      	bx	lr

0800303a <ucg_clip_intersection>:
  Assumptions:
    a <= b
    c <= d
*/
static ucg_int_t ucg_clip_intersection(ucg_int_t *ap, ucg_int_t *bp, ucg_int_t c, ucg_int_t d)
{
 800303a:	b480      	push	{r7}
 800303c:	b087      	sub	sp, #28
 800303e:	af00      	add	r7, sp, #0
 8003040:	60f8      	str	r0, [r7, #12]
 8003042:	60b9      	str	r1, [r7, #8]
 8003044:	4611      	mov	r1, r2
 8003046:	461a      	mov	r2, r3
 8003048:	460b      	mov	r3, r1
 800304a:	80fb      	strh	r3, [r7, #6]
 800304c:	4613      	mov	r3, r2
 800304e:	80bb      	strh	r3, [r7, #4]
  ucg_int_t a = *ap;
 8003050:	68fb      	ldr	r3, [r7, #12]
 8003052:	881b      	ldrh	r3, [r3, #0]
 8003054:	82fb      	strh	r3, [r7, #22]
  ucg_int_t b = *bp;
 8003056:	68bb      	ldr	r3, [r7, #8]
 8003058:	881b      	ldrh	r3, [r3, #0]
 800305a:	82bb      	strh	r3, [r7, #20]
  
  if ( a >= d )
 800305c:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8003060:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8003064:	429a      	cmp	r2, r3
 8003066:	db01      	blt.n	800306c <ucg_clip_intersection+0x32>
    return 0;
 8003068:	2300      	movs	r3, #0
 800306a:	e01a      	b.n	80030a2 <ucg_clip_intersection+0x68>
  if ( b <= c )
 800306c:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 8003070:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003074:	429a      	cmp	r2, r3
 8003076:	dc01      	bgt.n	800307c <ucg_clip_intersection+0x42>
    return 0;
 8003078:	2300      	movs	r3, #0
 800307a:	e012      	b.n	80030a2 <ucg_clip_intersection+0x68>
  if ( a < c )
 800307c:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8003080:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8003084:	429a      	cmp	r2, r3
 8003086:	da02      	bge.n	800308e <ucg_clip_intersection+0x54>
    *ap = c;
 8003088:	68fb      	ldr	r3, [r7, #12]
 800308a:	88fa      	ldrh	r2, [r7, #6]
 800308c:	801a      	strh	r2, [r3, #0]
  if ( b > d )
 800308e:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 8003092:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8003096:	429a      	cmp	r2, r3
 8003098:	dd02      	ble.n	80030a0 <ucg_clip_intersection+0x66>
    *bp = d;
 800309a:	68bb      	ldr	r3, [r7, #8]
 800309c:	88ba      	ldrh	r2, [r7, #4]
 800309e:	801a      	strh	r2, [r3, #0]
  return 1;
 80030a0:	2301      	movs	r3, #1
}
 80030a2:	4618      	mov	r0, r3
 80030a4:	371c      	adds	r7, #28
 80030a6:	46bd      	mov	sp, r7
 80030a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80030ac:	4770      	bx	lr

080030ae <ucg_clip_is_pixel_visible>:

ucg_int_t ucg_clip_is_pixel_visible(ucg_t *ucg)
{
 80030ae:	b580      	push	{r7, lr}
 80030b0:	b082      	sub	sp, #8
 80030b2:	af00      	add	r7, sp, #0
 80030b4:	6078      	str	r0, [r7, #4]
  if ( ucg_clip_is_x_visible(ucg) == 0 )
 80030b6:	6878      	ldr	r0, [r7, #4]
 80030b8:	f7ff ff75 	bl	8002fa6 <ucg_clip_is_x_visible>
 80030bc:	4603      	mov	r3, r0
 80030be:	2b00      	cmp	r3, #0
 80030c0:	d101      	bne.n	80030c6 <ucg_clip_is_pixel_visible+0x18>
    return 0;
 80030c2:	2300      	movs	r3, #0
 80030c4:	e008      	b.n	80030d8 <ucg_clip_is_pixel_visible+0x2a>
  if ( ucg_clip_is_y_visible(ucg) == 0 )
 80030c6:	6878      	ldr	r0, [r7, #4]
 80030c8:	f7ff ff92 	bl	8002ff0 <ucg_clip_is_y_visible>
 80030cc:	4603      	mov	r3, r0
 80030ce:	2b00      	cmp	r3, #0
 80030d0:	d101      	bne.n	80030d6 <ucg_clip_is_pixel_visible+0x28>
    return 0;
 80030d2:	2300      	movs	r3, #0
 80030d4:	e000      	b.n	80030d8 <ucg_clip_is_pixel_visible+0x2a>
  return 1;
 80030d6:	2301      	movs	r3, #1
}
 80030d8:	4618      	mov	r0, r3
 80030da:	3708      	adds	r7, #8
 80030dc:	46bd      	mov	sp, r7
 80030de:	bd80      	pop	{r7, pc}

080030e0 <ucg_clip_l90fx>:
/*
  assumes, that ucg->arg contains data for l90fx and does clipping 
  against ucg->clip_box
*/
ucg_int_t ucg_clip_l90fx(ucg_t *ucg)
{
 80030e0:	b590      	push	{r4, r7, lr}
 80030e2:	b085      	sub	sp, #20
 80030e4:	af00      	add	r7, sp, #0
 80030e6:	6078      	str	r0, [r7, #4]
  ucg_int_t a;
  ucg_int_t b;
  ucg->arg.offset = 0;
 80030e8:	687b      	ldr	r3, [r7, #4]
 80030ea:	2200      	movs	r2, #0
 80030ec:	861a      	strh	r2, [r3, #48]	; 0x30
  switch(ucg->arg.dir)
 80030ee:	687b      	ldr	r3, [r7, #4]
 80030f0:	f9b3 302e 	ldrsh.w	r3, [r3, #46]	; 0x2e
 80030f4:	2b03      	cmp	r3, #3
 80030f6:	f200 816d 	bhi.w	80033d4 <ucg_clip_l90fx+0x2f4>
 80030fa:	a201      	add	r2, pc, #4	; (adr r2, 8003100 <ucg_clip_l90fx+0x20>)
 80030fc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003100:	08003111 	.word	0x08003111
 8003104:	080031b7 	.word	0x080031b7
 8003108:	0800325d 	.word	0x0800325d
 800310c:	08003319 	.word	0x08003319
  {
    case 0:
      if ( ucg_clip_is_y_visible(ucg) == 0 )
 8003110:	6878      	ldr	r0, [r7, #4]
 8003112:	f7ff ff6d 	bl	8002ff0 <ucg_clip_is_y_visible>
 8003116:	4603      	mov	r3, r0
 8003118:	2b00      	cmp	r3, #0
 800311a:	d101      	bne.n	8003120 <ucg_clip_l90fx+0x40>
	return 0; 
 800311c:	2300      	movs	r3, #0
 800311e:	e15a      	b.n	80033d6 <ucg_clip_l90fx+0x2f6>
      a = ucg->arg.pixel.pos.x;
 8003120:	687b      	ldr	r3, [r7, #4]
 8003122:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 8003126:	81fb      	strh	r3, [r7, #14]
      b = a;
 8003128:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800312c:	81bb      	strh	r3, [r7, #12]
      b += ucg->arg.len;
 800312e:	687b      	ldr	r3, [r7, #4]
 8003130:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
 8003134:	b29a      	uxth	r2, r3
 8003136:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800313a:	b29b      	uxth	r3, r3
 800313c:	4413      	add	r3, r2
 800313e:	b29b      	uxth	r3, r3
 8003140:	b21b      	sxth	r3, r3
 8003142:	81bb      	strh	r3, [r7, #12]
      
      if ( ucg_clip_intersection(&a, &b, ucg->clip_box.ul.x, ucg->clip_box.ul.x+ucg->clip_box.size.w) == 0 )
 8003144:	687b      	ldr	r3, [r7, #4]
 8003146:	f9b3 4070 	ldrsh.w	r4, [r3, #112]	; 0x70
 800314a:	687b      	ldr	r3, [r7, #4]
 800314c:	f9b3 3070 	ldrsh.w	r3, [r3, #112]	; 0x70
 8003150:	b29a      	uxth	r2, r3
 8003152:	687b      	ldr	r3, [r7, #4]
 8003154:	f9b3 3074 	ldrsh.w	r3, [r3, #116]	; 0x74
 8003158:	b29b      	uxth	r3, r3
 800315a:	4413      	add	r3, r2
 800315c:	b29b      	uxth	r3, r3
 800315e:	b21b      	sxth	r3, r3
 8003160:	f107 010c 	add.w	r1, r7, #12
 8003164:	f107 000e 	add.w	r0, r7, #14
 8003168:	4622      	mov	r2, r4
 800316a:	f7ff ff66 	bl	800303a <ucg_clip_intersection>
 800316e:	4603      	mov	r3, r0
 8003170:	2b00      	cmp	r3, #0
 8003172:	d101      	bne.n	8003178 <ucg_clip_l90fx+0x98>
	return 0;
 8003174:	2300      	movs	r3, #0
 8003176:	e12e      	b.n	80033d6 <ucg_clip_l90fx+0x2f6>
      
      ucg->arg.offset = a - ucg->arg.pixel.pos.x;
 8003178:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800317c:	b29a      	uxth	r2, r3
 800317e:	687b      	ldr	r3, [r7, #4]
 8003180:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 8003184:	b29b      	uxth	r3, r3
 8003186:	1ad3      	subs	r3, r2, r3
 8003188:	b29b      	uxth	r3, r3
 800318a:	b21a      	sxth	r2, r3
 800318c:	687b      	ldr	r3, [r7, #4]
 800318e:	861a      	strh	r2, [r3, #48]	; 0x30
      ucg->arg.pixel.pos.x = a;
 8003190:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8003194:	687b      	ldr	r3, [r7, #4]
 8003196:	849a      	strh	r2, [r3, #36]	; 0x24
      b -= a;
 8003198:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800319c:	b29a      	uxth	r2, r3
 800319e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80031a2:	b29b      	uxth	r3, r3
 80031a4:	1ad3      	subs	r3, r2, r3
 80031a6:	b29b      	uxth	r3, r3
 80031a8:	b21b      	sxth	r3, r3
 80031aa:	81bb      	strh	r3, [r7, #12]
      ucg->arg.len = b;
 80031ac:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 80031b0:	687b      	ldr	r3, [r7, #4]
 80031b2:	859a      	strh	r2, [r3, #44]	; 0x2c
      
      break;
 80031b4:	e10e      	b.n	80033d4 <ucg_clip_l90fx+0x2f4>
    case 1:
      if ( ucg_clip_is_x_visible(ucg) == 0 )
 80031b6:	6878      	ldr	r0, [r7, #4]
 80031b8:	f7ff fef5 	bl	8002fa6 <ucg_clip_is_x_visible>
 80031bc:	4603      	mov	r3, r0
 80031be:	2b00      	cmp	r3, #0
 80031c0:	d101      	bne.n	80031c6 <ucg_clip_l90fx+0xe6>
	return 0;
 80031c2:	2300      	movs	r3, #0
 80031c4:	e107      	b.n	80033d6 <ucg_clip_l90fx+0x2f6>
      
      a = ucg->arg.pixel.pos.y;
 80031c6:	687b      	ldr	r3, [r7, #4]
 80031c8:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
 80031cc:	81fb      	strh	r3, [r7, #14]
      b = a;
 80031ce:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80031d2:	81bb      	strh	r3, [r7, #12]
      b += ucg->arg.len;
 80031d4:	687b      	ldr	r3, [r7, #4]
 80031d6:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
 80031da:	b29a      	uxth	r2, r3
 80031dc:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80031e0:	b29b      	uxth	r3, r3
 80031e2:	4413      	add	r3, r2
 80031e4:	b29b      	uxth	r3, r3
 80031e6:	b21b      	sxth	r3, r3
 80031e8:	81bb      	strh	r3, [r7, #12]
      
      if ( ucg_clip_intersection(&a, &b, ucg->clip_box.ul.y, ucg->clip_box.ul.y+ucg->clip_box.size.h) == 0 )
 80031ea:	687b      	ldr	r3, [r7, #4]
 80031ec:	f9b3 4072 	ldrsh.w	r4, [r3, #114]	; 0x72
 80031f0:	687b      	ldr	r3, [r7, #4]
 80031f2:	f9b3 3072 	ldrsh.w	r3, [r3, #114]	; 0x72
 80031f6:	b29a      	uxth	r2, r3
 80031f8:	687b      	ldr	r3, [r7, #4]
 80031fa:	f9b3 3076 	ldrsh.w	r3, [r3, #118]	; 0x76
 80031fe:	b29b      	uxth	r3, r3
 8003200:	4413      	add	r3, r2
 8003202:	b29b      	uxth	r3, r3
 8003204:	b21b      	sxth	r3, r3
 8003206:	f107 010c 	add.w	r1, r7, #12
 800320a:	f107 000e 	add.w	r0, r7, #14
 800320e:	4622      	mov	r2, r4
 8003210:	f7ff ff13 	bl	800303a <ucg_clip_intersection>
 8003214:	4603      	mov	r3, r0
 8003216:	2b00      	cmp	r3, #0
 8003218:	d101      	bne.n	800321e <ucg_clip_l90fx+0x13e>
	return 0;
 800321a:	2300      	movs	r3, #0
 800321c:	e0db      	b.n	80033d6 <ucg_clip_l90fx+0x2f6>

      ucg->arg.offset = a - ucg->arg.pixel.pos.y;
 800321e:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8003222:	b29a      	uxth	r2, r3
 8003224:	687b      	ldr	r3, [r7, #4]
 8003226:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
 800322a:	b29b      	uxth	r3, r3
 800322c:	1ad3      	subs	r3, r2, r3
 800322e:	b29b      	uxth	r3, r3
 8003230:	b21a      	sxth	r2, r3
 8003232:	687b      	ldr	r3, [r7, #4]
 8003234:	861a      	strh	r2, [r3, #48]	; 0x30
      ucg->arg.pixel.pos.y = a;
 8003236:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 800323a:	687b      	ldr	r3, [r7, #4]
 800323c:	84da      	strh	r2, [r3, #38]	; 0x26
      b -= a;
 800323e:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8003242:	b29a      	uxth	r2, r3
 8003244:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8003248:	b29b      	uxth	r3, r3
 800324a:	1ad3      	subs	r3, r2, r3
 800324c:	b29b      	uxth	r3, r3
 800324e:	b21b      	sxth	r3, r3
 8003250:	81bb      	strh	r3, [r7, #12]
      ucg->arg.len = b;
 8003252:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8003256:	687b      	ldr	r3, [r7, #4]
 8003258:	859a      	strh	r2, [r3, #44]	; 0x2c
      
      break;
 800325a:	e0bb      	b.n	80033d4 <ucg_clip_l90fx+0x2f4>
    case 2:
      if ( ucg_clip_is_y_visible(ucg) == 0 )
 800325c:	6878      	ldr	r0, [r7, #4]
 800325e:	f7ff fec7 	bl	8002ff0 <ucg_clip_is_y_visible>
 8003262:	4603      	mov	r3, r0
 8003264:	2b00      	cmp	r3, #0
 8003266:	d101      	bne.n	800326c <ucg_clip_l90fx+0x18c>
	return 0;
 8003268:	2300      	movs	r3, #0
 800326a:	e0b4      	b.n	80033d6 <ucg_clip_l90fx+0x2f6>
      
      b = ucg->arg.pixel.pos.x;
 800326c:	687b      	ldr	r3, [r7, #4]
 800326e:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 8003272:	81bb      	strh	r3, [r7, #12]
      b++;
 8003274:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8003278:	b29b      	uxth	r3, r3
 800327a:	3301      	adds	r3, #1
 800327c:	b29b      	uxth	r3, r3
 800327e:	b21b      	sxth	r3, r3
 8003280:	81bb      	strh	r3, [r7, #12]
      
      a = b;
 8003282:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8003286:	81fb      	strh	r3, [r7, #14]
      a -= ucg->arg.len;
 8003288:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800328c:	b29a      	uxth	r2, r3
 800328e:	687b      	ldr	r3, [r7, #4]
 8003290:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
 8003294:	b29b      	uxth	r3, r3
 8003296:	1ad3      	subs	r3, r2, r3
 8003298:	b29b      	uxth	r3, r3
 800329a:	b21b      	sxth	r3, r3
 800329c:	81fb      	strh	r3, [r7, #14]
      
      
      if ( ucg_clip_intersection(&a, &b, ucg->clip_box.ul.x, ucg->clip_box.ul.x+ucg->clip_box.size.w) == 0 )
 800329e:	687b      	ldr	r3, [r7, #4]
 80032a0:	f9b3 4070 	ldrsh.w	r4, [r3, #112]	; 0x70
 80032a4:	687b      	ldr	r3, [r7, #4]
 80032a6:	f9b3 3070 	ldrsh.w	r3, [r3, #112]	; 0x70
 80032aa:	b29a      	uxth	r2, r3
 80032ac:	687b      	ldr	r3, [r7, #4]
 80032ae:	f9b3 3074 	ldrsh.w	r3, [r3, #116]	; 0x74
 80032b2:	b29b      	uxth	r3, r3
 80032b4:	4413      	add	r3, r2
 80032b6:	b29b      	uxth	r3, r3
 80032b8:	b21b      	sxth	r3, r3
 80032ba:	f107 010c 	add.w	r1, r7, #12
 80032be:	f107 000e 	add.w	r0, r7, #14
 80032c2:	4622      	mov	r2, r4
 80032c4:	f7ff feb9 	bl	800303a <ucg_clip_intersection>
 80032c8:	4603      	mov	r3, r0
 80032ca:	2b00      	cmp	r3, #0
 80032cc:	d101      	bne.n	80032d2 <ucg_clip_l90fx+0x1f2>
	return 0;
 80032ce:	2300      	movs	r3, #0
 80032d0:	e081      	b.n	80033d6 <ucg_clip_l90fx+0x2f6>
      
      ucg->arg.len = b-a;
 80032d2:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80032d6:	b29a      	uxth	r2, r3
 80032d8:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80032dc:	b29b      	uxth	r3, r3
 80032de:	1ad3      	subs	r3, r2, r3
 80032e0:	b29b      	uxth	r3, r3
 80032e2:	b21a      	sxth	r2, r3
 80032e4:	687b      	ldr	r3, [r7, #4]
 80032e6:	859a      	strh	r2, [r3, #44]	; 0x2c
      
      b--;
 80032e8:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80032ec:	b29b      	uxth	r3, r3
 80032ee:	3b01      	subs	r3, #1
 80032f0:	b29b      	uxth	r3, r3
 80032f2:	b21b      	sxth	r3, r3
 80032f4:	81bb      	strh	r3, [r7, #12]
      ucg->arg.offset = ucg->arg.pixel.pos.x-b;
 80032f6:	687b      	ldr	r3, [r7, #4]
 80032f8:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 80032fc:	b29a      	uxth	r2, r3
 80032fe:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8003302:	b29b      	uxth	r3, r3
 8003304:	1ad3      	subs	r3, r2, r3
 8003306:	b29b      	uxth	r3, r3
 8003308:	b21a      	sxth	r2, r3
 800330a:	687b      	ldr	r3, [r7, #4]
 800330c:	861a      	strh	r2, [r3, #48]	; 0x30
      ucg->arg.pixel.pos.x = b;
 800330e:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8003312:	687b      	ldr	r3, [r7, #4]
 8003314:	849a      	strh	r2, [r3, #36]	; 0x24
      
      break;
 8003316:	e05d      	b.n	80033d4 <ucg_clip_l90fx+0x2f4>
    case 3:
      if ( ucg_clip_is_x_visible(ucg) == 0 )
 8003318:	6878      	ldr	r0, [r7, #4]
 800331a:	f7ff fe44 	bl	8002fa6 <ucg_clip_is_x_visible>
 800331e:	4603      	mov	r3, r0
 8003320:	2b00      	cmp	r3, #0
 8003322:	d101      	bne.n	8003328 <ucg_clip_l90fx+0x248>
	return 0;
 8003324:	2300      	movs	r3, #0
 8003326:	e056      	b.n	80033d6 <ucg_clip_l90fx+0x2f6>

      b = ucg->arg.pixel.pos.y;
 8003328:	687b      	ldr	r3, [r7, #4]
 800332a:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
 800332e:	81bb      	strh	r3, [r7, #12]
      b++;
 8003330:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8003334:	b29b      	uxth	r3, r3
 8003336:	3301      	adds	r3, #1
 8003338:	b29b      	uxth	r3, r3
 800333a:	b21b      	sxth	r3, r3
 800333c:	81bb      	strh	r3, [r7, #12]
      
      a = b;
 800333e:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8003342:	81fb      	strh	r3, [r7, #14]
      a -= ucg->arg.len;
 8003344:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8003348:	b29a      	uxth	r2, r3
 800334a:	687b      	ldr	r3, [r7, #4]
 800334c:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
 8003350:	b29b      	uxth	r3, r3
 8003352:	1ad3      	subs	r3, r2, r3
 8003354:	b29b      	uxth	r3, r3
 8003356:	b21b      	sxth	r3, r3
 8003358:	81fb      	strh	r3, [r7, #14]
      
      
      if ( ucg_clip_intersection(&a, &b, ucg->clip_box.ul.y, ucg->clip_box.ul.y+ucg->clip_box.size.h) == 0 )
 800335a:	687b      	ldr	r3, [r7, #4]
 800335c:	f9b3 4072 	ldrsh.w	r4, [r3, #114]	; 0x72
 8003360:	687b      	ldr	r3, [r7, #4]
 8003362:	f9b3 3072 	ldrsh.w	r3, [r3, #114]	; 0x72
 8003366:	b29a      	uxth	r2, r3
 8003368:	687b      	ldr	r3, [r7, #4]
 800336a:	f9b3 3076 	ldrsh.w	r3, [r3, #118]	; 0x76
 800336e:	b29b      	uxth	r3, r3
 8003370:	4413      	add	r3, r2
 8003372:	b29b      	uxth	r3, r3
 8003374:	b21b      	sxth	r3, r3
 8003376:	f107 010c 	add.w	r1, r7, #12
 800337a:	f107 000e 	add.w	r0, r7, #14
 800337e:	4622      	mov	r2, r4
 8003380:	f7ff fe5b 	bl	800303a <ucg_clip_intersection>
 8003384:	4603      	mov	r3, r0
 8003386:	2b00      	cmp	r3, #0
 8003388:	d101      	bne.n	800338e <ucg_clip_l90fx+0x2ae>
	return 0;
 800338a:	2300      	movs	r3, #0
 800338c:	e023      	b.n	80033d6 <ucg_clip_l90fx+0x2f6>
      
      ucg->arg.len = b-a;
 800338e:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8003392:	b29a      	uxth	r2, r3
 8003394:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8003398:	b29b      	uxth	r3, r3
 800339a:	1ad3      	subs	r3, r2, r3
 800339c:	b29b      	uxth	r3, r3
 800339e:	b21a      	sxth	r2, r3
 80033a0:	687b      	ldr	r3, [r7, #4]
 80033a2:	859a      	strh	r2, [r3, #44]	; 0x2c
      
      b--;
 80033a4:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80033a8:	b29b      	uxth	r3, r3
 80033aa:	3b01      	subs	r3, #1
 80033ac:	b29b      	uxth	r3, r3
 80033ae:	b21b      	sxth	r3, r3
 80033b0:	81bb      	strh	r3, [r7, #12]
      ucg->arg.offset = ucg->arg.pixel.pos.y-b;
 80033b2:	687b      	ldr	r3, [r7, #4]
 80033b4:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
 80033b8:	b29a      	uxth	r2, r3
 80033ba:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80033be:	b29b      	uxth	r3, r3
 80033c0:	1ad3      	subs	r3, r2, r3
 80033c2:	b29b      	uxth	r3, r3
 80033c4:	b21a      	sxth	r2, r3
 80033c6:	687b      	ldr	r3, [r7, #4]
 80033c8:	861a      	strh	r2, [r3, #48]	; 0x30
      ucg->arg.pixel.pos.y = b;
 80033ca:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 80033ce:	687b      	ldr	r3, [r7, #4]
 80033d0:	84da      	strh	r2, [r3, #38]	; 0x26
      
      
      break;
 80033d2:	bf00      	nop
  }

  return 1;
 80033d4:	2301      	movs	r3, #1
}
 80033d6:	4618      	mov	r0, r3
 80033d8:	3714      	adds	r7, #20
 80033da:	46bd      	mov	sp, r7
 80033dc:	bd90      	pop	{r4, r7, pc}
 80033de:	bf00      	nop

080033e0 <ucg_clip_l90se>:
  return 1;
}
*/

ucg_int_t ucg_clip_l90se(ucg_t *ucg)
{
 80033e0:	b580      	push	{r7, lr}
 80033e2:	b084      	sub	sp, #16
 80033e4:	af00      	add	r7, sp, #0
 80033e6:	6078      	str	r0, [r7, #4]
  uint8_t i;
  if ( ucg_clip_l90fx(ucg) == 0 )
 80033e8:	6878      	ldr	r0, [r7, #4]
 80033ea:	f7ff fe79 	bl	80030e0 <ucg_clip_l90fx>
 80033ee:	4603      	mov	r3, r0
 80033f0:	2b00      	cmp	r3, #0
 80033f2:	d101      	bne.n	80033f8 <ucg_clip_l90se+0x18>
      return 0;
 80033f4:	2300      	movs	r3, #0
 80033f6:	e019      	b.n	800342c <ucg_clip_l90se+0x4c>
  for ( i = 0; i < 3; i++ )
 80033f8:	2300      	movs	r3, #0
 80033fa:	73fb      	strb	r3, [r7, #15]
 80033fc:	e012      	b.n	8003424 <ucg_clip_l90se+0x44>
  {
    ucg_ccs_seek(ucg->arg.ccs_line+i, ucg->arg.offset);
 80033fe:	687b      	ldr	r3, [r7, #4]
 8003400:	f103 0146 	add.w	r1, r3, #70	; 0x46
 8003404:	7bfa      	ldrb	r2, [r7, #15]
 8003406:	4613      	mov	r3, r2
 8003408:	00db      	lsls	r3, r3, #3
 800340a:	1a9b      	subs	r3, r3, r2
 800340c:	005b      	lsls	r3, r3, #1
 800340e:	18ca      	adds	r2, r1, r3
 8003410:	687b      	ldr	r3, [r7, #4]
 8003412:	f9b3 3030 	ldrsh.w	r3, [r3, #48]	; 0x30
 8003416:	4619      	mov	r1, r3
 8003418:	4610      	mov	r0, r2
 800341a:	f7ff fc3a 	bl	8002c92 <ucg_ccs_seek>
  for ( i = 0; i < 3; i++ )
 800341e:	7bfb      	ldrb	r3, [r7, #15]
 8003420:	3301      	adds	r3, #1
 8003422:	73fb      	strb	r3, [r7, #15]
 8003424:	7bfb      	ldrb	r3, [r7, #15]
 8003426:	2b02      	cmp	r3, #2
 8003428:	d9e9      	bls.n	80033fe <ucg_clip_l90se+0x1e>
  }  
  return 1;
 800342a:	2301      	movs	r3, #1
}
 800342c:	4618      	mov	r0, r3
 800342e:	3710      	adds	r7, #16
 8003430:	46bd      	mov	sp, r7
 8003432:	bd80      	pop	{r7, pc}

08003434 <ucg_com_PowerDown>:
  return 1;
}


void ucg_com_PowerDown(ucg_t *ucg)
{
 8003434:	b590      	push	{r4, r7, lr}
 8003436:	b083      	sub	sp, #12
 8003438:	af00      	add	r7, sp, #0
 800343a:	6078      	str	r0, [r7, #4]
  if ( (ucg->com_status & UCG_COM_STATUS_MASK_POWER) != 0 )
 800343c:	687b      	ldr	r3, [r7, #4]
 800343e:	f893 30af 	ldrb.w	r3, [r3, #175]	; 0xaf
 8003442:	f003 0308 	and.w	r3, r3, #8
 8003446:	2b00      	cmp	r3, #0
 8003448:	d006      	beq.n	8003458 <ucg_com_PowerDown+0x24>
    ucg->com_cb(ucg, UCG_COM_MSG_POWER_DOWN, 0, NULL);
 800344a:	687b      	ldr	r3, [r7, #4]
 800344c:	69dc      	ldr	r4, [r3, #28]
 800344e:	2300      	movs	r3, #0
 8003450:	2200      	movs	r2, #0
 8003452:	210b      	movs	r1, #11
 8003454:	6878      	ldr	r0, [r7, #4]
 8003456:	47a0      	blx	r4
  ucg->com_status &= ~UCG_COM_STATUS_MASK_POWER;
 8003458:	687b      	ldr	r3, [r7, #4]
 800345a:	f893 30af 	ldrb.w	r3, [r3, #175]	; 0xaf
 800345e:	f023 0308 	bic.w	r3, r3, #8
 8003462:	b2da      	uxtb	r2, r3
 8003464:	687b      	ldr	r3, [r7, #4]
 8003466:	f883 20af 	strb.w	r2, [r3, #175]	; 0xaf
}
 800346a:	bf00      	nop
 800346c:	370c      	adds	r7, #12
 800346e:	46bd      	mov	sp, r7
 8003470:	bd90      	pop	{r4, r7, pc}

08003472 <ucg_com_PowerUp>:

/*
  clk_speed in nano-seconds, range: 0..4095
*/
int16_t ucg_com_PowerUp(ucg_t *ucg, uint16_t serial_clk_speed, uint16_t parallel_clk_speed)
{
 8003472:	b590      	push	{r4, r7, lr}
 8003474:	b085      	sub	sp, #20
 8003476:	af00      	add	r7, sp, #0
 8003478:	6078      	str	r0, [r7, #4]
 800347a:	460b      	mov	r3, r1
 800347c:	807b      	strh	r3, [r7, #2]
 800347e:	4613      	mov	r3, r2
 8003480:	803b      	strh	r3, [r7, #0]
  int16_t r;
  ucg_com_info_t com_info;
  com_info.serial_clk_speed = serial_clk_speed;
 8003482:	887b      	ldrh	r3, [r7, #2]
 8003484:	813b      	strh	r3, [r7, #8]
  com_info.parallel_clk_speed = parallel_clk_speed;
 8003486:	883b      	ldrh	r3, [r7, #0]
 8003488:	817b      	strh	r3, [r7, #10]
  
  ucg_com_PowerDown(ucg);  
 800348a:	6878      	ldr	r0, [r7, #4]
 800348c:	f7ff ffd2 	bl	8003434 <ucg_com_PowerDown>
  ucg->com_initial_change_sent = 0;
 8003490:	687b      	ldr	r3, [r7, #4]
 8003492:	2200      	movs	r2, #0
 8003494:	f883 20ae 	strb.w	r2, [r3, #174]	; 0xae
  r = ucg->com_cb(ucg, UCG_COM_MSG_POWER_UP, 0UL, (uint8_t *)&com_info);
 8003498:	687b      	ldr	r3, [r7, #4]
 800349a:	69dc      	ldr	r4, [r3, #28]
 800349c:	f107 0308 	add.w	r3, r7, #8
 80034a0:	2200      	movs	r2, #0
 80034a2:	210a      	movs	r1, #10
 80034a4:	6878      	ldr	r0, [r7, #4]
 80034a6:	47a0      	blx	r4
 80034a8:	4603      	mov	r3, r0
 80034aa:	81fb      	strh	r3, [r7, #14]
  if ( r != 0 )
 80034ac:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80034b0:	2b00      	cmp	r3, #0
 80034b2:	d008      	beq.n	80034c6 <ucg_com_PowerUp+0x54>
  {
    ucg->com_status |= UCG_COM_STATUS_MASK_POWER;
 80034b4:	687b      	ldr	r3, [r7, #4]
 80034b6:	f893 30af 	ldrb.w	r3, [r3, #175]	; 0xaf
 80034ba:	f043 0308 	orr.w	r3, r3, #8
 80034be:	b2da      	uxtb	r2, r3
 80034c0:	687b      	ldr	r3, [r7, #4]
 80034c2:	f883 20af 	strb.w	r2, [r3, #175]	; 0xaf
  }
  return r;
 80034c6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
 80034ca:	4618      	mov	r0, r3
 80034cc:	3714      	adds	r7, #20
 80034ce:	46bd      	mov	sp, r7
 80034d0:	bd90      	pop	{r4, r7, pc}

080034d2 <ucg_com_SetLineStatus>:

void ucg_com_SetLineStatus(ucg_t *ucg, uint8_t level, uint8_t mask, uint8_t msg)
{
 80034d2:	b590      	push	{r4, r7, lr}
 80034d4:	b083      	sub	sp, #12
 80034d6:	af00      	add	r7, sp, #0
 80034d8:	6078      	str	r0, [r7, #4]
 80034da:	4608      	mov	r0, r1
 80034dc:	4611      	mov	r1, r2
 80034de:	461a      	mov	r2, r3
 80034e0:	4603      	mov	r3, r0
 80034e2:	70fb      	strb	r3, [r7, #3]
 80034e4:	460b      	mov	r3, r1
 80034e6:	70bb      	strb	r3, [r7, #2]
 80034e8:	4613      	mov	r3, r2
 80034ea:	707b      	strb	r3, [r7, #1]
  if ( level == 0 )
 80034ec:	78fb      	ldrb	r3, [r7, #3]
 80034ee:	2b00      	cmp	r3, #0
 80034f0:	d131      	bne.n	8003556 <ucg_com_SetLineStatus+0x84>
  {
    if ( (ucg->com_initial_change_sent & mask) == 0 || (ucg->com_status & mask) == mask )
 80034f2:	687b      	ldr	r3, [r7, #4]
 80034f4:	f893 20ae 	ldrb.w	r2, [r3, #174]	; 0xae
 80034f8:	78bb      	ldrb	r3, [r7, #2]
 80034fa:	4013      	ands	r3, r2
 80034fc:	b2db      	uxtb	r3, r3
 80034fe:	2b00      	cmp	r3, #0
 8003500:	d008      	beq.n	8003514 <ucg_com_SetLineStatus+0x42>
 8003502:	687b      	ldr	r3, [r7, #4]
 8003504:	f893 20af 	ldrb.w	r2, [r3, #175]	; 0xaf
 8003508:	78bb      	ldrb	r3, [r7, #2]
 800350a:	4013      	ands	r3, r2
 800350c:	b2db      	uxtb	r3, r3
 800350e:	78ba      	ldrb	r2, [r7, #2]
 8003510:	429a      	cmp	r2, r3
 8003512:	d14b      	bne.n	80035ac <ucg_com_SetLineStatus+0xda>
    {
      ucg->com_cb(ucg, msg, level, NULL);
 8003514:	687b      	ldr	r3, [r7, #4]
 8003516:	69dc      	ldr	r4, [r3, #28]
 8003518:	787b      	ldrb	r3, [r7, #1]
 800351a:	b219      	sxth	r1, r3
 800351c:	78fb      	ldrb	r3, [r7, #3]
 800351e:	b29a      	uxth	r2, r3
 8003520:	2300      	movs	r3, #0
 8003522:	6878      	ldr	r0, [r7, #4]
 8003524:	47a0      	blx	r4
      ucg->com_status &= ~mask;
 8003526:	687b      	ldr	r3, [r7, #4]
 8003528:	f893 30af 	ldrb.w	r3, [r3, #175]	; 0xaf
 800352c:	b25a      	sxtb	r2, r3
 800352e:	f997 3002 	ldrsb.w	r3, [r7, #2]
 8003532:	43db      	mvns	r3, r3
 8003534:	b25b      	sxtb	r3, r3
 8003536:	4013      	ands	r3, r2
 8003538:	b25b      	sxtb	r3, r3
 800353a:	b2da      	uxtb	r2, r3
 800353c:	687b      	ldr	r3, [r7, #4]
 800353e:	f883 20af 	strb.w	r2, [r3, #175]	; 0xaf
      ucg->com_initial_change_sent |= mask;
 8003542:	687b      	ldr	r3, [r7, #4]
 8003544:	f893 20ae 	ldrb.w	r2, [r3, #174]	; 0xae
 8003548:	78bb      	ldrb	r3, [r7, #2]
 800354a:	4313      	orrs	r3, r2
 800354c:	b2da      	uxtb	r2, r3
 800354e:	687b      	ldr	r3, [r7, #4]
 8003550:	f883 20ae 	strb.w	r2, [r3, #174]	; 0xae
      ucg->com_cb(ucg, msg, level, NULL);
      ucg->com_status |= mask;
      ucg->com_initial_change_sent |= mask;
    }
  }
}
 8003554:	e02a      	b.n	80035ac <ucg_com_SetLineStatus+0xda>
    if ( (ucg->com_initial_change_sent & mask) == 0 || (ucg->com_status & mask) == 0 )
 8003556:	687b      	ldr	r3, [r7, #4]
 8003558:	f893 20ae 	ldrb.w	r2, [r3, #174]	; 0xae
 800355c:	78bb      	ldrb	r3, [r7, #2]
 800355e:	4013      	ands	r3, r2
 8003560:	b2db      	uxtb	r3, r3
 8003562:	2b00      	cmp	r3, #0
 8003564:	d007      	beq.n	8003576 <ucg_com_SetLineStatus+0xa4>
 8003566:	687b      	ldr	r3, [r7, #4]
 8003568:	f893 20af 	ldrb.w	r2, [r3, #175]	; 0xaf
 800356c:	78bb      	ldrb	r3, [r7, #2]
 800356e:	4013      	ands	r3, r2
 8003570:	b2db      	uxtb	r3, r3
 8003572:	2b00      	cmp	r3, #0
 8003574:	d11a      	bne.n	80035ac <ucg_com_SetLineStatus+0xda>
      ucg->com_cb(ucg, msg, level, NULL);
 8003576:	687b      	ldr	r3, [r7, #4]
 8003578:	69dc      	ldr	r4, [r3, #28]
 800357a:	787b      	ldrb	r3, [r7, #1]
 800357c:	b219      	sxth	r1, r3
 800357e:	78fb      	ldrb	r3, [r7, #3]
 8003580:	b29a      	uxth	r2, r3
 8003582:	2300      	movs	r3, #0
 8003584:	6878      	ldr	r0, [r7, #4]
 8003586:	47a0      	blx	r4
      ucg->com_status |= mask;
 8003588:	687b      	ldr	r3, [r7, #4]
 800358a:	f893 20af 	ldrb.w	r2, [r3, #175]	; 0xaf
 800358e:	78bb      	ldrb	r3, [r7, #2]
 8003590:	4313      	orrs	r3, r2
 8003592:	b2da      	uxtb	r2, r3
 8003594:	687b      	ldr	r3, [r7, #4]
 8003596:	f883 20af 	strb.w	r2, [r3, #175]	; 0xaf
      ucg->com_initial_change_sent |= mask;
 800359a:	687b      	ldr	r3, [r7, #4]
 800359c:	f893 20ae 	ldrb.w	r2, [r3, #174]	; 0xae
 80035a0:	78bb      	ldrb	r3, [r7, #2]
 80035a2:	4313      	orrs	r3, r2
 80035a4:	b2da      	uxtb	r2, r3
 80035a6:	687b      	ldr	r3, [r7, #4]
 80035a8:	f883 20ae 	strb.w	r2, [r3, #174]	; 0xae
}
 80035ac:	bf00      	nop
 80035ae:	370c      	adds	r7, #12
 80035b0:	46bd      	mov	sp, r7
 80035b2:	bd90      	pop	{r4, r7, pc}

080035b4 <ucg_com_SetResetLineStatus>:

void ucg_com_SetResetLineStatus(ucg_t *ucg, uint8_t level)
{
 80035b4:	b580      	push	{r7, lr}
 80035b6:	b082      	sub	sp, #8
 80035b8:	af00      	add	r7, sp, #0
 80035ba:	6078      	str	r0, [r7, #4]
 80035bc:	460b      	mov	r3, r1
 80035be:	70fb      	strb	r3, [r7, #3]
  ucg_com_SetLineStatus(ucg, level, UCG_COM_STATUS_MASK_RESET, UCG_COM_MSG_CHANGE_RESET_LINE);
 80035c0:	78f9      	ldrb	r1, [r7, #3]
 80035c2:	230d      	movs	r3, #13
 80035c4:	2204      	movs	r2, #4
 80035c6:	6878      	ldr	r0, [r7, #4]
 80035c8:	f7ff ff83 	bl	80034d2 <ucg_com_SetLineStatus>
}
 80035cc:	bf00      	nop
 80035ce:	3708      	adds	r7, #8
 80035d0:	46bd      	mov	sp, r7
 80035d2:	bd80      	pop	{r7, pc}

080035d4 <ucg_com_SetCSLineStatus>:

void ucg_com_SetCSLineStatus(ucg_t *ucg, uint8_t level)
{
 80035d4:	b580      	push	{r7, lr}
 80035d6:	b082      	sub	sp, #8
 80035d8:	af00      	add	r7, sp, #0
 80035da:	6078      	str	r0, [r7, #4]
 80035dc:	460b      	mov	r3, r1
 80035de:	70fb      	strb	r3, [r7, #3]
  ucg_com_SetLineStatus(ucg, level, UCG_COM_STATUS_MASK_CS, UCG_COM_MSG_CHANGE_CS_LINE);
 80035e0:	78f9      	ldrb	r1, [r7, #3]
 80035e2:	230e      	movs	r3, #14
 80035e4:	2202      	movs	r2, #2
 80035e6:	6878      	ldr	r0, [r7, #4]
 80035e8:	f7ff ff73 	bl	80034d2 <ucg_com_SetLineStatus>
}
 80035ec:	bf00      	nop
 80035ee:	3708      	adds	r7, #8
 80035f0:	46bd      	mov	sp, r7
 80035f2:	bd80      	pop	{r7, pc}

080035f4 <ucg_com_SetCDLineStatus>:

void ucg_com_SetCDLineStatus(ucg_t *ucg, uint8_t level)
{
 80035f4:	b580      	push	{r7, lr}
 80035f6:	b082      	sub	sp, #8
 80035f8:	af00      	add	r7, sp, #0
 80035fa:	6078      	str	r0, [r7, #4]
 80035fc:	460b      	mov	r3, r1
 80035fe:	70fb      	strb	r3, [r7, #3]
  ucg_com_SetLineStatus(ucg, level, UCG_COM_STATUS_MASK_CD, UCG_COM_MSG_CHANGE_CD_LINE);
 8003600:	78f9      	ldrb	r1, [r7, #3]
 8003602:	230f      	movs	r3, #15
 8003604:	2201      	movs	r2, #1
 8003606:	6878      	ldr	r0, [r7, #4]
 8003608:	f7ff ff63 	bl	80034d2 <ucg_com_SetLineStatus>
}
 800360c:	bf00      	nop
 800360e:	3708      	adds	r7, #8
 8003610:	46bd      	mov	sp, r7
 8003612:	bd80      	pop	{r7, pc}

08003614 <ucg_com_DelayMicroseconds>:

/* delay in microseconds */
void ucg_com_DelayMicroseconds(ucg_t *ucg, uint16_t delay)
{
 8003614:	b590      	push	{r4, r7, lr}
 8003616:	b083      	sub	sp, #12
 8003618:	af00      	add	r7, sp, #0
 800361a:	6078      	str	r0, [r7, #4]
 800361c:	460b      	mov	r3, r1
 800361e:	807b      	strh	r3, [r7, #2]
  ucg->com_cb(ucg, UCG_COM_MSG_DELAY, delay, NULL);
 8003620:	687b      	ldr	r3, [r7, #4]
 8003622:	69dc      	ldr	r4, [r3, #28]
 8003624:	887a      	ldrh	r2, [r7, #2]
 8003626:	2300      	movs	r3, #0
 8003628:	210c      	movs	r1, #12
 800362a:	6878      	ldr	r0, [r7, #4]
 800362c:	47a0      	blx	r4
}
 800362e:	bf00      	nop
 8003630:	370c      	adds	r7, #12
 8003632:	46bd      	mov	sp, r7
 8003634:	bd90      	pop	{r4, r7, pc}

08003636 <ucg_com_DelayMilliseconds>:

/* delay in milliseconds */
void ucg_com_DelayMilliseconds(ucg_t *ucg, uint16_t delay)
{
 8003636:	b580      	push	{r7, lr}
 8003638:	b082      	sub	sp, #8
 800363a:	af00      	add	r7, sp, #0
 800363c:	6078      	str	r0, [r7, #4]
 800363e:	460b      	mov	r3, r1
 8003640:	807b      	strh	r3, [r7, #2]
  while( delay > 0 )
 8003642:	e007      	b.n	8003654 <ucg_com_DelayMilliseconds+0x1e>
  {
    ucg_com_DelayMicroseconds(ucg, 1000);
 8003644:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8003648:	6878      	ldr	r0, [r7, #4]
 800364a:	f7ff ffe3 	bl	8003614 <ucg_com_DelayMicroseconds>
    delay--;
 800364e:	887b      	ldrh	r3, [r7, #2]
 8003650:	3b01      	subs	r3, #1
 8003652:	807b      	strh	r3, [r7, #2]
  while( delay > 0 )
 8003654:	887b      	ldrh	r3, [r7, #2]
 8003656:	2b00      	cmp	r3, #0
 8003658:	d1f4      	bne.n	8003644 <ucg_com_DelayMilliseconds+0xe>
  }
}
 800365a:	bf00      	nop
 800365c:	bf00      	nop
 800365e:	3708      	adds	r7, #8
 8003660:	46bd      	mov	sp, r7
 8003662:	bd80      	pop	{r7, pc}

08003664 <ucg_com_SendByte>:


#ifndef ucg_com_SendByte
void ucg_com_SendByte(ucg_t *ucg, uint8_t byte)
{
 8003664:	b590      	push	{r4, r7, lr}
 8003666:	b083      	sub	sp, #12
 8003668:	af00      	add	r7, sp, #0
 800366a:	6078      	str	r0, [r7, #4]
 800366c:	460b      	mov	r3, r1
 800366e:	70fb      	strb	r3, [r7, #3]
  ucg->com_cb(ucg, UCG_COM_MSG_SEND_BYTE, byte, NULL);
 8003670:	687b      	ldr	r3, [r7, #4]
 8003672:	69dc      	ldr	r4, [r3, #28]
 8003674:	78fb      	ldrb	r3, [r7, #3]
 8003676:	b29a      	uxth	r2, r3
 8003678:	2300      	movs	r3, #0
 800367a:	2110      	movs	r1, #16
 800367c:	6878      	ldr	r0, [r7, #4]
 800367e:	47a0      	blx	r4
}
 8003680:	bf00      	nop
 8003682:	370c      	adds	r7, #12
 8003684:	46bd      	mov	sp, r7
 8003686:	bd90      	pop	{r4, r7, pc}

08003688 <ucg_com_SendStringP>:
{
  ucg->com_cb(ucg, UCG_COM_MSG_SEND_STR, cnt, (uint8_t *)byte_ptr);
}

void ucg_com_SendStringP(ucg_t *ucg, uint16_t cnt, const ucg_pgm_uint8_t *byte_ptr)
{
 8003688:	b590      	push	{r4, r7, lr}
 800368a:	b087      	sub	sp, #28
 800368c:	af00      	add	r7, sp, #0
 800368e:	60f8      	str	r0, [r7, #12]
 8003690:	460b      	mov	r3, r1
 8003692:	607a      	str	r2, [r7, #4]
 8003694:	817b      	strh	r3, [r7, #10]
  uint8_t b;
  while( cnt > 0 )
 8003696:	e010      	b.n	80036ba <ucg_com_SendStringP+0x32>
  {
    b = ucg_pgm_read(byte_ptr);
 8003698:	687b      	ldr	r3, [r7, #4]
 800369a:	781b      	ldrb	r3, [r3, #0]
 800369c:	75fb      	strb	r3, [r7, #23]
    //b = *byte_ptr;
    ucg->com_cb(ucg, UCG_COM_MSG_SEND_BYTE, b, NULL);
 800369e:	68fb      	ldr	r3, [r7, #12]
 80036a0:	69dc      	ldr	r4, [r3, #28]
 80036a2:	7dfb      	ldrb	r3, [r7, #23]
 80036a4:	b29a      	uxth	r2, r3
 80036a6:	2300      	movs	r3, #0
 80036a8:	2110      	movs	r1, #16
 80036aa:	68f8      	ldr	r0, [r7, #12]
 80036ac:	47a0      	blx	r4
    byte_ptr++;
 80036ae:	687b      	ldr	r3, [r7, #4]
 80036b0:	3301      	adds	r3, #1
 80036b2:	607b      	str	r3, [r7, #4]
    cnt--;
 80036b4:	897b      	ldrh	r3, [r7, #10]
 80036b6:	3b01      	subs	r3, #1
 80036b8:	817b      	strh	r3, [r7, #10]
  while( cnt > 0 )
 80036ba:	897b      	ldrh	r3, [r7, #10]
 80036bc:	2b00      	cmp	r3, #0
 80036be:	d1eb      	bne.n	8003698 <ucg_com_SendStringP+0x10>
  }
}
 80036c0:	bf00      	nop
 80036c2:	bf00      	nop
 80036c4:	371c      	adds	r7, #28
 80036c6:	46bd      	mov	sp, r7
 80036c8:	bd90      	pop	{r4, r7, pc}

080036ca <ucg_com_SendCmdArg>:
#define END()					0x00

*/

static void ucg_com_SendCmdArg(ucg_t *ucg, const ucg_pgm_uint8_t *data, uint8_t cmd_cnt, uint8_t arg_cnt)
{
 80036ca:	b580      	push	{r7, lr}
 80036cc:	b084      	sub	sp, #16
 80036ce:	af00      	add	r7, sp, #0
 80036d0:	60f8      	str	r0, [r7, #12]
 80036d2:	60b9      	str	r1, [r7, #8]
 80036d4:	4611      	mov	r1, r2
 80036d6:	461a      	mov	r2, r3
 80036d8:	460b      	mov	r3, r1
 80036da:	71fb      	strb	r3, [r7, #7]
 80036dc:	4613      	mov	r3, r2
 80036de:	71bb      	strb	r3, [r7, #6]
  ucg_com_SetCDLineStatus(ucg, (ucg->com_cfg_cd>>1)&1 );
 80036e0:	68fb      	ldr	r3, [r7, #12]
 80036e2:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 80036e6:	085b      	lsrs	r3, r3, #1
 80036e8:	b2db      	uxtb	r3, r3
 80036ea:	f003 0301 	and.w	r3, r3, #1
 80036ee:	b2db      	uxtb	r3, r3
 80036f0:	4619      	mov	r1, r3
 80036f2:	68f8      	ldr	r0, [r7, #12]
 80036f4:	f7ff ff7e 	bl	80035f4 <ucg_com_SetCDLineStatus>
  ucg_com_SendStringP(ucg, cmd_cnt, data);
 80036f8:	79fb      	ldrb	r3, [r7, #7]
 80036fa:	b29b      	uxth	r3, r3
 80036fc:	68ba      	ldr	r2, [r7, #8]
 80036fe:	4619      	mov	r1, r3
 8003700:	68f8      	ldr	r0, [r7, #12]
 8003702:	f7ff ffc1 	bl	8003688 <ucg_com_SendStringP>
  if ( arg_cnt > 0 )
 8003706:	79bb      	ldrb	r3, [r7, #6]
 8003708:	2b00      	cmp	r3, #0
 800370a:	d014      	beq.n	8003736 <ucg_com_SendCmdArg+0x6c>
  {
    data += cmd_cnt;
 800370c:	79fb      	ldrb	r3, [r7, #7]
 800370e:	68ba      	ldr	r2, [r7, #8]
 8003710:	4413      	add	r3, r2
 8003712:	60bb      	str	r3, [r7, #8]
    ucg_com_SetCDLineStatus(ucg, (ucg->com_cfg_cd)&1 );
 8003714:	68fb      	ldr	r3, [r7, #12]
 8003716:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 800371a:	f003 0301 	and.w	r3, r3, #1
 800371e:	b2db      	uxtb	r3, r3
 8003720:	4619      	mov	r1, r3
 8003722:	68f8      	ldr	r0, [r7, #12]
 8003724:	f7ff ff66 	bl	80035f4 <ucg_com_SetCDLineStatus>
    ucg_com_SendStringP(ucg, arg_cnt, data);
 8003728:	79bb      	ldrb	r3, [r7, #6]
 800372a:	b29b      	uxth	r3, r3
 800372c:	68ba      	ldr	r2, [r7, #8]
 800372e:	4619      	mov	r1, r3
 8003730:	68f8      	ldr	r0, [r7, #12]
 8003732:	f7ff ffa9 	bl	8003688 <ucg_com_SendStringP>
  }
}
 8003736:	bf00      	nop
 8003738:	3710      	adds	r7, #16
 800373a:	46bd      	mov	sp, r7
 800373c:	bd80      	pop	{r7, pc}
	...

08003740 <ucg_com_SendCmdSeq>:


//void ucg_com_SendCmdSeq(ucg_t *ucg, const ucg_pgm_uint8_t *data)
void ucg_com_SendCmdSeq(ucg_t *ucg, const ucg_pgm_uint8_t *data)
{
 8003740:	b580      	push	{r7, lr}
 8003742:	b084      	sub	sp, #16
 8003744:	af00      	add	r7, sp, #0
 8003746:	6078      	str	r0, [r7, #4]
 8003748:	6039      	str	r1, [r7, #0]
  uint8_t hi;
  uint8_t lo;

  for(;;)
  {
    b = ucg_pgm_read(data);
 800374a:	683b      	ldr	r3, [r7, #0]
 800374c:	781b      	ldrb	r3, [r3, #0]
 800374e:	73fb      	strb	r3, [r7, #15]
    //b = *data;
    hi = (b) >> 4;
 8003750:	7bfb      	ldrb	r3, [r7, #15]
 8003752:	091b      	lsrs	r3, r3, #4
 8003754:	73bb      	strb	r3, [r7, #14]
    lo = (b) & 0x0f;
 8003756:	7bfb      	ldrb	r3, [r7, #15]
 8003758:	f003 030f 	and.w	r3, r3, #15
 800375c:	737b      	strb	r3, [r7, #13]
    switch( hi )
 800375e:	7bbb      	ldrb	r3, [r7, #14]
 8003760:	2b0f      	cmp	r3, #15
 8003762:	f200 8127 	bhi.w	80039b4 <ucg_com_SendCmdSeq+0x274>
 8003766:	a201      	add	r2, pc, #4	; (adr r2, 800376c <ucg_com_SendCmdSeq+0x2c>)
 8003768:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800376c:	080039b5 	.word	0x080039b5
 8003770:	080037ad 	.word	0x080037ad
 8003774:	080037ad 	.word	0x080037ad
 8003778:	080037ad 	.word	0x080037ad
 800377c:	080039b5 	.word	0x080039b5
 8003780:	080039b5 	.word	0x080039b5
 8003784:	080037cd 	.word	0x080037cd
 8003788:	080037ff 	.word	0x080037ff
 800378c:	08003843 	.word	0x08003843
 8003790:	0800386f 	.word	0x0800386f
 8003794:	0800389b 	.word	0x0800389b
 8003798:	080038fb 	.word	0x080038fb
 800379c:	080039b5 	.word	0x080039b5
 80037a0:	080039b5 	.word	0x080039b5
 80037a4:	080039b5 	.word	0x080039b5
 80037a8:	0800395b 	.word	0x0800395b
      case 0:
	return;		/* end marker */
      case 1:
      case 2:
      case 3:
	ucg_com_SendCmdArg(ucg, data+1, hi, lo);
 80037ac:	683b      	ldr	r3, [r7, #0]
 80037ae:	1c59      	adds	r1, r3, #1
 80037b0:	7b7b      	ldrb	r3, [r7, #13]
 80037b2:	7bba      	ldrb	r2, [r7, #14]
 80037b4:	6878      	ldr	r0, [r7, #4]
 80037b6:	f7ff ff88 	bl	80036ca <ucg_com_SendCmdArg>
	data+=1+hi+lo;
 80037ba:	7bbb      	ldrb	r3, [r7, #14]
 80037bc:	1c5a      	adds	r2, r3, #1
 80037be:	7b7b      	ldrb	r3, [r7, #13]
 80037c0:	4413      	add	r3, r2
 80037c2:	461a      	mov	r2, r3
 80037c4:	683b      	ldr	r3, [r7, #0]
 80037c6:	4413      	add	r3, r2
 80037c8:	603b      	str	r3, [r7, #0]
	break;
 80037ca:	e0f2      	b.n	80039b2 <ucg_com_SendCmdSeq+0x272>
      case 6:
	ucg_com_SetCDLineStatus(ucg, (ucg->com_cfg_cd)&1 );
 80037cc:	687b      	ldr	r3, [r7, #4]
 80037ce:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 80037d2:	f003 0301 	and.w	r3, r3, #1
 80037d6:	b2db      	uxtb	r3, r3
 80037d8:	4619      	mov	r1, r3
 80037da:	6878      	ldr	r0, [r7, #4]
 80037dc:	f7ff ff0a 	bl	80035f4 <ucg_com_SetCDLineStatus>
	ucg_com_SendStringP(ucg, lo, data+1);
 80037e0:	7b7b      	ldrb	r3, [r7, #13]
 80037e2:	b299      	uxth	r1, r3
 80037e4:	683b      	ldr	r3, [r7, #0]
 80037e6:	3301      	adds	r3, #1
 80037e8:	461a      	mov	r2, r3
 80037ea:	6878      	ldr	r0, [r7, #4]
 80037ec:	f7ff ff4c 	bl	8003688 <ucg_com_SendStringP>
	data+=1+lo;      
 80037f0:	7b7b      	ldrb	r3, [r7, #13]
 80037f2:	3301      	adds	r3, #1
 80037f4:	461a      	mov	r2, r3
 80037f6:	683b      	ldr	r3, [r7, #0]
 80037f8:	4413      	add	r3, r2
 80037fa:	603b      	str	r3, [r7, #0]
	break;
 80037fc:	e0d9      	b.n	80039b2 <ucg_com_SendCmdSeq+0x272>
      case 7:	/* note: 0x070 is used to set data line status */
	ucg_com_SetCDLineStatus(ucg, ((ucg->com_cfg_cd>>1)&1)^1 );
 80037fe:	687b      	ldr	r3, [r7, #4]
 8003800:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 8003804:	085b      	lsrs	r3, r3, #1
 8003806:	b2db      	uxtb	r3, r3
 8003808:	f003 0301 	and.w	r3, r3, #1
 800380c:	2b00      	cmp	r3, #0
 800380e:	bf0c      	ite	eq
 8003810:	2301      	moveq	r3, #1
 8003812:	2300      	movne	r3, #0
 8003814:	b2db      	uxtb	r3, r3
 8003816:	4619      	mov	r1, r3
 8003818:	6878      	ldr	r0, [r7, #4]
 800381a:	f7ff feeb 	bl	80035f4 <ucg_com_SetCDLineStatus>
	if ( lo > 0 )
 800381e:	7b7b      	ldrb	r3, [r7, #13]
 8003820:	2b00      	cmp	r3, #0
 8003822:	d007      	beq.n	8003834 <ucg_com_SendCmdSeq+0xf4>
	  ucg_com_SendStringP(ucg, lo, data+1);
 8003824:	7b7b      	ldrb	r3, [r7, #13]
 8003826:	b299      	uxth	r1, r3
 8003828:	683b      	ldr	r3, [r7, #0]
 800382a:	3301      	adds	r3, #1
 800382c:	461a      	mov	r2, r3
 800382e:	6878      	ldr	r0, [r7, #4]
 8003830:	f7ff ff2a 	bl	8003688 <ucg_com_SendStringP>
	data+=1+lo;      
 8003834:	7b7b      	ldrb	r3, [r7, #13]
 8003836:	3301      	adds	r3, #1
 8003838:	461a      	mov	r2, r3
 800383a:	683b      	ldr	r3, [r7, #0]
 800383c:	4413      	add	r3, r2
 800383e:	603b      	str	r3, [r7, #0]
	break;
 8003840:	e0b7      	b.n	80039b2 <ucg_com_SendCmdSeq+0x272>
      case 8:
	data++;
 8003842:	683b      	ldr	r3, [r7, #0]
 8003844:	3301      	adds	r3, #1
 8003846:	603b      	str	r3, [r7, #0]
	b = ucg_pgm_read(data);
 8003848:	683b      	ldr	r3, [r7, #0]
 800384a:	781b      	ldrb	r3, [r3, #0]
 800384c:	73fb      	strb	r3, [r7, #15]
	//b = *data;
	ucg_com_DelayMilliseconds(ucg, (((uint16_t)lo)<<8) + b );
 800384e:	7b7b      	ldrb	r3, [r7, #13]
 8003850:	b29b      	uxth	r3, r3
 8003852:	021b      	lsls	r3, r3, #8
 8003854:	b29a      	uxth	r2, r3
 8003856:	7bfb      	ldrb	r3, [r7, #15]
 8003858:	b29b      	uxth	r3, r3
 800385a:	4413      	add	r3, r2
 800385c:	b29b      	uxth	r3, r3
 800385e:	4619      	mov	r1, r3
 8003860:	6878      	ldr	r0, [r7, #4]
 8003862:	f7ff fee8 	bl	8003636 <ucg_com_DelayMilliseconds>
	data++;
 8003866:	683b      	ldr	r3, [r7, #0]
 8003868:	3301      	adds	r3, #1
 800386a:	603b      	str	r3, [r7, #0]
	break;
 800386c:	e0a1      	b.n	80039b2 <ucg_com_SendCmdSeq+0x272>
      case 9:
	data++;
 800386e:	683b      	ldr	r3, [r7, #0]
 8003870:	3301      	adds	r3, #1
 8003872:	603b      	str	r3, [r7, #0]
	b = ucg_pgm_read(data);
 8003874:	683b      	ldr	r3, [r7, #0]
 8003876:	781b      	ldrb	r3, [r3, #0]
 8003878:	73fb      	strb	r3, [r7, #15]
	//b = *data;
	ucg_com_DelayMicroseconds(ucg, (((uint16_t)lo)<<8) + b );
 800387a:	7b7b      	ldrb	r3, [r7, #13]
 800387c:	b29b      	uxth	r3, r3
 800387e:	021b      	lsls	r3, r3, #8
 8003880:	b29a      	uxth	r2, r3
 8003882:	7bfb      	ldrb	r3, [r7, #15]
 8003884:	b29b      	uxth	r3, r3
 8003886:	4413      	add	r3, r2
 8003888:	b29b      	uxth	r3, r3
 800388a:	4619      	mov	r1, r3
 800388c:	6878      	ldr	r0, [r7, #4]
 800388e:	f7ff fec1 	bl	8003614 <ucg_com_DelayMicroseconds>
	data++;
 8003892:	683b      	ldr	r3, [r7, #0]
 8003894:	3301      	adds	r3, #1
 8003896:	603b      	str	r3, [r7, #0]
	break;
 8003898:	e08b      	b.n	80039b2 <ucg_com_SendCmdSeq+0x272>
      case 10:
	data++;
 800389a:	683b      	ldr	r3, [r7, #0]
 800389c:	3301      	adds	r3, #1
 800389e:	603b      	str	r3, [r7, #0]
	b = ucg_pgm_read(data);
 80038a0:	683b      	ldr	r3, [r7, #0]
 80038a2:	781b      	ldrb	r3, [r3, #0]
 80038a4:	73fb      	strb	r3, [r7, #15]
	data++;
 80038a6:	683b      	ldr	r3, [r7, #0]
 80038a8:	3301      	adds	r3, #1
 80038aa:	603b      	str	r3, [r7, #0]
	bb = ucg_pgm_read(data);
 80038ac:	683b      	ldr	r3, [r7, #0]
 80038ae:	781b      	ldrb	r3, [r3, #0]
 80038b0:	733b      	strb	r3, [r7, #12]
	data++;
 80038b2:	683b      	ldr	r3, [r7, #0]
 80038b4:	3301      	adds	r3, #1
 80038b6:	603b      	str	r3, [r7, #0]
	//b = data[0];
	//bb = data[1];
	ucg_com_SetCDLineStatus(ucg, (ucg->com_cfg_cd)&1 );
 80038b8:	687b      	ldr	r3, [r7, #4]
 80038ba:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 80038be:	f003 0301 	and.w	r3, r3, #1
 80038c2:	b2db      	uxtb	r3, r3
 80038c4:	4619      	mov	r1, r3
 80038c6:	6878      	ldr	r0, [r7, #4]
 80038c8:	f7ff fe94 	bl	80035f4 <ucg_com_SetCDLineStatus>
	ucg_com_SendByte(ucg, (((uint8_t)(((ucg->arg.pixel.pos.x+ucg->display_offset.x)>>lo)))&b)|bb );
 80038cc:	687b      	ldr	r3, [r7, #4]
 80038ce:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 80038d2:	461a      	mov	r2, r3
 80038d4:	687b      	ldr	r3, [r7, #4]
 80038d6:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 80038da:	441a      	add	r2, r3
 80038dc:	7b7b      	ldrb	r3, [r7, #13]
 80038de:	fa42 f303 	asr.w	r3, r2, r3
 80038e2:	b2da      	uxtb	r2, r3
 80038e4:	7bfb      	ldrb	r3, [r7, #15]
 80038e6:	4013      	ands	r3, r2
 80038e8:	b2da      	uxtb	r2, r3
 80038ea:	7b3b      	ldrb	r3, [r7, #12]
 80038ec:	4313      	orrs	r3, r2
 80038ee:	b2db      	uxtb	r3, r3
 80038f0:	4619      	mov	r1, r3
 80038f2:	6878      	ldr	r0, [r7, #4]
 80038f4:	f7ff feb6 	bl	8003664 <ucg_com_SendByte>
	//data+=2;
	break;
 80038f8:	e05b      	b.n	80039b2 <ucg_com_SendCmdSeq+0x272>
      case 11:
	data++;
 80038fa:	683b      	ldr	r3, [r7, #0]
 80038fc:	3301      	adds	r3, #1
 80038fe:	603b      	str	r3, [r7, #0]
	b = ucg_pgm_read(data);
 8003900:	683b      	ldr	r3, [r7, #0]
 8003902:	781b      	ldrb	r3, [r3, #0]
 8003904:	73fb      	strb	r3, [r7, #15]
	data++;
 8003906:	683b      	ldr	r3, [r7, #0]
 8003908:	3301      	adds	r3, #1
 800390a:	603b      	str	r3, [r7, #0]
	bb = ucg_pgm_read(data);
 800390c:	683b      	ldr	r3, [r7, #0]
 800390e:	781b      	ldrb	r3, [r3, #0]
 8003910:	733b      	strb	r3, [r7, #12]
	data++;
 8003912:	683b      	ldr	r3, [r7, #0]
 8003914:	3301      	adds	r3, #1
 8003916:	603b      	str	r3, [r7, #0]
	//b = data[0];
	//bb = data[1];
	ucg_com_SetCDLineStatus(ucg, (ucg->com_cfg_cd)&1 );
 8003918:	687b      	ldr	r3, [r7, #4]
 800391a:	f893 30b0 	ldrb.w	r3, [r3, #176]	; 0xb0
 800391e:	f003 0301 	and.w	r3, r3, #1
 8003922:	b2db      	uxtb	r3, r3
 8003924:	4619      	mov	r1, r3
 8003926:	6878      	ldr	r0, [r7, #4]
 8003928:	f7ff fe64 	bl	80035f4 <ucg_com_SetCDLineStatus>
	ucg_com_SendByte(ucg, (((uint8_t)(((ucg->arg.pixel.pos.y+ucg->display_offset.y)>>lo)))&b)|bb );
 800392c:	687b      	ldr	r3, [r7, #4]
 800392e:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
 8003932:	461a      	mov	r2, r3
 8003934:	687b      	ldr	r3, [r7, #4]
 8003936:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
 800393a:	441a      	add	r2, r3
 800393c:	7b7b      	ldrb	r3, [r7, #13]
 800393e:	fa42 f303 	asr.w	r3, r2, r3
 8003942:	b2da      	uxtb	r2, r3
 8003944:	7bfb      	ldrb	r3, [r7, #15]
 8003946:	4013      	ands	r3, r2
 8003948:	b2da      	uxtb	r2, r3
 800394a:	7b3b      	ldrb	r3, [r7, #12]
 800394c:	4313      	orrs	r3, r2
 800394e:	b2db      	uxtb	r3, r3
 8003950:	4619      	mov	r1, r3
 8003952:	6878      	ldr	r0, [r7, #4]
 8003954:	f7ff fe86 	bl	8003664 <ucg_com_SendByte>
	//data+=2;
	break;
 8003958:	e02b      	b.n	80039b2 <ucg_com_SendCmdSeq+0x272>
      case 15:
	hi = lo >> 2;
 800395a:	7b7b      	ldrb	r3, [r7, #13]
 800395c:	089b      	lsrs	r3, r3, #2
 800395e:	73bb      	strb	r3, [r7, #14]
	lo &= 3;
 8003960:	7b7b      	ldrb	r3, [r7, #13]
 8003962:	f003 0303 	and.w	r3, r3, #3
 8003966:	737b      	strb	r3, [r7, #13]
	switch(hi)
 8003968:	7bbb      	ldrb	r3, [r7, #14]
 800396a:	2b03      	cmp	r3, #3
 800396c:	d018      	beq.n	80039a0 <ucg_com_SendCmdSeq+0x260>
 800396e:	2b03      	cmp	r3, #3
 8003970:	dc1b      	bgt.n	80039aa <ucg_com_SendCmdSeq+0x26a>
 8003972:	2b00      	cmp	r3, #0
 8003974:	d002      	beq.n	800397c <ucg_com_SendCmdSeq+0x23c>
 8003976:	2b01      	cmp	r3, #1
 8003978:	d009      	beq.n	800398e <ucg_com_SendCmdSeq+0x24e>
 800397a:	e016      	b.n	80039aa <ucg_com_SendCmdSeq+0x26a>
	{
	  case 0:
	    ucg_com_SetResetLineStatus(ucg, lo&1);
 800397c:	7b7b      	ldrb	r3, [r7, #13]
 800397e:	f003 0301 	and.w	r3, r3, #1
 8003982:	b2db      	uxtb	r3, r3
 8003984:	4619      	mov	r1, r3
 8003986:	6878      	ldr	r0, [r7, #4]
 8003988:	f7ff fe14 	bl	80035b4 <ucg_com_SetResetLineStatus>
	    break;
 800398c:	e00d      	b.n	80039aa <ucg_com_SendCmdSeq+0x26a>
	  case 1:
	    ucg_com_SetCSLineStatus(ucg, lo&1);
 800398e:	7b7b      	ldrb	r3, [r7, #13]
 8003990:	f003 0301 	and.w	r3, r3, #1
 8003994:	b2db      	uxtb	r3, r3
 8003996:	4619      	mov	r1, r3
 8003998:	6878      	ldr	r0, [r7, #4]
 800399a:	f7ff fe1b 	bl	80035d4 <ucg_com_SetCSLineStatus>
	    break;
 800399e:	e004      	b.n	80039aa <ucg_com_SendCmdSeq+0x26a>
	  case 3:
	    ucg->com_cfg_cd = lo;
 80039a0:	687b      	ldr	r3, [r7, #4]
 80039a2:	7b7a      	ldrb	r2, [r7, #13]
 80039a4:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
	    break;
 80039a8:	bf00      	nop
	}
	data++;
 80039aa:	683b      	ldr	r3, [r7, #0]
 80039ac:	3301      	adds	r3, #1
 80039ae:	603b      	str	r3, [r7, #0]
	break;
 80039b0:	bf00      	nop
    b = ucg_pgm_read(data);
 80039b2:	e6ca      	b.n	800374a <ucg_com_SendCmdSeq+0xa>
      default:
	return;
 80039b4:	bf00      	nop
    }  
  }
}
 80039b6:	3710      	adds	r7, #16
 80039b8:	46bd      	mov	sp, r7
 80039ba:	bd80      	pop	{r7, pc}

080039bc <ucg_dev_default_cb>:
  this should be (finally) called by any other device callback to handle
  messages, which are not yet handled.
*/

ucg_int_t ucg_dev_default_cb(ucg_t *ucg, ucg_int_t msg, void *data)
{
 80039bc:	b580      	push	{r7, lr}
 80039be:	b084      	sub	sp, #16
 80039c0:	af00      	add	r7, sp, #0
 80039c2:	60f8      	str	r0, [r7, #12]
 80039c4:	460b      	mov	r3, r1
 80039c6:	607a      	str	r2, [r7, #4]
 80039c8:	817b      	strh	r3, [r7, #10]
  switch(msg)
 80039ca:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80039ce:	2b0c      	cmp	r3, #12
 80039d0:	d00a      	beq.n	80039e8 <ucg_dev_default_cb+0x2c>
 80039d2:	2b17      	cmp	r3, #23
 80039d4:	d10f      	bne.n	80039f6 <ucg_dev_default_cb+0x3a>
  {
    case UCG_MSG_DRAW_L90SE:
      return ucg->ext_cb(ucg, msg, data);
 80039d6:	68fb      	ldr	r3, [r7, #12]
 80039d8:	68db      	ldr	r3, [r3, #12]
 80039da:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 80039de:	687a      	ldr	r2, [r7, #4]
 80039e0:	68f8      	ldr	r0, [r7, #12]
 80039e2:	4798      	blx	r3
 80039e4:	4603      	mov	r3, r0
 80039e6:	e007      	b.n	80039f8 <ucg_dev_default_cb+0x3c>
    case UCG_MSG_SET_CLIP_BOX:
      ucg->clip_box = *(ucg_box_t *)data;
 80039e8:	68fb      	ldr	r3, [r7, #12]
 80039ea:	687a      	ldr	r2, [r7, #4]
 80039ec:	3370      	adds	r3, #112	; 0x70
 80039ee:	6810      	ldr	r0, [r2, #0]
 80039f0:	6851      	ldr	r1, [r2, #4]
 80039f2:	c303      	stmia	r3!, {r0, r1}
      break;
 80039f4:	bf00      	nop
  }
  return 1;	/* all ok */
 80039f6:	2301      	movs	r3, #1
}
 80039f8:	4618      	mov	r0, r3
 80039fa:	3710      	adds	r7, #16
 80039fc:	46bd      	mov	sp, r7
 80039fe:	bd80      	pop	{r7, pc}

08003a00 <ucg_ext_none>:

/*
  will be used as default cb if no extentions callback is provided
*/
ucg_int_t ucg_ext_none(ucg_t *ucg, ucg_int_t msg, void *data)
{
 8003a00:	b480      	push	{r7}
 8003a02:	b085      	sub	sp, #20
 8003a04:	af00      	add	r7, sp, #0
 8003a06:	60f8      	str	r0, [r7, #12]
 8003a08:	460b      	mov	r3, r1
 8003a0a:	607a      	str	r2, [r7, #4]
 8003a0c:	817b      	strh	r3, [r7, #10]
  return 1;	/* all ok */  
 8003a0e:	2301      	movs	r3, #1
}
 8003a10:	4618      	mov	r0, r3
 8003a12:	3714      	adds	r7, #20
 8003a14:	46bd      	mov	sp, r7
 8003a16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003a1a:	4770      	bx	lr

08003a1c <ucg_handle_st7735_l90fx>:
  UCG_DATA(),								/* change to data mode */
  UCG_END()
};

ucg_int_t ucg_handle_st7735_l90fx(ucg_t *ucg)
{
 8003a1c:	b590      	push	{r4, r7, lr}
 8003a1e:	b085      	sub	sp, #20
 8003a20:	af00      	add	r7, sp, #0
 8003a22:	6078      	str	r0, [r7, #4]
  uint8_t c[3];
  ucg_int_t tmp;
  if ( ucg_clip_l90fx(ucg) != 0 )
 8003a24:	6878      	ldr	r0, [r7, #4]
 8003a26:	f7ff fb5b 	bl	80030e0 <ucg_clip_l90fx>
 8003a2a:	4603      	mov	r3, r0
 8003a2c:	2b00      	cmp	r3, #0
 8003a2e:	d056      	beq.n	8003ade <ucg_handle_st7735_l90fx+0xc2>
  {
    switch(ucg->arg.dir)
 8003a30:	687b      	ldr	r3, [r7, #4]
 8003a32:	f9b3 302e 	ldrsh.w	r3, [r3, #46]	; 0x2e
 8003a36:	2b02      	cmp	r3, #2
 8003a38:	d010      	beq.n	8003a5c <ucg_handle_st7735_l90fx+0x40>
 8003a3a:	2b02      	cmp	r3, #2
 8003a3c:	dc20      	bgt.n	8003a80 <ucg_handle_st7735_l90fx+0x64>
 8003a3e:	2b00      	cmp	r3, #0
 8003a40:	d002      	beq.n	8003a48 <ucg_handle_st7735_l90fx+0x2c>
 8003a42:	2b01      	cmp	r3, #1
 8003a44:	d005      	beq.n	8003a52 <ucg_handle_st7735_l90fx+0x36>
 8003a46:	e01b      	b.n	8003a80 <ucg_handle_st7735_l90fx+0x64>
    {
      case 0: 
	ucg_com_SendCmdSeq(ucg, ucg_st7735_set_pos_dir0_seq);	
 8003a48:	4927      	ldr	r1, [pc, #156]	; (8003ae8 <ucg_handle_st7735_l90fx+0xcc>)
 8003a4a:	6878      	ldr	r0, [r7, #4]
 8003a4c:	f7ff fe78 	bl	8003740 <ucg_com_SendCmdSeq>
	break;
 8003a50:	e028      	b.n	8003aa4 <ucg_handle_st7735_l90fx+0x88>
      case 1: 
	ucg_com_SendCmdSeq(ucg, ucg_st7735_set_pos_dir1_seq);	
 8003a52:	4926      	ldr	r1, [pc, #152]	; (8003aec <ucg_handle_st7735_l90fx+0xd0>)
 8003a54:	6878      	ldr	r0, [r7, #4]
 8003a56:	f7ff fe73 	bl	8003740 <ucg_com_SendCmdSeq>
	break;
 8003a5a:	e023      	b.n	8003aa4 <ucg_handle_st7735_l90fx+0x88>
      case 2: 
	tmp = ucg->arg.pixel.pos.x;
 8003a5c:	687b      	ldr	r3, [r7, #4]
 8003a5e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8003a60:	81fb      	strh	r3, [r7, #14]
	ucg->arg.pixel.pos.x = 127-tmp;
 8003a62:	89fb      	ldrh	r3, [r7, #14]
 8003a64:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 8003a68:	b29b      	uxth	r3, r3
 8003a6a:	b21a      	sxth	r2, r3
 8003a6c:	687b      	ldr	r3, [r7, #4]
 8003a6e:	849a      	strh	r2, [r3, #36]	; 0x24
	ucg_com_SendCmdSeq(ucg, ucg_st7735_set_pos_dir2_seq);	
 8003a70:	491f      	ldr	r1, [pc, #124]	; (8003af0 <ucg_handle_st7735_l90fx+0xd4>)
 8003a72:	6878      	ldr	r0, [r7, #4]
 8003a74:	f7ff fe64 	bl	8003740 <ucg_com_SendCmdSeq>
	ucg->arg.pixel.pos.x = tmp;
 8003a78:	687b      	ldr	r3, [r7, #4]
 8003a7a:	89fa      	ldrh	r2, [r7, #14]
 8003a7c:	849a      	strh	r2, [r3, #36]	; 0x24
	break;
 8003a7e:	e011      	b.n	8003aa4 <ucg_handle_st7735_l90fx+0x88>
      case 3: 
      default: 
	tmp = ucg->arg.pixel.pos.y;
 8003a80:	687b      	ldr	r3, [r7, #4]
 8003a82:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8003a84:	81fb      	strh	r3, [r7, #14]
	ucg->arg.pixel.pos.y = 127-tmp;
 8003a86:	89fb      	ldrh	r3, [r7, #14]
 8003a88:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 8003a8c:	b29b      	uxth	r3, r3
 8003a8e:	b21a      	sxth	r2, r3
 8003a90:	687b      	ldr	r3, [r7, #4]
 8003a92:	84da      	strh	r2, [r3, #38]	; 0x26
	ucg_com_SendCmdSeq(ucg, ucg_st7735_set_pos_dir3_seq);	
 8003a94:	4917      	ldr	r1, [pc, #92]	; (8003af4 <ucg_handle_st7735_l90fx+0xd8>)
 8003a96:	6878      	ldr	r0, [r7, #4]
 8003a98:	f7ff fe52 	bl	8003740 <ucg_com_SendCmdSeq>
	ucg->arg.pixel.pos.y = tmp;
 8003a9c:	687b      	ldr	r3, [r7, #4]
 8003a9e:	89fa      	ldrh	r2, [r7, #14]
 8003aa0:	84da      	strh	r2, [r3, #38]	; 0x26
	break;
 8003aa2:	bf00      	nop
    }
    c[0] = ucg->arg.pixel.rgb.color[0];
 8003aa4:	687b      	ldr	r3, [r7, #4]
 8003aa6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8003aaa:	723b      	strb	r3, [r7, #8]
    c[1] = ucg->arg.pixel.rgb.color[1];
 8003aac:	687b      	ldr	r3, [r7, #4]
 8003aae:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8003ab2:	727b      	strb	r3, [r7, #9]
    c[2] = ucg->arg.pixel.rgb.color[2];
 8003ab4:	687b      	ldr	r3, [r7, #4]
 8003ab6:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 8003aba:	72bb      	strb	r3, [r7, #10]
    ucg_com_SendRepeat3Bytes(ucg, ucg->arg.len, c);
 8003abc:	687b      	ldr	r3, [r7, #4]
 8003abe:	69dc      	ldr	r4, [r3, #28]
 8003ac0:	687b      	ldr	r3, [r7, #4]
 8003ac2:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
 8003ac6:	b29a      	uxth	r2, r3
 8003ac8:	f107 0308 	add.w	r3, r7, #8
 8003acc:	2113      	movs	r1, #19
 8003ace:	6878      	ldr	r0, [r7, #4]
 8003ad0:	47a0      	blx	r4
    ucg_com_SetCSLineStatus(ucg, 1);		/* disable chip */
 8003ad2:	2101      	movs	r1, #1
 8003ad4:	6878      	ldr	r0, [r7, #4]
 8003ad6:	f7ff fd7d 	bl	80035d4 <ucg_com_SetCSLineStatus>
    return 1;
 8003ada:	2301      	movs	r3, #1
 8003adc:	e000      	b.n	8003ae0 <ucg_handle_st7735_l90fx+0xc4>
  }
  return 0;
 8003ade:	2300      	movs	r3, #0
}
 8003ae0:	4618      	mov	r0, r3
 8003ae2:	3714      	adds	r7, #20
 8003ae4:	46bd      	mov	sp, r7
 8003ae6:	bd90      	pop	{r4, r7, pc}
 8003ae8:	08006980 	.word	0x08006980
 8003aec:	080069a0 	.word	0x080069a0
 8003af0:	080069c4 	.word	0x080069c4
 8003af4:	080069e8 	.word	0x080069e8

08003af8 <ucg_handle_st7735_l90se>:
  return 0;
}


ucg_int_t ucg_handle_st7735_l90se(ucg_t *ucg)
{
 8003af8:	b590      	push	{r4, r7, lr}
 8003afa:	b087      	sub	sp, #28
 8003afc:	af00      	add	r7, sp, #0
 8003afe:	6078      	str	r0, [r7, #4]
  uint8_t c[3];
  ucg_int_t tmp;
  
  /* Setup ccs for l90se. This will be updated by ucg_clip_l90se if required */
  
  for ( i = 0; i < 3; i++ )
 8003b00:	2300      	movs	r3, #0
 8003b02:	75fb      	strb	r3, [r7, #23]
 8003b04:	e01a      	b.n	8003b3c <ucg_handle_st7735_l90se+0x44>
  {
    ucg_ccs_init(ucg->arg.ccs_line+i, ucg->arg.rgb[0].color[i], ucg->arg.rgb[1].color[i], ucg->arg.len);
 8003b06:	687b      	ldr	r3, [r7, #4]
 8003b08:	f103 0146 	add.w	r1, r3, #70	; 0x46
 8003b0c:	7dfa      	ldrb	r2, [r7, #23]
 8003b0e:	4613      	mov	r3, r2
 8003b10:	00db      	lsls	r3, r3, #3
 8003b12:	1a9b      	subs	r3, r3, r2
 8003b14:	005b      	lsls	r3, r3, #1
 8003b16:	18c8      	adds	r0, r1, r3
 8003b18:	7dfb      	ldrb	r3, [r7, #23]
 8003b1a:	687a      	ldr	r2, [r7, #4]
 8003b1c:	4413      	add	r3, r2
 8003b1e:	f893 103a 	ldrb.w	r1, [r3, #58]	; 0x3a
 8003b22:	7dfb      	ldrb	r3, [r7, #23]
 8003b24:	687a      	ldr	r2, [r7, #4]
 8003b26:	4413      	add	r3, r2
 8003b28:	f893 203d 	ldrb.w	r2, [r3, #61]	; 0x3d
 8003b2c:	687b      	ldr	r3, [r7, #4]
 8003b2e:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
 8003b32:	f7ff f80e 	bl	8002b52 <ucg_ccs_init>
  for ( i = 0; i < 3; i++ )
 8003b36:	7dfb      	ldrb	r3, [r7, #23]
 8003b38:	3301      	adds	r3, #1
 8003b3a:	75fb      	strb	r3, [r7, #23]
 8003b3c:	7dfb      	ldrb	r3, [r7, #23]
 8003b3e:	2b02      	cmp	r3, #2
 8003b40:	d9e1      	bls.n	8003b06 <ucg_handle_st7735_l90se+0xe>
  }
  
  /* check if the line is visible */
  
  if ( ucg_clip_l90se(ucg) != 0 )
 8003b42:	6878      	ldr	r0, [r7, #4]
 8003b44:	f7ff fc4c 	bl	80033e0 <ucg_clip_l90se>
 8003b48:	4603      	mov	r3, r0
 8003b4a:	2b00      	cmp	r3, #0
 8003b4c:	d074      	beq.n	8003c38 <ucg_handle_st7735_l90se+0x140>
  {
    ucg_int_t i;
    switch(ucg->arg.dir)
 8003b4e:	687b      	ldr	r3, [r7, #4]
 8003b50:	f9b3 302e 	ldrsh.w	r3, [r3, #46]	; 0x2e
 8003b54:	2b02      	cmp	r3, #2
 8003b56:	d010      	beq.n	8003b7a <ucg_handle_st7735_l90se+0x82>
 8003b58:	2b02      	cmp	r3, #2
 8003b5a:	dc20      	bgt.n	8003b9e <ucg_handle_st7735_l90se+0xa6>
 8003b5c:	2b00      	cmp	r3, #0
 8003b5e:	d002      	beq.n	8003b66 <ucg_handle_st7735_l90se+0x6e>
 8003b60:	2b01      	cmp	r3, #1
 8003b62:	d005      	beq.n	8003b70 <ucg_handle_st7735_l90se+0x78>
 8003b64:	e01b      	b.n	8003b9e <ucg_handle_st7735_l90se+0xa6>
    {
      case 0: 
	ucg_com_SendCmdSeq(ucg, ucg_st7735_set_pos_dir0_seq);	
 8003b66:	4937      	ldr	r1, [pc, #220]	; (8003c44 <ucg_handle_st7735_l90se+0x14c>)
 8003b68:	6878      	ldr	r0, [r7, #4]
 8003b6a:	f7ff fde9 	bl	8003740 <ucg_com_SendCmdSeq>
	break;
 8003b6e:	e028      	b.n	8003bc2 <ucg_handle_st7735_l90se+0xca>
      case 1: 
	ucg_com_SendCmdSeq(ucg, ucg_st7735_set_pos_dir1_seq);	
 8003b70:	4935      	ldr	r1, [pc, #212]	; (8003c48 <ucg_handle_st7735_l90se+0x150>)
 8003b72:	6878      	ldr	r0, [r7, #4]
 8003b74:	f7ff fde4 	bl	8003740 <ucg_com_SendCmdSeq>
	break;
 8003b78:	e023      	b.n	8003bc2 <ucg_handle_st7735_l90se+0xca>
      case 2: 
	tmp = ucg->arg.pixel.pos.x;
 8003b7a:	687b      	ldr	r3, [r7, #4]
 8003b7c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8003b7e:	827b      	strh	r3, [r7, #18]
	ucg->arg.pixel.pos.x = 127-tmp;
 8003b80:	8a7b      	ldrh	r3, [r7, #18]
 8003b82:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 8003b86:	b29b      	uxth	r3, r3
 8003b88:	b21a      	sxth	r2, r3
 8003b8a:	687b      	ldr	r3, [r7, #4]
 8003b8c:	849a      	strh	r2, [r3, #36]	; 0x24
	ucg_com_SendCmdSeq(ucg, ucg_st7735_set_pos_dir2_seq);	
 8003b8e:	492f      	ldr	r1, [pc, #188]	; (8003c4c <ucg_handle_st7735_l90se+0x154>)
 8003b90:	6878      	ldr	r0, [r7, #4]
 8003b92:	f7ff fdd5 	bl	8003740 <ucg_com_SendCmdSeq>
	ucg->arg.pixel.pos.x = tmp;
 8003b96:	687b      	ldr	r3, [r7, #4]
 8003b98:	8a7a      	ldrh	r2, [r7, #18]
 8003b9a:	849a      	strh	r2, [r3, #36]	; 0x24
	break;
 8003b9c:	e011      	b.n	8003bc2 <ucg_handle_st7735_l90se+0xca>
      case 3: 
      default: 
	tmp = ucg->arg.pixel.pos.y;
 8003b9e:	687b      	ldr	r3, [r7, #4]
 8003ba0:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 8003ba2:	827b      	strh	r3, [r7, #18]
	ucg->arg.pixel.pos.y = 127-tmp;
 8003ba4:	8a7b      	ldrh	r3, [r7, #18]
 8003ba6:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 8003baa:	b29b      	uxth	r3, r3
 8003bac:	b21a      	sxth	r2, r3
 8003bae:	687b      	ldr	r3, [r7, #4]
 8003bb0:	84da      	strh	r2, [r3, #38]	; 0x26
	ucg_com_SendCmdSeq(ucg, ucg_st7735_set_pos_dir3_seq);	
 8003bb2:	4927      	ldr	r1, [pc, #156]	; (8003c50 <ucg_handle_st7735_l90se+0x158>)
 8003bb4:	6878      	ldr	r0, [r7, #4]
 8003bb6:	f7ff fdc3 	bl	8003740 <ucg_com_SendCmdSeq>
	ucg->arg.pixel.pos.y = tmp;
 8003bba:	687b      	ldr	r3, [r7, #4]
 8003bbc:	8a7a      	ldrh	r2, [r7, #18]
 8003bbe:	84da      	strh	r2, [r3, #38]	; 0x26
	break;
 8003bc0:	bf00      	nop
    }
    
    for( i = 0; i < ucg->arg.len; i++ )
 8003bc2:	2300      	movs	r3, #0
 8003bc4:	82bb      	strh	r3, [r7, #20]
 8003bc6:	e02a      	b.n	8003c1e <ucg_handle_st7735_l90se+0x126>
    {
      c[0] = ucg->arg.ccs_line[0].current;
 8003bc8:	687b      	ldr	r3, [r7, #4]
 8003bca:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
 8003bce:	733b      	strb	r3, [r7, #12]
      c[1] = ucg->arg.ccs_line[1].current; 
 8003bd0:	687b      	ldr	r3, [r7, #4]
 8003bd2:	f893 3054 	ldrb.w	r3, [r3, #84]	; 0x54
 8003bd6:	737b      	strb	r3, [r7, #13]
      c[2] = ucg->arg.ccs_line[2].current;
 8003bd8:	687b      	ldr	r3, [r7, #4]
 8003bda:	f893 3062 	ldrb.w	r3, [r3, #98]	; 0x62
 8003bde:	73bb      	strb	r3, [r7, #14]
      ucg_com_SendRepeat3Bytes(ucg, 1, c);
 8003be0:	687b      	ldr	r3, [r7, #4]
 8003be2:	69dc      	ldr	r4, [r3, #28]
 8003be4:	f107 030c 	add.w	r3, r7, #12
 8003be8:	2201      	movs	r2, #1
 8003bea:	2113      	movs	r1, #19
 8003bec:	6878      	ldr	r0, [r7, #4]
 8003bee:	47a0      	blx	r4
      ucg_ccs_step(ucg->arg.ccs_line+0);
 8003bf0:	687b      	ldr	r3, [r7, #4]
 8003bf2:	3346      	adds	r3, #70	; 0x46
 8003bf4:	4618      	mov	r0, r3
 8003bf6:	f7ff f80c 	bl	8002c12 <ucg_ccs_step>
      ucg_ccs_step(ucg->arg.ccs_line+1);
 8003bfa:	687b      	ldr	r3, [r7, #4]
 8003bfc:	3346      	adds	r3, #70	; 0x46
 8003bfe:	330e      	adds	r3, #14
 8003c00:	4618      	mov	r0, r3
 8003c02:	f7ff f806 	bl	8002c12 <ucg_ccs_step>
      ucg_ccs_step(ucg->arg.ccs_line+2);
 8003c06:	687b      	ldr	r3, [r7, #4]
 8003c08:	3346      	adds	r3, #70	; 0x46
 8003c0a:	331c      	adds	r3, #28
 8003c0c:	4618      	mov	r0, r3
 8003c0e:	f7ff f800 	bl	8002c12 <ucg_ccs_step>
    for( i = 0; i < ucg->arg.len; i++ )
 8003c12:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8003c16:	b29b      	uxth	r3, r3
 8003c18:	3301      	adds	r3, #1
 8003c1a:	b29b      	uxth	r3, r3
 8003c1c:	82bb      	strh	r3, [r7, #20]
 8003c1e:	687b      	ldr	r3, [r7, #4]
 8003c20:	f9b3 302c 	ldrsh.w	r3, [r3, #44]	; 0x2c
 8003c24:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 8003c28:	429a      	cmp	r2, r3
 8003c2a:	dbcd      	blt.n	8003bc8 <ucg_handle_st7735_l90se+0xd0>
    }
    ucg_com_SetCSLineStatus(ucg, 1);		/* disable chip */
 8003c2c:	2101      	movs	r1, #1
 8003c2e:	6878      	ldr	r0, [r7, #4]
 8003c30:	f7ff fcd0 	bl	80035d4 <ucg_com_SetCSLineStatus>
    return 1;
 8003c34:	2301      	movs	r3, #1
 8003c36:	e000      	b.n	8003c3a <ucg_handle_st7735_l90se+0x142>
  }
  return 0;
 8003c38:	2300      	movs	r3, #0
}
 8003c3a:	4618      	mov	r0, r3
 8003c3c:	371c      	adds	r7, #28
 8003c3e:	46bd      	mov	sp, r7
 8003c40:	bd90      	pop	{r4, r7, pc}
 8003c42:	bf00      	nop
 8003c44:	08006980 	.word	0x08006980
 8003c48:	080069a0 	.word	0x080069a0
 8003c4c:	080069c4 	.word	0x080069c4
 8003c50:	080069e8 	.word	0x080069e8

08003c54 <ucg_dev_ic_st7735_18>:
	UCG_CS(1),					/* disable chip */
	UCG_END(),					/* end of sequence */
};

ucg_int_t ucg_dev_ic_st7735_18(ucg_t *ucg, ucg_int_t msg, void *data)
{
 8003c54:	b590      	push	{r4, r7, lr}
 8003c56:	b087      	sub	sp, #28
 8003c58:	af00      	add	r7, sp, #0
 8003c5a:	60f8      	str	r0, [r7, #12]
 8003c5c:	460b      	mov	r3, r1
 8003c5e:	607a      	str	r2, [r7, #4]
 8003c60:	817b      	strh	r3, [r7, #10]
  switch(msg)
 8003c62:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8003c66:	3b0a      	subs	r3, #10
 8003c68:	2b0b      	cmp	r3, #11
 8003c6a:	d85f      	bhi.n	8003d2c <ucg_dev_ic_st7735_18+0xd8>
 8003c6c:	a201      	add	r2, pc, #4	; (adr r2, 8003c74 <ucg_dev_ic_st7735_18+0x20>)
 8003c6e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003c72:	bf00      	nop
 8003c74:	08003ca5 	.word	0x08003ca5
 8003c78:	08003cbf 	.word	0x08003cbf
 8003c7c:	08003d2d 	.word	0x08003d2d
 8003c80:	08003d2d 	.word	0x08003d2d
 8003c84:	08003d2d 	.word	0x08003d2d
 8003c88:	08003ccb 	.word	0x08003ccb
 8003c8c:	08003d2d 	.word	0x08003d2d
 8003c90:	08003d2d 	.word	0x08003d2d
 8003c94:	08003d2d 	.word	0x08003d2d
 8003c98:	08003d2d 	.word	0x08003d2d
 8003c9c:	08003cdb 	.word	0x08003cdb
 8003ca0:	08003d23 	.word	0x08003d23
  {
    case UCG_MSG_DEV_POWER_UP:
      /* setup com interface and provide information on the clock speed */
      /* of the serial and parallel interface. Values are nanoseconds. */
	  ucg->display_offset.x = 2;
 8003ca4:	68fb      	ldr	r3, [r7, #12]
 8003ca6:	2202      	movs	r2, #2
 8003ca8:	841a      	strh	r2, [r3, #32]
	  ucg->display_offset.y = 1;
 8003caa:	68fb      	ldr	r3, [r7, #12]
 8003cac:	2201      	movs	r2, #1
 8003cae:	845a      	strh	r2, [r3, #34]	; 0x22
      return ucg_com_PowerUp(ucg, 100, 66);
 8003cb0:	2242      	movs	r2, #66	; 0x42
 8003cb2:	2164      	movs	r1, #100	; 0x64
 8003cb4:	68f8      	ldr	r0, [r7, #12]
 8003cb6:	f7ff fbdc 	bl	8003472 <ucg_com_PowerUp>
 8003cba:	4603      	mov	r3, r0
 8003cbc:	e03e      	b.n	8003d3c <ucg_dev_ic_st7735_18+0xe8>
    case UCG_MSG_DEV_POWER_DOWN:
      ucg_com_SendCmdSeq(ucg, ucg_st7735_power_down_seq);
 8003cbe:	4921      	ldr	r1, [pc, #132]	; (8003d44 <ucg_dev_ic_st7735_18+0xf0>)
 8003cc0:	68f8      	ldr	r0, [r7, #12]
 8003cc2:	f7ff fd3d 	bl	8003740 <ucg_com_SendCmdSeq>
      return 1;
 8003cc6:	2301      	movs	r3, #1
 8003cc8:	e038      	b.n	8003d3c <ucg_dev_ic_st7735_18+0xe8>
    case UCG_MSG_GET_DIMENSION:
      ((ucg_wh_t *)data)->w = 128;
 8003cca:	687b      	ldr	r3, [r7, #4]
 8003ccc:	2280      	movs	r2, #128	; 0x80
 8003cce:	801a      	strh	r2, [r3, #0]
      ((ucg_wh_t *)data)->h = 128;
 8003cd0:	687b      	ldr	r3, [r7, #4]
 8003cd2:	2280      	movs	r2, #128	; 0x80
 8003cd4:	805a      	strh	r2, [r3, #2]
      return 1;
 8003cd6:	2301      	movs	r3, #1
 8003cd8:	e030      	b.n	8003d3c <ucg_dev_ic_st7735_18+0xe8>
    case UCG_MSG_DRAW_PIXEL:
      if ( ucg_clip_is_pixel_visible(ucg) !=0 )
 8003cda:	68f8      	ldr	r0, [r7, #12]
 8003cdc:	f7ff f9e7 	bl	80030ae <ucg_clip_is_pixel_visible>
 8003ce0:	4603      	mov	r3, r0
 8003ce2:	2b00      	cmp	r3, #0
 8003ce4:	d01b      	beq.n	8003d1e <ucg_dev_ic_st7735_18+0xca>
      {
	uint8_t c[3];
	ucg_com_SendCmdSeq(ucg, ucg_st7735_set_pos_seq);	
 8003ce6:	4918      	ldr	r1, [pc, #96]	; (8003d48 <ucg_dev_ic_st7735_18+0xf4>)
 8003ce8:	68f8      	ldr	r0, [r7, #12]
 8003cea:	f7ff fd29 	bl	8003740 <ucg_com_SendCmdSeq>
	c[0] = ucg->arg.pixel.rgb.color[0];
 8003cee:	68fb      	ldr	r3, [r7, #12]
 8003cf0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8003cf4:	753b      	strb	r3, [r7, #20]
	c[1] = ucg->arg.pixel.rgb.color[1];
 8003cf6:	68fb      	ldr	r3, [r7, #12]
 8003cf8:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
 8003cfc:	757b      	strb	r3, [r7, #21]
	c[2] = ucg->arg.pixel.rgb.color[2];
 8003cfe:	68fb      	ldr	r3, [r7, #12]
 8003d00:	f893 302a 	ldrb.w	r3, [r3, #42]	; 0x2a
 8003d04:	75bb      	strb	r3, [r7, #22]
	ucg_com_SendRepeat3Bytes(ucg, 1, c);
 8003d06:	68fb      	ldr	r3, [r7, #12]
 8003d08:	69dc      	ldr	r4, [r3, #28]
 8003d0a:	f107 0314 	add.w	r3, r7, #20
 8003d0e:	2201      	movs	r2, #1
 8003d10:	2113      	movs	r1, #19
 8003d12:	68f8      	ldr	r0, [r7, #12]
 8003d14:	47a0      	blx	r4
	ucg_com_SetCSLineStatus(ucg, 1);		/* disable chip */
 8003d16:	2101      	movs	r1, #1
 8003d18:	68f8      	ldr	r0, [r7, #12]
 8003d1a:	f7ff fc5b 	bl	80035d4 <ucg_com_SetCSLineStatus>
      }
      return 1;
 8003d1e:	2301      	movs	r3, #1
 8003d20:	e00c      	b.n	8003d3c <ucg_dev_ic_st7735_18+0xe8>
    case UCG_MSG_DRAW_L90FX:
      //ucg_handle_l90fx(ucg, ucg_dev_ic_st7735_18);
      ucg_handle_st7735_l90fx(ucg);
 8003d22:	68f8      	ldr	r0, [r7, #12]
 8003d24:	f7ff fe7a 	bl	8003a1c <ucg_handle_st7735_l90fx>
      return 1;
 8003d28:	2301      	movs	r3, #1
 8003d2a:	e007      	b.n	8003d3c <ucg_dev_ic_st7735_18+0xe8>
    /*
    case UCG_MSG_DRAW_L90SE:
      return ucg->ext_cb(ucg, msg, data);
    */
  }
  return ucg_dev_default_cb(ucg, msg, data);  
 8003d2c:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8003d30:	687a      	ldr	r2, [r7, #4]
 8003d32:	4619      	mov	r1, r3
 8003d34:	68f8      	ldr	r0, [r7, #12]
 8003d36:	f7ff fe41 	bl	80039bc <ucg_dev_default_cb>
 8003d3a:	4603      	mov	r3, r0
}
 8003d3c:	4618      	mov	r0, r3
 8003d3e:	371c      	adds	r7, #28
 8003d40:	46bd      	mov	sp, r7
 8003d42:	bd90      	pop	{r4, r7, pc}
 8003d44:	08006a0c 	.word	0x08006a0c
 8003d48:	08006960 	.word	0x08006960

08003d4c <ucg_ext_st7735_18>:

ucg_int_t ucg_ext_st7735_18(ucg_t *ucg, ucg_int_t msg, void *data)
{
 8003d4c:	b580      	push	{r7, lr}
 8003d4e:	b084      	sub	sp, #16
 8003d50:	af00      	add	r7, sp, #0
 8003d52:	60f8      	str	r0, [r7, #12]
 8003d54:	460b      	mov	r3, r1
 8003d56:	607a      	str	r2, [r7, #4]
 8003d58:	817b      	strh	r3, [r7, #10]
  switch(msg)
 8003d5a:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8003d5e:	2b17      	cmp	r3, #23
 8003d60:	d103      	bne.n	8003d6a <ucg_ext_st7735_18+0x1e>
  {
    case UCG_MSG_DRAW_L90SE:
      //ucg_handle_l90se(ucg, ucg_dev_ic_st7735_18);
      ucg_handle_st7735_l90se(ucg);
 8003d62:	68f8      	ldr	r0, [r7, #12]
 8003d64:	f7ff fec8 	bl	8003af8 <ucg_handle_st7735_l90se>
      break;
 8003d68:	bf00      	nop
  }
  return 1;
 8003d6a:	2301      	movs	r3, #1
}
 8003d6c:	4618      	mov	r0, r3
 8003d6e:	3710      	adds	r7, #16
 8003d70:	46bd      	mov	sp, r7
 8003d72:	bd80      	pop	{r7, pc}

08003d74 <ucg_PowerDown>:

#include "ucg.h"
#include <stddef.h>

void ucg_PowerDown(ucg_t *ucg)
{
 8003d74:	b580      	push	{r7, lr}
 8003d76:	b082      	sub	sp, #8
 8003d78:	af00      	add	r7, sp, #0
 8003d7a:	6078      	str	r0, [r7, #4]
  if ( ucg->is_power_up != 0 )
 8003d7c:	687b      	ldr	r3, [r7, #4]
 8003d7e:	781b      	ldrb	r3, [r3, #0]
 8003d80:	f003 0301 	and.w	r3, r3, #1
 8003d84:	b2db      	uxtb	r3, r3
 8003d86:	2b00      	cmp	r3, #0
 8003d88:	d00a      	beq.n	8003da0 <ucg_PowerDown+0x2c>
  {
    ucg->device_cb(ucg, UCG_MSG_DEV_POWER_DOWN, NULL);
 8003d8a:	687b      	ldr	r3, [r7, #4]
 8003d8c:	689b      	ldr	r3, [r3, #8]
 8003d8e:	2200      	movs	r2, #0
 8003d90:	210b      	movs	r1, #11
 8003d92:	6878      	ldr	r0, [r7, #4]
 8003d94:	4798      	blx	r3
    ucg->is_power_up = 0;
 8003d96:	687a      	ldr	r2, [r7, #4]
 8003d98:	7813      	ldrb	r3, [r2, #0]
 8003d9a:	f36f 0300 	bfc	r3, #0, #1
 8003d9e:	7013      	strb	r3, [r2, #0]
  }
}
 8003da0:	bf00      	nop
 8003da2:	3708      	adds	r7, #8
 8003da4:	46bd      	mov	sp, r7
 8003da6:	bd80      	pop	{r7, pc}

08003da8 <ucg_PowerUp>:

ucg_int_t ucg_PowerUp(ucg_t *ucg)
{
 8003da8:	b580      	push	{r7, lr}
 8003daa:	b084      	sub	sp, #16
 8003dac:	af00      	add	r7, sp, #0
 8003dae:	6078      	str	r0, [r7, #4]
  ucg_int_t r;
  /* power down first. will do nothing if power is already down */
  ucg_PowerDown(ucg);
 8003db0:	6878      	ldr	r0, [r7, #4]
 8003db2:	f7ff ffdf 	bl	8003d74 <ucg_PowerDown>
  /* now try to power up the display */
  r = ucg->device_cb(ucg, UCG_MSG_DEV_POWER_UP, NULL);
 8003db6:	687b      	ldr	r3, [r7, #4]
 8003db8:	689b      	ldr	r3, [r3, #8]
 8003dba:	2200      	movs	r2, #0
 8003dbc:	210a      	movs	r1, #10
 8003dbe:	6878      	ldr	r0, [r7, #4]
 8003dc0:	4798      	blx	r3
 8003dc2:	4603      	mov	r3, r0
 8003dc4:	81fb      	strh	r3, [r7, #14]
  if ( r != 0 )
 8003dc6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8003dca:	2b00      	cmp	r3, #0
 8003dcc:	d004      	beq.n	8003dd8 <ucg_PowerUp+0x30>
  {
    ucg->is_power_up = 1;
 8003dce:	687a      	ldr	r2, [r7, #4]
 8003dd0:	7813      	ldrb	r3, [r2, #0]
 8003dd2:	f043 0301 	orr.w	r3, r3, #1
 8003dd6:	7013      	strb	r3, [r2, #0]
  }
  return r;
 8003dd8:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
}
 8003ddc:	4618      	mov	r0, r3
 8003dde:	3710      	adds	r7, #16
 8003de0:	46bd      	mov	sp, r7
 8003de2:	bd80      	pop	{r7, pc}

08003de4 <ucg_SetClipBox>:

void ucg_SetClipBox(ucg_t *ucg, ucg_box_t *clip_box)
{
 8003de4:	b580      	push	{r7, lr}
 8003de6:	b082      	sub	sp, #8
 8003de8:	af00      	add	r7, sp, #0
 8003dea:	6078      	str	r0, [r7, #4]
 8003dec:	6039      	str	r1, [r7, #0]
  ucg->device_cb(ucg, UCG_MSG_SET_CLIP_BOX, (void *)(clip_box));
 8003dee:	687b      	ldr	r3, [r7, #4]
 8003df0:	689b      	ldr	r3, [r3, #8]
 8003df2:	683a      	ldr	r2, [r7, #0]
 8003df4:	210c      	movs	r1, #12
 8003df6:	6878      	ldr	r0, [r7, #4]
 8003df8:	4798      	blx	r3
}
 8003dfa:	bf00      	nop
 8003dfc:	3708      	adds	r7, #8
 8003dfe:	46bd      	mov	sp, r7
 8003e00:	bd80      	pop	{r7, pc}

08003e02 <ucg_SetMaxClipRange>:
  clip_box.size.h = h;
  ucg_SetClipBox(ucg, &clip_box);
}

void ucg_SetMaxClipRange(ucg_t *ucg)
{
 8003e02:	b580      	push	{r7, lr}
 8003e04:	b084      	sub	sp, #16
 8003e06:	af00      	add	r7, sp, #0
 8003e08:	6078      	str	r0, [r7, #4]
  ucg_box_t new_clip_box;
  new_clip_box.size = ucg->dimension;
 8003e0a:	687a      	ldr	r2, [r7, #4]
 8003e0c:	f107 030c 	add.w	r3, r7, #12
 8003e10:	3202      	adds	r2, #2
 8003e12:	6810      	ldr	r0, [r2, #0]
 8003e14:	6018      	str	r0, [r3, #0]
  new_clip_box.ul.x = 0;
 8003e16:	2300      	movs	r3, #0
 8003e18:	813b      	strh	r3, [r7, #8]
  new_clip_box.ul.y = 0;
 8003e1a:	2300      	movs	r3, #0
 8003e1c:	817b      	strh	r3, [r7, #10]
  ucg_SetClipBox(ucg, &new_clip_box);
 8003e1e:	f107 0308 	add.w	r3, r7, #8
 8003e22:	4619      	mov	r1, r3
 8003e24:	6878      	ldr	r0, [r7, #4]
 8003e26:	f7ff ffdd 	bl	8003de4 <ucg_SetClipBox>
}
 8003e2a:	bf00      	nop
 8003e2c:	3710      	adds	r7, #16
 8003e2e:	46bd      	mov	sp, r7
 8003e30:	bd80      	pop	{r7, pc}

08003e32 <ucg_GetDimension>:
/* 
  Query the display dimension from the driver, reset clip window to maximum 
  new dimension
*/
void ucg_GetDimension(ucg_t *ucg)
{
 8003e32:	b580      	push	{r7, lr}
 8003e34:	b082      	sub	sp, #8
 8003e36:	af00      	add	r7, sp, #0
 8003e38:	6078      	str	r0, [r7, #4]
  ucg->device_cb(ucg, UCG_MSG_GET_DIMENSION, &(ucg->dimension));
 8003e3a:	687b      	ldr	r3, [r7, #4]
 8003e3c:	689b      	ldr	r3, [r3, #8]
 8003e3e:	687a      	ldr	r2, [r7, #4]
 8003e40:	3202      	adds	r2, #2
 8003e42:	210f      	movs	r1, #15
 8003e44:	6878      	ldr	r0, [r7, #4]
 8003e46:	4798      	blx	r3
  ucg_SetMaxClipRange(ucg);
 8003e48:	6878      	ldr	r0, [r7, #4]
 8003e4a:	f7ff ffda 	bl	8003e02 <ucg_SetMaxClipRange>
}
 8003e4e:	bf00      	nop
 8003e50:	3708      	adds	r7, #8
 8003e52:	46bd      	mov	sp, r7
 8003e54:	bd80      	pop	{r7, pc}

08003e56 <ucg_DrawPixelWithArg>:

void ucg_DrawPixelWithArg(ucg_t *ucg)
{
 8003e56:	b580      	push	{r7, lr}
 8003e58:	b082      	sub	sp, #8
 8003e5a:	af00      	add	r7, sp, #0
 8003e5c:	6078      	str	r0, [r7, #4]
  ucg->device_cb(ucg, UCG_MSG_DRAW_PIXEL, NULL);
 8003e5e:	687b      	ldr	r3, [r7, #4]
 8003e60:	689b      	ldr	r3, [r3, #8]
 8003e62:	2200      	movs	r2, #0
 8003e64:	2114      	movs	r1, #20
 8003e66:	6878      	ldr	r0, [r7, #4]
 8003e68:	4798      	blx	r3
}
 8003e6a:	bf00      	nop
 8003e6c:	3708      	adds	r7, #8
 8003e6e:	46bd      	mov	sp, r7
 8003e70:	bd80      	pop	{r7, pc}

08003e72 <ucg_DrawL90FXWithArg>:

void ucg_DrawL90FXWithArg(ucg_t *ucg)
{
 8003e72:	b580      	push	{r7, lr}
 8003e74:	b082      	sub	sp, #8
 8003e76:	af00      	add	r7, sp, #0
 8003e78:	6078      	str	r0, [r7, #4]
  ucg->device_cb(ucg, UCG_MSG_DRAW_L90FX, &(ucg->arg));
 8003e7a:	687b      	ldr	r3, [r7, #4]
 8003e7c:	689b      	ldr	r3, [r3, #8]
 8003e7e:	687a      	ldr	r2, [r7, #4]
 8003e80:	3224      	adds	r2, #36	; 0x24
 8003e82:	2115      	movs	r1, #21
 8003e84:	6878      	ldr	r0, [r7, #4]
 8003e86:	4798      	blx	r3
}
 8003e88:	bf00      	nop
 8003e8a:	3708      	adds	r7, #8
 8003e8c:	46bd      	mov	sp, r7
 8003e8e:	bd80      	pop	{r7, pc}

08003e90 <ucg_dev_st7735_18x128x128>:
  UCG_CS(1),					/* disable chip */
  UCG_END(),					/* end of sequence */
};

ucg_int_t ucg_dev_st7735_18x128x128(ucg_t *ucg, ucg_int_t msg, void *data)
{
 8003e90:	b580      	push	{r7, lr}
 8003e92:	b084      	sub	sp, #16
 8003e94:	af00      	add	r7, sp, #0
 8003e96:	60f8      	str	r0, [r7, #12]
 8003e98:	460b      	mov	r3, r1
 8003e9a:	607a      	str	r2, [r7, #4]
 8003e9c:	817b      	strh	r3, [r7, #10]
  switch(msg)
 8003e9e:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8003ea2:	2b0f      	cmp	r3, #15
 8003ea4:	d021      	beq.n	8003eea <ucg_dev_st7735_18x128x128+0x5a>
 8003ea6:	2b0f      	cmp	r3, #15
 8003ea8:	dc27      	bgt.n	8003efa <ucg_dev_st7735_18x128x128+0x6a>
 8003eaa:	2b0a      	cmp	r3, #10
 8003eac:	d002      	beq.n	8003eb4 <ucg_dev_st7735_18x128x128+0x24>
 8003eae:	2b0b      	cmp	r3, #11
 8003eb0:	d012      	beq.n	8003ed8 <ucg_dev_st7735_18x128x128+0x48>
 8003eb2:	e022      	b.n	8003efa <ucg_dev_st7735_18x128x128+0x6a>
  {
    case UCG_MSG_DEV_POWER_UP:
      /* 1. Call to the controller procedures to setup the com interface */
      if ( ucg_dev_ic_st7735_18(ucg, msg, data) == 0 )
 8003eb4:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8003eb8:	687a      	ldr	r2, [r7, #4]
 8003eba:	4619      	mov	r1, r3
 8003ebc:	68f8      	ldr	r0, [r7, #12]
 8003ebe:	f7ff fec9 	bl	8003c54 <ucg_dev_ic_st7735_18>
 8003ec2:	4603      	mov	r3, r0
 8003ec4:	2b00      	cmp	r3, #0
 8003ec6:	d101      	bne.n	8003ecc <ucg_dev_st7735_18x128x128+0x3c>
	return 0;
 8003ec8:	2300      	movs	r3, #0
 8003eca:	e01e      	b.n	8003f0a <ucg_dev_st7735_18x128x128+0x7a>

      /* 2. Send specific init sequence for this display module */
      ucg_com_SendCmdSeq(ucg, ucg_tft_128x160_st7735_init_seq);
 8003ecc:	4911      	ldr	r1, [pc, #68]	; (8003f14 <ucg_dev_st7735_18x128x128+0x84>)
 8003ece:	68f8      	ldr	r0, [r7, #12]
 8003ed0:	f7ff fc36 	bl	8003740 <ucg_com_SendCmdSeq>
      
      return 1;
 8003ed4:	2301      	movs	r3, #1
 8003ed6:	e018      	b.n	8003f0a <ucg_dev_st7735_18x128x128+0x7a>
      
    case UCG_MSG_DEV_POWER_DOWN:
      /* let do power down by the conroller procedures */
      return ucg_dev_ic_st7735_18(ucg, msg, data);  
 8003ed8:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8003edc:	687a      	ldr	r2, [r7, #4]
 8003ede:	4619      	mov	r1, r3
 8003ee0:	68f8      	ldr	r0, [r7, #12]
 8003ee2:	f7ff feb7 	bl	8003c54 <ucg_dev_ic_st7735_18>
 8003ee6:	4603      	mov	r3, r0
 8003ee8:	e00f      	b.n	8003f0a <ucg_dev_st7735_18x128x128+0x7a>
    
    case UCG_MSG_GET_DIMENSION:
      ((ucg_wh_t *)data)->w = 128;
 8003eea:	687b      	ldr	r3, [r7, #4]
 8003eec:	2280      	movs	r2, #128	; 0x80
 8003eee:	801a      	strh	r2, [r3, #0]
      ((ucg_wh_t *)data)->h = 128;
 8003ef0:	687b      	ldr	r3, [r7, #4]
 8003ef2:	2280      	movs	r2, #128	; 0x80
 8003ef4:	805a      	strh	r2, [r3, #2]
      return 1;
 8003ef6:	2301      	movs	r3, #1
 8003ef8:	e007      	b.n	8003f0a <ucg_dev_st7735_18x128x128+0x7a>
  }
  
  /* all other messages are handled by the controller procedures */
  return ucg_dev_ic_st7735_18(ucg, msg, data);  
 8003efa:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8003efe:	687a      	ldr	r2, [r7, #4]
 8003f00:	4619      	mov	r1, r3
 8003f02:	68f8      	ldr	r0, [r7, #12]
 8003f04:	f7ff fea6 	bl	8003c54 <ucg_dev_ic_st7735_18>
 8003f08:	4603      	mov	r3, r0
}
 8003f0a:	4618      	mov	r0, r3
 8003f0c:	3710      	adds	r7, #16
 8003f0e:	46bd      	mov	sp, r7
 8003f10:	bd80      	pop	{r7, pc}
 8003f12:	bf00      	nop
 8003f14:	08006a14 	.word	0x08006a14

08003f18 <ucg_font_get_byte>:
/* low level byte and word access */

/* removed NOINLINE, because it leads to smaller code, might also be faster */
//static uint8_t ucg_font_get_byte(const ucg_fntpgm_uint8_t *font, uint8_t offset) UCG_NOINLINE;
static uint8_t ucg_font_get_byte(const ucg_fntpgm_uint8_t *font, uint8_t offset)
{
 8003f18:	b480      	push	{r7}
 8003f1a:	b083      	sub	sp, #12
 8003f1c:	af00      	add	r7, sp, #0
 8003f1e:	6078      	str	r0, [r7, #4]
 8003f20:	460b      	mov	r3, r1
 8003f22:	70fb      	strb	r3, [r7, #3]
  font += offset;
 8003f24:	78fb      	ldrb	r3, [r7, #3]
 8003f26:	687a      	ldr	r2, [r7, #4]
 8003f28:	4413      	add	r3, r2
 8003f2a:	607b      	str	r3, [r7, #4]
  return ucg_pgm_read( (ucg_pgm_uint8_t *)font );  
 8003f2c:	687b      	ldr	r3, [r7, #4]
 8003f2e:	781b      	ldrb	r3, [r3, #0]
}
 8003f30:	4618      	mov	r0, r3
 8003f32:	370c      	adds	r7, #12
 8003f34:	46bd      	mov	sp, r7
 8003f36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f3a:	4770      	bx	lr

08003f3c <ucg_font_get_word>:

static uint16_t ucg_font_get_word(const ucg_fntpgm_uint8_t *font, uint8_t offset) UCG_NOINLINE; 
static uint16_t ucg_font_get_word(const ucg_fntpgm_uint8_t *font, uint8_t offset)
{
 8003f3c:	b480      	push	{r7}
 8003f3e:	b085      	sub	sp, #20
 8003f40:	af00      	add	r7, sp, #0
 8003f42:	6078      	str	r0, [r7, #4]
 8003f44:	460b      	mov	r3, r1
 8003f46:	70fb      	strb	r3, [r7, #3]
    uint16_t pos;
    font += offset;
 8003f48:	78fb      	ldrb	r3, [r7, #3]
 8003f4a:	687a      	ldr	r2, [r7, #4]
 8003f4c:	4413      	add	r3, r2
 8003f4e:	607b      	str	r3, [r7, #4]
    pos = ucg_pgm_read( (ucg_pgm_uint8_t *)font );
 8003f50:	687b      	ldr	r3, [r7, #4]
 8003f52:	781b      	ldrb	r3, [r3, #0]
 8003f54:	81fb      	strh	r3, [r7, #14]
    font++;
 8003f56:	687b      	ldr	r3, [r7, #4]
 8003f58:	3301      	adds	r3, #1
 8003f5a:	607b      	str	r3, [r7, #4]
    pos <<= 8;
 8003f5c:	89fb      	ldrh	r3, [r7, #14]
 8003f5e:	021b      	lsls	r3, r3, #8
 8003f60:	81fb      	strh	r3, [r7, #14]
    pos += ucg_pgm_read( (ucg_pgm_uint8_t *)font);
 8003f62:	687b      	ldr	r3, [r7, #4]
 8003f64:	781b      	ldrb	r3, [r3, #0]
 8003f66:	b29a      	uxth	r2, r3
 8003f68:	89fb      	ldrh	r3, [r7, #14]
 8003f6a:	4413      	add	r3, r2
 8003f6c:	81fb      	strh	r3, [r7, #14]
    return pos;
 8003f6e:	89fb      	ldrh	r3, [r7, #14]
}
 8003f70:	4618      	mov	r0, r3
 8003f72:	3714      	adds	r7, #20
 8003f74:	46bd      	mov	sp, r7
 8003f76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f7a:	4770      	bx	lr

08003f7c <ucg_read_font_info>:

/*========================================================================*/
/* new font format */
void ucg_read_font_info(ucg_font_info_t *font_info, const ucg_fntpgm_uint8_t *font)
{
 8003f7c:	b580      	push	{r7, lr}
 8003f7e:	b082      	sub	sp, #8
 8003f80:	af00      	add	r7, sp, #0
 8003f82:	6078      	str	r0, [r7, #4]
 8003f84:	6039      	str	r1, [r7, #0]
  /* offset 0 */
  font_info->glyph_cnt = ucg_font_get_byte(font, 0);
 8003f86:	2100      	movs	r1, #0
 8003f88:	6838      	ldr	r0, [r7, #0]
 8003f8a:	f7ff ffc5 	bl	8003f18 <ucg_font_get_byte>
 8003f8e:	4603      	mov	r3, r0
 8003f90:	461a      	mov	r2, r3
 8003f92:	687b      	ldr	r3, [r7, #4]
 8003f94:	701a      	strb	r2, [r3, #0]
  font_info->bbx_mode = ucg_font_get_byte(font, 1);
 8003f96:	2101      	movs	r1, #1
 8003f98:	6838      	ldr	r0, [r7, #0]
 8003f9a:	f7ff ffbd 	bl	8003f18 <ucg_font_get_byte>
 8003f9e:	4603      	mov	r3, r0
 8003fa0:	461a      	mov	r2, r3
 8003fa2:	687b      	ldr	r3, [r7, #4]
 8003fa4:	705a      	strb	r2, [r3, #1]
  font_info->bits_per_0 = ucg_font_get_byte(font, 2);
 8003fa6:	2102      	movs	r1, #2
 8003fa8:	6838      	ldr	r0, [r7, #0]
 8003faa:	f7ff ffb5 	bl	8003f18 <ucg_font_get_byte>
 8003fae:	4603      	mov	r3, r0
 8003fb0:	461a      	mov	r2, r3
 8003fb2:	687b      	ldr	r3, [r7, #4]
 8003fb4:	709a      	strb	r2, [r3, #2]
  font_info->bits_per_1 = ucg_font_get_byte(font, 3);
 8003fb6:	2103      	movs	r1, #3
 8003fb8:	6838      	ldr	r0, [r7, #0]
 8003fba:	f7ff ffad 	bl	8003f18 <ucg_font_get_byte>
 8003fbe:	4603      	mov	r3, r0
 8003fc0:	461a      	mov	r2, r3
 8003fc2:	687b      	ldr	r3, [r7, #4]
 8003fc4:	70da      	strb	r2, [r3, #3]
  
  /* offset 4 */
  font_info->bits_per_char_width = ucg_font_get_byte(font, 4);
 8003fc6:	2104      	movs	r1, #4
 8003fc8:	6838      	ldr	r0, [r7, #0]
 8003fca:	f7ff ffa5 	bl	8003f18 <ucg_font_get_byte>
 8003fce:	4603      	mov	r3, r0
 8003fd0:	461a      	mov	r2, r3
 8003fd2:	687b      	ldr	r3, [r7, #4]
 8003fd4:	711a      	strb	r2, [r3, #4]
  font_info->bits_per_char_height = ucg_font_get_byte(font, 5);
 8003fd6:	2105      	movs	r1, #5
 8003fd8:	6838      	ldr	r0, [r7, #0]
 8003fda:	f7ff ff9d 	bl	8003f18 <ucg_font_get_byte>
 8003fde:	4603      	mov	r3, r0
 8003fe0:	461a      	mov	r2, r3
 8003fe2:	687b      	ldr	r3, [r7, #4]
 8003fe4:	715a      	strb	r2, [r3, #5]
  font_info->bits_per_char_x = ucg_font_get_byte(font, 6);
 8003fe6:	2106      	movs	r1, #6
 8003fe8:	6838      	ldr	r0, [r7, #0]
 8003fea:	f7ff ff95 	bl	8003f18 <ucg_font_get_byte>
 8003fee:	4603      	mov	r3, r0
 8003ff0:	461a      	mov	r2, r3
 8003ff2:	687b      	ldr	r3, [r7, #4]
 8003ff4:	719a      	strb	r2, [r3, #6]
  font_info->bits_per_char_y = ucg_font_get_byte(font, 7);
 8003ff6:	2107      	movs	r1, #7
 8003ff8:	6838      	ldr	r0, [r7, #0]
 8003ffa:	f7ff ff8d 	bl	8003f18 <ucg_font_get_byte>
 8003ffe:	4603      	mov	r3, r0
 8004000:	461a      	mov	r2, r3
 8004002:	687b      	ldr	r3, [r7, #4]
 8004004:	71da      	strb	r2, [r3, #7]
  font_info->bits_per_delta_x = ucg_font_get_byte(font, 8);
 8004006:	2108      	movs	r1, #8
 8004008:	6838      	ldr	r0, [r7, #0]
 800400a:	f7ff ff85 	bl	8003f18 <ucg_font_get_byte>
 800400e:	4603      	mov	r3, r0
 8004010:	461a      	mov	r2, r3
 8004012:	687b      	ldr	r3, [r7, #4]
 8004014:	721a      	strb	r2, [r3, #8]
  
  /* offset 9 */
  font_info->max_char_width = ucg_font_get_byte(font, 9);
 8004016:	2109      	movs	r1, #9
 8004018:	6838      	ldr	r0, [r7, #0]
 800401a:	f7ff ff7d 	bl	8003f18 <ucg_font_get_byte>
 800401e:	4603      	mov	r3, r0
 8004020:	b25a      	sxtb	r2, r3
 8004022:	687b      	ldr	r3, [r7, #4]
 8004024:	725a      	strb	r2, [r3, #9]
  font_info->max_char_height = ucg_font_get_byte(font, 10);
 8004026:	210a      	movs	r1, #10
 8004028:	6838      	ldr	r0, [r7, #0]
 800402a:	f7ff ff75 	bl	8003f18 <ucg_font_get_byte>
 800402e:	4603      	mov	r3, r0
 8004030:	b25a      	sxtb	r2, r3
 8004032:	687b      	ldr	r3, [r7, #4]
 8004034:	729a      	strb	r2, [r3, #10]
  font_info->x_offset = ucg_font_get_byte(font, 11);
 8004036:	210b      	movs	r1, #11
 8004038:	6838      	ldr	r0, [r7, #0]
 800403a:	f7ff ff6d 	bl	8003f18 <ucg_font_get_byte>
 800403e:	4603      	mov	r3, r0
 8004040:	b25a      	sxtb	r2, r3
 8004042:	687b      	ldr	r3, [r7, #4]
 8004044:	72da      	strb	r2, [r3, #11]
  font_info->y_offset = ucg_font_get_byte(font, 12);
 8004046:	210c      	movs	r1, #12
 8004048:	6838      	ldr	r0, [r7, #0]
 800404a:	f7ff ff65 	bl	8003f18 <ucg_font_get_byte>
 800404e:	4603      	mov	r3, r0
 8004050:	b25a      	sxtb	r2, r3
 8004052:	687b      	ldr	r3, [r7, #4]
 8004054:	731a      	strb	r2, [r3, #12]
  
  /* offset 13 */
  font_info->ascent_A = ucg_font_get_byte(font, 13);
 8004056:	210d      	movs	r1, #13
 8004058:	6838      	ldr	r0, [r7, #0]
 800405a:	f7ff ff5d 	bl	8003f18 <ucg_font_get_byte>
 800405e:	4603      	mov	r3, r0
 8004060:	b25a      	sxtb	r2, r3
 8004062:	687b      	ldr	r3, [r7, #4]
 8004064:	735a      	strb	r2, [r3, #13]
  font_info->descent_g = ucg_font_get_byte(font, 14);
 8004066:	210e      	movs	r1, #14
 8004068:	6838      	ldr	r0, [r7, #0]
 800406a:	f7ff ff55 	bl	8003f18 <ucg_font_get_byte>
 800406e:	4603      	mov	r3, r0
 8004070:	b25a      	sxtb	r2, r3
 8004072:	687b      	ldr	r3, [r7, #4]
 8004074:	739a      	strb	r2, [r3, #14]
  font_info->ascent_para = ucg_font_get_byte(font, 15);
 8004076:	210f      	movs	r1, #15
 8004078:	6838      	ldr	r0, [r7, #0]
 800407a:	f7ff ff4d 	bl	8003f18 <ucg_font_get_byte>
 800407e:	4603      	mov	r3, r0
 8004080:	b25a      	sxtb	r2, r3
 8004082:	687b      	ldr	r3, [r7, #4]
 8004084:	73da      	strb	r2, [r3, #15]
  font_info->descent_para = ucg_font_get_byte(font, 16);
 8004086:	2110      	movs	r1, #16
 8004088:	6838      	ldr	r0, [r7, #0]
 800408a:	f7ff ff45 	bl	8003f18 <ucg_font_get_byte>
 800408e:	4603      	mov	r3, r0
 8004090:	b25a      	sxtb	r2, r3
 8004092:	687b      	ldr	r3, [r7, #4]
 8004094:	741a      	strb	r2, [r3, #16]
  
  /* offset 17 */
  font_info->start_pos_upper_A = ucg_font_get_word(font, 17);
 8004096:	2111      	movs	r1, #17
 8004098:	6838      	ldr	r0, [r7, #0]
 800409a:	f7ff ff4f 	bl	8003f3c <ucg_font_get_word>
 800409e:	4603      	mov	r3, r0
 80040a0:	461a      	mov	r2, r3
 80040a2:	687b      	ldr	r3, [r7, #4]
 80040a4:	825a      	strh	r2, [r3, #18]
  font_info->start_pos_lower_a = ucg_font_get_word(font, 19);  
 80040a6:	2113      	movs	r1, #19
 80040a8:	6838      	ldr	r0, [r7, #0]
 80040aa:	f7ff ff47 	bl	8003f3c <ucg_font_get_word>
 80040ae:	4603      	mov	r3, r0
 80040b0:	461a      	mov	r2, r3
 80040b2:	687b      	ldr	r3, [r7, #4]
 80040b4:	829a      	strh	r2, [r3, #20]
}
 80040b6:	bf00      	nop
 80040b8:	3708      	adds	r7, #8
 80040ba:	46bd      	mov	sp, r7
 80040bc:	bd80      	pop	{r7, pc}

080040be <ucg_font_decode_get_unsigned_bits>:
/*========================================================================*/
/* glyph handling */

/* optimized */
uint8_t ucg_font_decode_get_unsigned_bits(ucg_font_decode_t *f, uint8_t cnt) 
{
 80040be:	b480      	push	{r7}
 80040c0:	b085      	sub	sp, #20
 80040c2:	af00      	add	r7, sp, #0
 80040c4:	6078      	str	r0, [r7, #4]
 80040c6:	460b      	mov	r3, r1
 80040c8:	70fb      	strb	r3, [r7, #3]
  uint8_t val;
  uint8_t bit_pos = f->decode_bit_pos;
 80040ca:	687b      	ldr	r3, [r7, #4]
 80040cc:	7b1b      	ldrb	r3, [r3, #12]
 80040ce:	737b      	strb	r3, [r7, #13]
  uint8_t bit_pos_plus_cnt;
  
  //val = *(f->decode_ptr);
  val = ucg_pgm_read( (ucg_pgm_uint8_t *)(f->decode_ptr) );  
 80040d0:	687b      	ldr	r3, [r7, #4]
 80040d2:	681b      	ldr	r3, [r3, #0]
 80040d4:	781b      	ldrb	r3, [r3, #0]
 80040d6:	73fb      	strb	r3, [r7, #15]
  
  val >>= bit_pos;
 80040d8:	7bfa      	ldrb	r2, [r7, #15]
 80040da:	7b7b      	ldrb	r3, [r7, #13]
 80040dc:	fa42 f303 	asr.w	r3, r2, r3
 80040e0:	73fb      	strb	r3, [r7, #15]
  bit_pos_plus_cnt = bit_pos;
 80040e2:	7b7b      	ldrb	r3, [r7, #13]
 80040e4:	73bb      	strb	r3, [r7, #14]
  bit_pos_plus_cnt += cnt;
 80040e6:	7bba      	ldrb	r2, [r7, #14]
 80040e8:	78fb      	ldrb	r3, [r7, #3]
 80040ea:	4413      	add	r3, r2
 80040ec:	73bb      	strb	r3, [r7, #14]
  if ( bit_pos_plus_cnt >= 8 )
 80040ee:	7bbb      	ldrb	r3, [r7, #14]
 80040f0:	2b07      	cmp	r3, #7
 80040f2:	d91a      	bls.n	800412a <ucg_font_decode_get_unsigned_bits+0x6c>
  {
    uint8_t s = 8;
 80040f4:	2308      	movs	r3, #8
 80040f6:	733b      	strb	r3, [r7, #12]
    s -= bit_pos;
 80040f8:	7b3a      	ldrb	r2, [r7, #12]
 80040fa:	7b7b      	ldrb	r3, [r7, #13]
 80040fc:	1ad3      	subs	r3, r2, r3
 80040fe:	733b      	strb	r3, [r7, #12]
    f->decode_ptr++;
 8004100:	687b      	ldr	r3, [r7, #4]
 8004102:	681b      	ldr	r3, [r3, #0]
 8004104:	1c5a      	adds	r2, r3, #1
 8004106:	687b      	ldr	r3, [r7, #4]
 8004108:	601a      	str	r2, [r3, #0]
    //val |= *(f->decode_ptr) << (8-bit_pos);
    val |= ucg_pgm_read( (ucg_pgm_uint8_t *)(f->decode_ptr) ) << (s);
 800410a:	687b      	ldr	r3, [r7, #4]
 800410c:	681b      	ldr	r3, [r3, #0]
 800410e:	781b      	ldrb	r3, [r3, #0]
 8004110:	461a      	mov	r2, r3
 8004112:	7b3b      	ldrb	r3, [r7, #12]
 8004114:	fa02 f303 	lsl.w	r3, r2, r3
 8004118:	b25a      	sxtb	r2, r3
 800411a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 800411e:	4313      	orrs	r3, r2
 8004120:	b25b      	sxtb	r3, r3
 8004122:	73fb      	strb	r3, [r7, #15]
    //bit_pos -= 8;
    bit_pos_plus_cnt -= 8;
 8004124:	7bbb      	ldrb	r3, [r7, #14]
 8004126:	3b08      	subs	r3, #8
 8004128:	73bb      	strb	r3, [r7, #14]
  }
  val &= (1U<<cnt)-1;
 800412a:	78fb      	ldrb	r3, [r7, #3]
 800412c:	f04f 32ff 	mov.w	r2, #4294967295
 8004130:	fa02 f303 	lsl.w	r3, r2, r3
 8004134:	b2db      	uxtb	r3, r3
 8004136:	43db      	mvns	r3, r3
 8004138:	b2da      	uxtb	r2, r3
 800413a:	7bfb      	ldrb	r3, [r7, #15]
 800413c:	4013      	ands	r3, r2
 800413e:	73fb      	strb	r3, [r7, #15]
  //bit_pos += cnt;
  
  f->decode_bit_pos = bit_pos_plus_cnt;
 8004140:	687b      	ldr	r3, [r7, #4]
 8004142:	7bba      	ldrb	r2, [r7, #14]
 8004144:	731a      	strb	r2, [r3, #12]
  return val;
 8004146:	7bfb      	ldrb	r3, [r7, #15]
}
 8004148:	4618      	mov	r0, r3
 800414a:	3714      	adds	r7, #20
 800414c:	46bd      	mov	sp, r7
 800414e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004152:	4770      	bx	lr

08004154 <ucg_font_decode_get_signed_bits>:
	r = bits(x)+1;

*/
/* optimized */
int8_t ucg_font_decode_get_signed_bits(ucg_font_decode_t *f, uint8_t cnt)
{
 8004154:	b580      	push	{r7, lr}
 8004156:	b084      	sub	sp, #16
 8004158:	af00      	add	r7, sp, #0
 800415a:	6078      	str	r0, [r7, #4]
 800415c:	460b      	mov	r3, r1
 800415e:	70fb      	strb	r3, [r7, #3]
  int8_t v, d;
  v = (int8_t)ucg_font_decode_get_unsigned_bits(f, cnt);
 8004160:	78fb      	ldrb	r3, [r7, #3]
 8004162:	4619      	mov	r1, r3
 8004164:	6878      	ldr	r0, [r7, #4]
 8004166:	f7ff ffaa 	bl	80040be <ucg_font_decode_get_unsigned_bits>
 800416a:	4603      	mov	r3, r0
 800416c:	73fb      	strb	r3, [r7, #15]
  d = 1;
 800416e:	2301      	movs	r3, #1
 8004170:	73bb      	strb	r3, [r7, #14]
  cnt--;
 8004172:	78fb      	ldrb	r3, [r7, #3]
 8004174:	3b01      	subs	r3, #1
 8004176:	70fb      	strb	r3, [r7, #3]
  d <<= cnt;
 8004178:	f997 200e 	ldrsb.w	r2, [r7, #14]
 800417c:	78fb      	ldrb	r3, [r7, #3]
 800417e:	fa02 f303 	lsl.w	r3, r2, r3
 8004182:	73bb      	strb	r3, [r7, #14]
  v -= d;
 8004184:	7bfa      	ldrb	r2, [r7, #15]
 8004186:	7bbb      	ldrb	r3, [r7, #14]
 8004188:	1ad3      	subs	r3, r2, r3
 800418a:	b2db      	uxtb	r3, r3
 800418c:	73fb      	strb	r3, [r7, #15]
  return v;
 800418e:	f997 300f 	ldrsb.w	r3, [r7, #15]
  //return (int8_t)ucg_font_decode_get_unsigned_bits(f, cnt) - ((1<<cnt)>>1);
}
 8004192:	4618      	mov	r0, r3
 8004194:	3710      	adds	r7, #16
 8004196:	46bd      	mov	sp, r7
 8004198:	bd80      	pop	{r7, pc}

0800419a <ucg_add_vector_y>:
}
*/

static ucg_int_t ucg_add_vector_y(ucg_int_t dy, int8_t x, int8_t y, uint8_t dir) UCG_NOINLINE;
static ucg_int_t ucg_add_vector_y(ucg_int_t dy, int8_t x, int8_t y, uint8_t dir)
{
 800419a:	b490      	push	{r4, r7}
 800419c:	b082      	sub	sp, #8
 800419e:	af00      	add	r7, sp, #0
 80041a0:	4604      	mov	r4, r0
 80041a2:	4608      	mov	r0, r1
 80041a4:	4611      	mov	r1, r2
 80041a6:	461a      	mov	r2, r3
 80041a8:	4623      	mov	r3, r4
 80041aa:	80fb      	strh	r3, [r7, #6]
 80041ac:	4603      	mov	r3, r0
 80041ae:	717b      	strb	r3, [r7, #5]
 80041b0:	460b      	mov	r3, r1
 80041b2:	713b      	strb	r3, [r7, #4]
 80041b4:	4613      	mov	r3, r2
 80041b6:	70fb      	strb	r3, [r7, #3]
  switch(dir)
 80041b8:	78fb      	ldrb	r3, [r7, #3]
 80041ba:	2b02      	cmp	r3, #2
 80041bc:	d016      	beq.n	80041ec <ucg_add_vector_y+0x52>
 80041be:	2b02      	cmp	r3, #2
 80041c0:	dc1c      	bgt.n	80041fc <ucg_add_vector_y+0x62>
 80041c2:	2b00      	cmp	r3, #0
 80041c4:	d002      	beq.n	80041cc <ucg_add_vector_y+0x32>
 80041c6:	2b01      	cmp	r3, #1
 80041c8:	d008      	beq.n	80041dc <ucg_add_vector_y+0x42>
 80041ca:	e017      	b.n	80041fc <ucg_add_vector_y+0x62>
  {
    case 0:
      dy += y;
 80041cc:	f997 3004 	ldrsb.w	r3, [r7, #4]
 80041d0:	b29a      	uxth	r2, r3
 80041d2:	88fb      	ldrh	r3, [r7, #6]
 80041d4:	4413      	add	r3, r2
 80041d6:	b29b      	uxth	r3, r3
 80041d8:	80fb      	strh	r3, [r7, #6]
      break;
 80041da:	e017      	b.n	800420c <ucg_add_vector_y+0x72>
    case 1:
      dy += x;
 80041dc:	f997 3005 	ldrsb.w	r3, [r7, #5]
 80041e0:	b29a      	uxth	r2, r3
 80041e2:	88fb      	ldrh	r3, [r7, #6]
 80041e4:	4413      	add	r3, r2
 80041e6:	b29b      	uxth	r3, r3
 80041e8:	80fb      	strh	r3, [r7, #6]
      break;
 80041ea:	e00f      	b.n	800420c <ucg_add_vector_y+0x72>
    case 2:
      dy -= y;
 80041ec:	88fa      	ldrh	r2, [r7, #6]
 80041ee:	f997 3004 	ldrsb.w	r3, [r7, #4]
 80041f2:	b29b      	uxth	r3, r3
 80041f4:	1ad3      	subs	r3, r2, r3
 80041f6:	b29b      	uxth	r3, r3
 80041f8:	80fb      	strh	r3, [r7, #6]
      break;
 80041fa:	e007      	b.n	800420c <ucg_add_vector_y+0x72>
    default:
      dy -= x;
 80041fc:	88fa      	ldrh	r2, [r7, #6]
 80041fe:	f997 3005 	ldrsb.w	r3, [r7, #5]
 8004202:	b29b      	uxth	r3, r3
 8004204:	1ad3      	subs	r3, r2, r3
 8004206:	b29b      	uxth	r3, r3
 8004208:	80fb      	strh	r3, [r7, #6]
      break;      
 800420a:	bf00      	nop
  }
  return dy;
 800420c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
}
 8004210:	4618      	mov	r0, r3
 8004212:	3708      	adds	r7, #8
 8004214:	46bd      	mov	sp, r7
 8004216:	bc90      	pop	{r4, r7}
 8004218:	4770      	bx	lr

0800421a <ucg_add_vector_x>:

static ucg_int_t ucg_add_vector_x(ucg_int_t dx, int8_t x, int8_t y, uint8_t dir) UCG_NOINLINE;
static ucg_int_t ucg_add_vector_x(ucg_int_t dx, int8_t x, int8_t y, uint8_t dir)
{
 800421a:	b490      	push	{r4, r7}
 800421c:	b082      	sub	sp, #8
 800421e:	af00      	add	r7, sp, #0
 8004220:	4604      	mov	r4, r0
 8004222:	4608      	mov	r0, r1
 8004224:	4611      	mov	r1, r2
 8004226:	461a      	mov	r2, r3
 8004228:	4623      	mov	r3, r4
 800422a:	80fb      	strh	r3, [r7, #6]
 800422c:	4603      	mov	r3, r0
 800422e:	717b      	strb	r3, [r7, #5]
 8004230:	460b      	mov	r3, r1
 8004232:	713b      	strb	r3, [r7, #4]
 8004234:	4613      	mov	r3, r2
 8004236:	70fb      	strb	r3, [r7, #3]
  switch(dir)
 8004238:	78fb      	ldrb	r3, [r7, #3]
 800423a:	2b02      	cmp	r3, #2
 800423c:	d016      	beq.n	800426c <ucg_add_vector_x+0x52>
 800423e:	2b02      	cmp	r3, #2
 8004240:	dc1c      	bgt.n	800427c <ucg_add_vector_x+0x62>
 8004242:	2b00      	cmp	r3, #0
 8004244:	d002      	beq.n	800424c <ucg_add_vector_x+0x32>
 8004246:	2b01      	cmp	r3, #1
 8004248:	d008      	beq.n	800425c <ucg_add_vector_x+0x42>
 800424a:	e017      	b.n	800427c <ucg_add_vector_x+0x62>
  {
    case 0:
      dx += x;
 800424c:	f997 3005 	ldrsb.w	r3, [r7, #5]
 8004250:	b29a      	uxth	r2, r3
 8004252:	88fb      	ldrh	r3, [r7, #6]
 8004254:	4413      	add	r3, r2
 8004256:	b29b      	uxth	r3, r3
 8004258:	80fb      	strh	r3, [r7, #6]
      break;
 800425a:	e017      	b.n	800428c <ucg_add_vector_x+0x72>
    case 1:
      dx -= y;
 800425c:	88fa      	ldrh	r2, [r7, #6]
 800425e:	f997 3004 	ldrsb.w	r3, [r7, #4]
 8004262:	b29b      	uxth	r3, r3
 8004264:	1ad3      	subs	r3, r2, r3
 8004266:	b29b      	uxth	r3, r3
 8004268:	80fb      	strh	r3, [r7, #6]
      break;
 800426a:	e00f      	b.n	800428c <ucg_add_vector_x+0x72>
    case 2:
      dx -= x;
 800426c:	88fa      	ldrh	r2, [r7, #6]
 800426e:	f997 3005 	ldrsb.w	r3, [r7, #5]
 8004272:	b29b      	uxth	r3, r3
 8004274:	1ad3      	subs	r3, r2, r3
 8004276:	b29b      	uxth	r3, r3
 8004278:	80fb      	strh	r3, [r7, #6]
      break;
 800427a:	e007      	b.n	800428c <ucg_add_vector_x+0x72>
    default:
      dx += y;
 800427c:	f997 3004 	ldrsb.w	r3, [r7, #4]
 8004280:	b29a      	uxth	r2, r3
 8004282:	88fb      	ldrh	r3, [r7, #6]
 8004284:	4413      	add	r3, r2
 8004286:	b29b      	uxth	r3, r3
 8004288:	80fb      	strh	r3, [r7, #6]
      break;      
 800428a:	bf00      	nop
  }
  return dx;
 800428c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
}
 8004290:	4618      	mov	r0, r3
 8004292:	3708      	adds	r7, #8
 8004294:	46bd      	mov	sp, r7
 8004296:	bc90      	pop	{r4, r7}
 8004298:	4770      	bx	lr

0800429a <ucg_font_decode_len>:
  Called by:
    ucg_font_decode_glyph()
*/
/* optimized */
void ucg_font_decode_len(ucg_t *ucg, uint8_t len, uint8_t is_foreground)
{
 800429a:	b590      	push	{r4, r7, lr}
 800429c:	b089      	sub	sp, #36	; 0x24
 800429e:	af02      	add	r7, sp, #8
 80042a0:	6078      	str	r0, [r7, #4]
 80042a2:	460b      	mov	r3, r1
 80042a4:	70fb      	strb	r3, [r7, #3]
 80042a6:	4613      	mov	r3, r2
 80042a8:	70bb      	strb	r3, [r7, #2]
  uint8_t lx,ly;
  
  /* target position on the screen */
  ucg_int_t x, y;
  
  ucg_font_decode_t *decode = &(ucg->font_decode);
 80042aa:	687b      	ldr	r3, [r7, #4]
 80042ac:	3380      	adds	r3, #128	; 0x80
 80042ae:	613b      	str	r3, [r7, #16]
  
  cnt = len;
 80042b0:	78fb      	ldrb	r3, [r7, #3]
 80042b2:	75fb      	strb	r3, [r7, #23]
  
  /* get the local position */
  lx = decode->x;
 80042b4:	693b      	ldr	r3, [r7, #16]
 80042b6:	f993 3008 	ldrsb.w	r3, [r3, #8]
 80042ba:	757b      	strb	r3, [r7, #21]
  ly = decode->y;
 80042bc:	693b      	ldr	r3, [r7, #16]
 80042be:	f993 3009 	ldrsb.w	r3, [r3, #9]
 80042c2:	753b      	strb	r3, [r7, #20]
  
  for(;;)
  {
    /* calculate the number of pixel to the right edge of the glyph */
    rem = decode->glyph_width;
 80042c4:	693b      	ldr	r3, [r7, #16]
 80042c6:	f993 300a 	ldrsb.w	r3, [r3, #10]
 80042ca:	73fb      	strb	r3, [r7, #15]
    rem -= lx;
 80042cc:	7bfa      	ldrb	r2, [r7, #15]
 80042ce:	7d7b      	ldrb	r3, [r7, #21]
 80042d0:	1ad3      	subs	r3, r2, r3
 80042d2:	73fb      	strb	r3, [r7, #15]
    
    /* calculate how many pixel to draw. This is either to the right edge */
    /* or lesser, if not enough pixel are left */
    current = rem;
 80042d4:	7bfb      	ldrb	r3, [r7, #15]
 80042d6:	75bb      	strb	r3, [r7, #22]
    if ( cnt < rem )
 80042d8:	7dfa      	ldrb	r2, [r7, #23]
 80042da:	7bfb      	ldrb	r3, [r7, #15]
 80042dc:	429a      	cmp	r2, r3
 80042de:	d201      	bcs.n	80042e4 <ucg_font_decode_len+0x4a>
      current = cnt;
 80042e0:	7dfb      	ldrb	r3, [r7, #23]
 80042e2:	75bb      	strb	r3, [r7, #22]
    
    /* now draw the line, but apply the rotation around the glyph target position */
    //ucg_font_decode_draw_pixel(ucg, lx, ly, current, is_foreground);

    /* get target position */
    x = decode->target_x;
 80042e4:	693b      	ldr	r3, [r7, #16]
 80042e6:	889b      	ldrh	r3, [r3, #4]
 80042e8:	81bb      	strh	r3, [r7, #12]
    y = decode->target_y;
 80042ea:	693b      	ldr	r3, [r7, #16]
 80042ec:	88db      	ldrh	r3, [r3, #6]
 80042ee:	817b      	strh	r3, [r7, #10]

    /* apply rotation */
    x = ucg_add_vector_x(x, lx, ly, decode->dir);
 80042f0:	f997 1015 	ldrsb.w	r1, [r7, #21]
 80042f4:	f997 2014 	ldrsb.w	r2, [r7, #20]
 80042f8:	693b      	ldr	r3, [r7, #16]
 80042fa:	7b9b      	ldrb	r3, [r3, #14]
 80042fc:	f9b7 000c 	ldrsh.w	r0, [r7, #12]
 8004300:	f7ff ff8b 	bl	800421a <ucg_add_vector_x>
 8004304:	4603      	mov	r3, r0
 8004306:	81bb      	strh	r3, [r7, #12]
    y = ucg_add_vector_y(y, lx, ly, decode->dir);
 8004308:	f997 1015 	ldrsb.w	r1, [r7, #21]
 800430c:	f997 2014 	ldrsb.w	r2, [r7, #20]
 8004310:	693b      	ldr	r3, [r7, #16]
 8004312:	7b9b      	ldrb	r3, [r3, #14]
 8004314:	f9b7 000a 	ldrsh.w	r0, [r7, #10]
 8004318:	f7ff ff3f 	bl	800419a <ucg_add_vector_y>
 800431c:	4603      	mov	r3, r0
 800431e:	817b      	strh	r3, [r7, #10]
    
    /* draw foreground and background (if required) */
    if ( is_foreground )
 8004320:	78bb      	ldrb	r3, [r7, #2]
 8004322:	2b00      	cmp	r3, #0
 8004324:	d010      	beq.n	8004348 <ucg_font_decode_len+0xae>
    {
      ucg_Draw90Line(ucg, x, y, current, decode->dir, 0);
 8004326:	7dbb      	ldrb	r3, [r7, #22]
 8004328:	b218      	sxth	r0, r3
 800432a:	693b      	ldr	r3, [r7, #16]
 800432c:	7b9b      	ldrb	r3, [r3, #14]
 800432e:	b21b      	sxth	r3, r3
 8004330:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8004334:	f9b7 100c 	ldrsh.w	r1, [r7, #12]
 8004338:	2400      	movs	r4, #0
 800433a:	9401      	str	r4, [sp, #4]
 800433c:	9300      	str	r3, [sp, #0]
 800433e:	4603      	mov	r3, r0
 8004340:	6878      	ldr	r0, [r7, #4]
 8004342:	f000 fbbf 	bl	8004ac4 <ucg_Draw90Line>
 8004346:	e013      	b.n	8004370 <ucg_font_decode_len+0xd6>
    }
    else if ( decode->is_transparent == 0 )    
 8004348:	693b      	ldr	r3, [r7, #16]
 800434a:	7b5b      	ldrb	r3, [r3, #13]
 800434c:	2b00      	cmp	r3, #0
 800434e:	d10f      	bne.n	8004370 <ucg_font_decode_len+0xd6>
    {
      ucg_Draw90Line(ucg, x, y, current, decode->dir, 1);
 8004350:	7dbb      	ldrb	r3, [r7, #22]
 8004352:	b218      	sxth	r0, r3
 8004354:	693b      	ldr	r3, [r7, #16]
 8004356:	7b9b      	ldrb	r3, [r3, #14]
 8004358:	b21b      	sxth	r3, r3
 800435a:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 800435e:	f9b7 100c 	ldrsh.w	r1, [r7, #12]
 8004362:	2401      	movs	r4, #1
 8004364:	9401      	str	r4, [sp, #4]
 8004366:	9300      	str	r3, [sp, #0]
 8004368:	4603      	mov	r3, r0
 800436a:	6878      	ldr	r0, [r7, #4]
 800436c:	f000 fbaa 	bl	8004ac4 <ucg_Draw90Line>
    }
    
    /* check, whether the end of the run length code has been reached */
    if ( cnt < rem )
 8004370:	7dfa      	ldrb	r2, [r7, #23]
 8004372:	7bfb      	ldrb	r3, [r7, #15]
 8004374:	429a      	cmp	r2, r3
 8004376:	d309      	bcc.n	800438c <ucg_font_decode_len+0xf2>
      break;
    cnt -= rem;
 8004378:	7dfa      	ldrb	r2, [r7, #23]
 800437a:	7bfb      	ldrb	r3, [r7, #15]
 800437c:	1ad3      	subs	r3, r2, r3
 800437e:	75fb      	strb	r3, [r7, #23]
    lx = 0;
 8004380:	2300      	movs	r3, #0
 8004382:	757b      	strb	r3, [r7, #21]
    ly++;
 8004384:	7d3b      	ldrb	r3, [r7, #20]
 8004386:	3301      	adds	r3, #1
 8004388:	753b      	strb	r3, [r7, #20]
    rem = decode->glyph_width;
 800438a:	e79b      	b.n	80042c4 <ucg_font_decode_len+0x2a>
      break;
 800438c:	bf00      	nop
  }
  //ucg_font_decode_draw_pixel(ucg, x,y, cnt, is_foreground);
  lx += cnt;
 800438e:	7d7a      	ldrb	r2, [r7, #21]
 8004390:	7dfb      	ldrb	r3, [r7, #23]
 8004392:	4413      	add	r3, r2
 8004394:	757b      	strb	r3, [r7, #21]
  
  decode->x = lx;
 8004396:	f997 2015 	ldrsb.w	r2, [r7, #21]
 800439a:	693b      	ldr	r3, [r7, #16]
 800439c:	721a      	strb	r2, [r3, #8]
  decode->y = ly;
 800439e:	f997 2014 	ldrsb.w	r2, [r7, #20]
 80043a2:	693b      	ldr	r3, [r7, #16]
 80043a4:	725a      	strb	r2, [r3, #9]
  
}
 80043a6:	bf00      	nop
 80043a8:	371c      	adds	r7, #28
 80043aa:	46bd      	mov	sp, r7
 80043ac:	bd90      	pop	{r4, r7, pc}

080043ae <ucg_font_setup_decode>:

static void ucg_font_setup_decode(ucg_t *ucg, const uint8_t *glyph_data)
{
 80043ae:	b580      	push	{r7, lr}
 80043b0:	b084      	sub	sp, #16
 80043b2:	af00      	add	r7, sp, #0
 80043b4:	6078      	str	r0, [r7, #4]
 80043b6:	6039      	str	r1, [r7, #0]
  ucg_font_decode_t *decode = &(ucg->font_decode);
 80043b8:	687b      	ldr	r3, [r7, #4]
 80043ba:	3380      	adds	r3, #128	; 0x80
 80043bc:	60fb      	str	r3, [r7, #12]
  decode->decode_ptr = glyph_data;
 80043be:	68fb      	ldr	r3, [r7, #12]
 80043c0:	683a      	ldr	r2, [r7, #0]
 80043c2:	601a      	str	r2, [r3, #0]
  decode->decode_bit_pos = 0;
 80043c4:	68fb      	ldr	r3, [r7, #12]
 80043c6:	2200      	movs	r2, #0
 80043c8:	731a      	strb	r2, [r3, #12]
  
  decode->decode_ptr += 1;
 80043ca:	68fb      	ldr	r3, [r7, #12]
 80043cc:	681b      	ldr	r3, [r3, #0]
 80043ce:	1c5a      	adds	r2, r3, #1
 80043d0:	68fb      	ldr	r3, [r7, #12]
 80043d2:	601a      	str	r2, [r3, #0]
  decode->decode_ptr += 1;
 80043d4:	68fb      	ldr	r3, [r7, #12]
 80043d6:	681b      	ldr	r3, [r3, #0]
 80043d8:	1c5a      	adds	r2, r3, #1
 80043da:	68fb      	ldr	r3, [r7, #12]
 80043dc:	601a      	str	r2, [r3, #0]
  
  decode->glyph_width = ucg_font_decode_get_unsigned_bits(decode, ucg->font_info.bits_per_char_width);
 80043de:	687b      	ldr	r3, [r7, #4]
 80043e0:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
 80043e4:	4619      	mov	r1, r3
 80043e6:	68f8      	ldr	r0, [r7, #12]
 80043e8:	f7ff fe69 	bl	80040be <ucg_font_decode_get_unsigned_bits>
 80043ec:	4603      	mov	r3, r0
 80043ee:	b25a      	sxtb	r2, r3
 80043f0:	68fb      	ldr	r3, [r7, #12]
 80043f2:	729a      	strb	r2, [r3, #10]
  decode->glyph_height = ucg_font_decode_get_unsigned_bits(decode,ucg->font_info.bits_per_char_height);
 80043f4:	687b      	ldr	r3, [r7, #4]
 80043f6:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
 80043fa:	4619      	mov	r1, r3
 80043fc:	68f8      	ldr	r0, [r7, #12]
 80043fe:	f7ff fe5e 	bl	80040be <ucg_font_decode_get_unsigned_bits>
 8004402:	4603      	mov	r3, r0
 8004404:	b25a      	sxtb	r2, r3
 8004406:	68fb      	ldr	r3, [r7, #12]
 8004408:	72da      	strb	r2, [r3, #11]
}
 800440a:	bf00      	nop
 800440c:	3710      	adds	r7, #16
 800440e:	46bd      	mov	sp, r7
 8004410:	bd80      	pop	{r7, pc}

08004412 <ucg_font_decode_glyph>:
    ucg_font_decode_len()
*/
/* optimized */

int8_t ucg_font_decode_glyph(ucg_t *ucg, const uint8_t *glyph_data)
{
 8004412:	b580      	push	{r7, lr}
 8004414:	b084      	sub	sp, #16
 8004416:	af00      	add	r7, sp, #0
 8004418:	6078      	str	r0, [r7, #4]
 800441a:	6039      	str	r1, [r7, #0]
  int8_t d;
  int8_t h;
//  ucg_scan = ucg;
//  decode = &(ucg_scan->font_decode);
    
  ucg_font_setup_decode(ucg, glyph_data);
 800441c:	6839      	ldr	r1, [r7, #0]
 800441e:	6878      	ldr	r0, [r7, #4]
 8004420:	f7ff ffc5 	bl	80043ae <ucg_font_setup_decode>
  h = ucg->font_decode.glyph_height;
 8004424:	687b      	ldr	r3, [r7, #4]
 8004426:	f893 308b 	ldrb.w	r3, [r3, #139]	; 0x8b
 800442a:	73fb      	strb	r3, [r7, #15]
  
  x = ucg_font_decode_get_signed_bits(&ucg->font_decode, ucg->font_info.bits_per_char_x);
 800442c:	687b      	ldr	r3, [r7, #4]
 800442e:	f103 0280 	add.w	r2, r3, #128	; 0x80
 8004432:	687b      	ldr	r3, [r7, #4]
 8004434:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
 8004438:	4619      	mov	r1, r3
 800443a:	4610      	mov	r0, r2
 800443c:	f7ff fe8a 	bl	8004154 <ucg_font_decode_get_signed_bits>
 8004440:	4603      	mov	r3, r0
 8004442:	73bb      	strb	r3, [r7, #14]
  y = ucg_font_decode_get_signed_bits(&ucg->font_decode, ucg->font_info.bits_per_char_y);
 8004444:	687b      	ldr	r3, [r7, #4]
 8004446:	f103 0280 	add.w	r2, r3, #128	; 0x80
 800444a:	687b      	ldr	r3, [r7, #4]
 800444c:	f893 3097 	ldrb.w	r3, [r3, #151]	; 0x97
 8004450:	4619      	mov	r1, r3
 8004452:	4610      	mov	r0, r2
 8004454:	f7ff fe7e 	bl	8004154 <ucg_font_decode_get_signed_bits>
 8004458:	4603      	mov	r3, r0
 800445a:	737b      	strb	r3, [r7, #13]
  d = ucg_font_decode_get_signed_bits(&ucg->font_decode, ucg->font_info.bits_per_delta_x);
 800445c:	687b      	ldr	r3, [r7, #4]
 800445e:	f103 0280 	add.w	r2, r3, #128	; 0x80
 8004462:	687b      	ldr	r3, [r7, #4]
 8004464:	f893 3098 	ldrb.w	r3, [r3, #152]	; 0x98
 8004468:	4619      	mov	r1, r3
 800446a:	4610      	mov	r0, r2
 800446c:	f7ff fe72 	bl	8004154 <ucg_font_decode_get_signed_bits>
 8004470:	4603      	mov	r3, r0
 8004472:	733b      	strb	r3, [r7, #12]
  
  if ( ucg->font_decode.glyph_width > 0 )
 8004474:	687b      	ldr	r3, [r7, #4]
 8004476:	f993 308a 	ldrsb.w	r3, [r3, #138]	; 0x8a
 800447a:	2b00      	cmp	r3, #0
 800447c:	dd69      	ble.n	8004552 <ucg_font_decode_glyph+0x140>
  {
	ucg->font_decode.target_x = ucg_add_vector_x(ucg->font_decode.target_x, x, -(h+y), ucg->font_decode.dir);
 800447e:	687b      	ldr	r3, [r7, #4]
 8004480:	f9b3 0084 	ldrsh.w	r0, [r3, #132]	; 0x84
 8004484:	7bfa      	ldrb	r2, [r7, #15]
 8004486:	7b7b      	ldrb	r3, [r7, #13]
 8004488:	4413      	add	r3, r2
 800448a:	b2db      	uxtb	r3, r3
 800448c:	425b      	negs	r3, r3
 800448e:	b2db      	uxtb	r3, r3
 8004490:	b25a      	sxtb	r2, r3
 8004492:	687b      	ldr	r3, [r7, #4]
 8004494:	f893 308e 	ldrb.w	r3, [r3, #142]	; 0x8e
 8004498:	f997 100e 	ldrsb.w	r1, [r7, #14]
 800449c:	f7ff febd 	bl	800421a <ucg_add_vector_x>
 80044a0:	4603      	mov	r3, r0
 80044a2:	461a      	mov	r2, r3
 80044a4:	687b      	ldr	r3, [r7, #4]
 80044a6:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
	ucg->font_decode.target_y = ucg_add_vector_y(ucg->font_decode.target_y, x, -(h+y), ucg->font_decode.dir);
 80044aa:	687b      	ldr	r3, [r7, #4]
 80044ac:	f9b3 0086 	ldrsh.w	r0, [r3, #134]	; 0x86
 80044b0:	7bfa      	ldrb	r2, [r7, #15]
 80044b2:	7b7b      	ldrb	r3, [r7, #13]
 80044b4:	4413      	add	r3, r2
 80044b6:	b2db      	uxtb	r3, r3
 80044b8:	425b      	negs	r3, r3
 80044ba:	b2db      	uxtb	r3, r3
 80044bc:	b25a      	sxtb	r2, r3
 80044be:	687b      	ldr	r3, [r7, #4]
 80044c0:	f893 308e 	ldrb.w	r3, [r3, #142]	; 0x8e
 80044c4:	f997 100e 	ldrsb.w	r1, [r7, #14]
 80044c8:	f7ff fe67 	bl	800419a <ucg_add_vector_y>
 80044cc:	4603      	mov	r3, r0
 80044ce:	461a      	mov	r2, r3
 80044d0:	687b      	ldr	r3, [r7, #4]
 80044d2:	f8a3 2086 	strh.w	r2, [r3, #134]	; 0x86
    //ucg_add_vector(&(decode->target_x), &(decode->target_y), x, -(h+y), decode->dir);

    /* reset local x/y position */
	ucg->font_decode.x = 0;
 80044d6:	687b      	ldr	r3, [r7, #4]
 80044d8:	2200      	movs	r2, #0
 80044da:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
	ucg->font_decode.y = 0;
 80044de:	687b      	ldr	r3, [r7, #4]
 80044e0:	2200      	movs	r2, #0
 80044e2:	f883 2089 	strb.w	r2, [r3, #137]	; 0x89

    for(;;)
    {
      a = ucg_font_decode_get_unsigned_bits(&ucg->font_decode, ucg->font_info.bits_per_0);
 80044e6:	687b      	ldr	r3, [r7, #4]
 80044e8:	f103 0280 	add.w	r2, r3, #128	; 0x80
 80044ec:	687b      	ldr	r3, [r7, #4]
 80044ee:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
 80044f2:	4619      	mov	r1, r3
 80044f4:	4610      	mov	r0, r2
 80044f6:	f7ff fde2 	bl	80040be <ucg_font_decode_get_unsigned_bits>
 80044fa:	4603      	mov	r3, r0
 80044fc:	72fb      	strb	r3, [r7, #11]
      b = ucg_font_decode_get_unsigned_bits(&ucg->font_decode, ucg->font_info.bits_per_1);
 80044fe:	687b      	ldr	r3, [r7, #4]
 8004500:	f103 0280 	add.w	r2, r3, #128	; 0x80
 8004504:	687b      	ldr	r3, [r7, #4]
 8004506:	f893 3093 	ldrb.w	r3, [r3, #147]	; 0x93
 800450a:	4619      	mov	r1, r3
 800450c:	4610      	mov	r0, r2
 800450e:	f7ff fdd6 	bl	80040be <ucg_font_decode_get_unsigned_bits>
 8004512:	4603      	mov	r3, r0
 8004514:	72bb      	strb	r3, [r7, #10]
      do
      {
		ucg_font_decode_len(ucg, a, 0);
 8004516:	7afb      	ldrb	r3, [r7, #11]
 8004518:	2200      	movs	r2, #0
 800451a:	4619      	mov	r1, r3
 800451c:	6878      	ldr	r0, [r7, #4]
 800451e:	f7ff febc 	bl	800429a <ucg_font_decode_len>
		ucg_font_decode_len(ucg, b, 1);
 8004522:	7abb      	ldrb	r3, [r7, #10]
 8004524:	2201      	movs	r2, #1
 8004526:	4619      	mov	r1, r3
 8004528:	6878      	ldr	r0, [r7, #4]
 800452a:	f7ff feb6 	bl	800429a <ucg_font_decode_len>
      } while( ucg_font_decode_get_unsigned_bits(&ucg->font_decode, 1) != 0 );
 800452e:	687b      	ldr	r3, [r7, #4]
 8004530:	3380      	adds	r3, #128	; 0x80
 8004532:	2101      	movs	r1, #1
 8004534:	4618      	mov	r0, r3
 8004536:	f7ff fdc2 	bl	80040be <ucg_font_decode_get_unsigned_bits>
 800453a:	4603      	mov	r3, r0
 800453c:	2b00      	cmp	r3, #0
 800453e:	d1ea      	bne.n	8004516 <ucg_font_decode_glyph+0x104>

      if ( ucg->font_decode.y >= h )
 8004540:	687b      	ldr	r3, [r7, #4]
 8004542:	f993 3089 	ldrsb.w	r3, [r3, #137]	; 0x89
 8004546:	f997 200f 	ldrsb.w	r2, [r7, #15]
 800454a:	429a      	cmp	r2, r3
 800454c:	dd00      	ble.n	8004550 <ucg_font_decode_glyph+0x13e>
      a = ucg_font_decode_get_unsigned_bits(&ucg->font_decode, ucg->font_info.bits_per_0);
 800454e:	e7ca      	b.n	80044e6 <ucg_font_decode_glyph+0xd4>
	    break;
 8004550:	bf00      	nop
    }
  }
  return d;
 8004552:	f997 300c 	ldrsb.w	r3, [r7, #12]
}
 8004556:	4618      	mov	r0, r3
 8004558:	3710      	adds	r7, #16
 800455a:	46bd      	mov	sp, r7
 800455c:	bd80      	pop	{r7, pc}

0800455e <ucg_font_get_glyph_data>:
    encoding: Encoding (ASCII code) of the glyph
  Return:
    Address of the glyph data or NULL, if the encoding is not avialable in the font.
*/
const uint8_t *ucg_font_get_glyph_data(ucg_t *ucg, uint8_t encoding)
{
 800455e:	b480      	push	{r7}
 8004560:	b085      	sub	sp, #20
 8004562:	af00      	add	r7, sp, #0
 8004564:	6078      	str	r0, [r7, #4]
 8004566:	460b      	mov	r3, r1
 8004568:	70fb      	strb	r3, [r7, #3]
  const uint8_t *font = ucg->font;
 800456a:	687b      	ldr	r3, [r7, #4]
 800456c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800456e:	60fb      	str	r3, [r7, #12]
  font += UCG_FONT_DATA_STRUCT_SIZE;
 8004570:	68fb      	ldr	r3, [r7, #12]
 8004572:	3315      	adds	r3, #21
 8004574:	60fb      	str	r3, [r7, #12]
  
  if ( encoding >= 'a' )
 8004576:	78fb      	ldrb	r3, [r7, #3]
 8004578:	2b60      	cmp	r3, #96	; 0x60
 800457a:	d907      	bls.n	800458c <ucg_font_get_glyph_data+0x2e>
  {
    font += ucg->font_info.start_pos_lower_a;
 800457c:	687b      	ldr	r3, [r7, #4]
 800457e:	f8b3 30a4 	ldrh.w	r3, [r3, #164]	; 0xa4
 8004582:	461a      	mov	r2, r3
 8004584:	68fb      	ldr	r3, [r7, #12]
 8004586:	4413      	add	r3, r2
 8004588:	60fb      	str	r3, [r7, #12]
 800458a:	e009      	b.n	80045a0 <ucg_font_get_glyph_data+0x42>
  }
  else if ( encoding >= 'A' )
 800458c:	78fb      	ldrb	r3, [r7, #3]
 800458e:	2b40      	cmp	r3, #64	; 0x40
 8004590:	d906      	bls.n	80045a0 <ucg_font_get_glyph_data+0x42>
  {
    font += ucg->font_info.start_pos_upper_A;
 8004592:	687b      	ldr	r3, [r7, #4]
 8004594:	f8b3 30a2 	ldrh.w	r3, [r3, #162]	; 0xa2
 8004598:	461a      	mov	r2, r3
 800459a:	68fb      	ldr	r3, [r7, #12]
 800459c:	4413      	add	r3, r2
 800459e:	60fb      	str	r3, [r7, #12]
  }
  
  for(;;)
  {
    if ( ucg_pgm_read( ((ucg_pgm_uint8_t *)font) + 1 ) == 0 )
 80045a0:	68fb      	ldr	r3, [r7, #12]
 80045a2:	3301      	adds	r3, #1
 80045a4:	781b      	ldrb	r3, [r3, #0]
 80045a6:	2b00      	cmp	r3, #0
 80045a8:	d00e      	beq.n	80045c8 <ucg_font_get_glyph_data+0x6a>
      break;
    if ( ucg_pgm_read( (ucg_pgm_uint8_t *)font ) == encoding )
 80045aa:	68fb      	ldr	r3, [r7, #12]
 80045ac:	781b      	ldrb	r3, [r3, #0]
 80045ae:	78fa      	ldrb	r2, [r7, #3]
 80045b0:	429a      	cmp	r2, r3
 80045b2:	d101      	bne.n	80045b8 <ucg_font_get_glyph_data+0x5a>
    {
      return font;
 80045b4:	68fb      	ldr	r3, [r7, #12]
 80045b6:	e009      	b.n	80045cc <ucg_font_get_glyph_data+0x6e>
    }
    font += ucg_pgm_read( ((ucg_pgm_uint8_t *)font) + 1 );
 80045b8:	68fb      	ldr	r3, [r7, #12]
 80045ba:	3301      	adds	r3, #1
 80045bc:	781b      	ldrb	r3, [r3, #0]
 80045be:	461a      	mov	r2, r3
 80045c0:	68fb      	ldr	r3, [r7, #12]
 80045c2:	4413      	add	r3, r2
 80045c4:	60fb      	str	r3, [r7, #12]
    if ( ucg_pgm_read( ((ucg_pgm_uint8_t *)font) + 1 ) == 0 )
 80045c6:	e7eb      	b.n	80045a0 <ucg_font_get_glyph_data+0x42>
      break;
 80045c8:	bf00      	nop
  }
  return NULL;
 80045ca:	2300      	movs	r3, #0
}
 80045cc:	4618      	mov	r0, r3
 80045ce:	3714      	adds	r7, #20
 80045d0:	46bd      	mov	sp, r7
 80045d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80045d6:	4770      	bx	lr

080045d8 <ucg_font_draw_glyph>:

ucg_int_t ucg_font_draw_glyph(ucg_t *ucg, ucg_int_t x, ucg_int_t y, uint8_t dir, uint8_t encoding)
{
 80045d8:	b580      	push	{r7, lr}
 80045da:	b086      	sub	sp, #24
 80045dc:	af00      	add	r7, sp, #0
 80045de:	60f8      	str	r0, [r7, #12]
 80045e0:	4608      	mov	r0, r1
 80045e2:	4611      	mov	r1, r2
 80045e4:	461a      	mov	r2, r3
 80045e6:	4603      	mov	r3, r0
 80045e8:	817b      	strh	r3, [r7, #10]
 80045ea:	460b      	mov	r3, r1
 80045ec:	813b      	strh	r3, [r7, #8]
 80045ee:	4613      	mov	r3, r2
 80045f0:	71fb      	strb	r3, [r7, #7]
  ucg_int_t dx = 0;
 80045f2:	2300      	movs	r3, #0
 80045f4:	82fb      	strh	r3, [r7, #22]
  ucg->font_decode.target_x = x;
 80045f6:	68fb      	ldr	r3, [r7, #12]
 80045f8:	897a      	ldrh	r2, [r7, #10]
 80045fa:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
  ucg->font_decode.target_y = y;
 80045fe:	68fb      	ldr	r3, [r7, #12]
 8004600:	893a      	ldrh	r2, [r7, #8]
 8004602:	f8a3 2086 	strh.w	r2, [r3, #134]	; 0x86
  //ucg->font_decode.is_transparent = is_transparent; this is already set
  ucg->font_decode.dir = dir;
 8004606:	68fb      	ldr	r3, [r7, #12]
 8004608:	79fa      	ldrb	r2, [r7, #7]
 800460a:	f883 208e 	strb.w	r2, [r3, #142]	; 0x8e
  const uint8_t *glyph_data = ucg_font_get_glyph_data(ucg, encoding);
 800460e:	f897 3020 	ldrb.w	r3, [r7, #32]
 8004612:	4619      	mov	r1, r3
 8004614:	68f8      	ldr	r0, [r7, #12]
 8004616:	f7ff ffa2 	bl	800455e <ucg_font_get_glyph_data>
 800461a:	6138      	str	r0, [r7, #16]
  if ( glyph_data != NULL )
 800461c:	693b      	ldr	r3, [r7, #16]
 800461e:	2b00      	cmp	r3, #0
 8004620:	d005      	beq.n	800462e <ucg_font_draw_glyph+0x56>
  {
    dx = ucg_font_decode_glyph(ucg, glyph_data);
 8004622:	6939      	ldr	r1, [r7, #16]
 8004624:	68f8      	ldr	r0, [r7, #12]
 8004626:	f7ff fef4 	bl	8004412 <ucg_font_decode_glyph>
 800462a:	4603      	mov	r3, r0
 800462c:	82fb      	strh	r3, [r7, #22]
  }
  return dx;
 800462e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
}
 8004632:	4618      	mov	r0, r3
 8004634:	3718      	adds	r7, #24
 8004636:	46bd      	mov	sp, r7
 8004638:	bd80      	pop	{r7, pc}

0800463a <ucg_SetFontMode>:
    UCG_FONT_MODE_SOLID
    UCG_FONT_MODE_NONE
  This has been changed for the new font procedures  
*/
void ucg_SetFontMode(ucg_t *ucg, uint8_t is_transparent)
{
 800463a:	b480      	push	{r7}
 800463c:	b083      	sub	sp, #12
 800463e:	af00      	add	r7, sp, #0
 8004640:	6078      	str	r0, [r7, #4]
 8004642:	460b      	mov	r3, r1
 8004644:	70fb      	strb	r3, [r7, #3]
  ucg->font_decode.is_transparent = is_transparent;		// new font procedures
 8004646:	687b      	ldr	r3, [r7, #4]
 8004648:	78fa      	ldrb	r2, [r7, #3]
 800464a:	f883 208d 	strb.w	r2, [r3, #141]	; 0x8d
}
 800464e:	bf00      	nop
 8004650:	370c      	adds	r7, #12
 8004652:	46bd      	mov	sp, r7
 8004654:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004658:	4770      	bx	lr
	...

0800465c <ucg_DrawGlyph>:

ucg_int_t ucg_DrawGlyph(ucg_t *ucg, ucg_int_t x, ucg_int_t y, uint8_t dir, uint8_t encoding)
{
 800465c:	b580      	push	{r7, lr}
 800465e:	b086      	sub	sp, #24
 8004660:	af02      	add	r7, sp, #8
 8004662:	60f8      	str	r0, [r7, #12]
 8004664:	4608      	mov	r0, r1
 8004666:	4611      	mov	r1, r2
 8004668:	461a      	mov	r2, r3
 800466a:	4603      	mov	r3, r0
 800466c:	817b      	strh	r3, [r7, #10]
 800466e:	460b      	mov	r3, r1
 8004670:	813b      	strh	r3, [r7, #8]
 8004672:	4613      	mov	r3, r2
 8004674:	71fb      	strb	r3, [r7, #7]
  switch(dir)
 8004676:	79fb      	ldrb	r3, [r7, #7]
 8004678:	2b03      	cmp	r3, #3
 800467a:	d837      	bhi.n	80046ec <ucg_DrawGlyph+0x90>
 800467c:	a201      	add	r2, pc, #4	; (adr r2, 8004684 <ucg_DrawGlyph+0x28>)
 800467e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004682:	bf00      	nop
 8004684:	08004695 	.word	0x08004695
 8004688:	080046ab 	.word	0x080046ab
 800468c:	080046c1 	.word	0x080046c1
 8004690:	080046d7 	.word	0x080046d7
  {
    case 0:
      y += ucg->font_calc_vref(ucg);
 8004694:	68fb      	ldr	r3, [r7, #12]
 8004696:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8004698:	68f8      	ldr	r0, [r7, #12]
 800469a:	4798      	blx	r3
 800469c:	4603      	mov	r3, r0
 800469e:	b29a      	uxth	r2, r3
 80046a0:	893b      	ldrh	r3, [r7, #8]
 80046a2:	4413      	add	r3, r2
 80046a4:	b29b      	uxth	r3, r3
 80046a6:	813b      	strh	r3, [r7, #8]
      break;
 80046a8:	e020      	b.n	80046ec <ucg_DrawGlyph+0x90>
    case 1:
      x -= ucg->font_calc_vref(ucg);
 80046aa:	68fb      	ldr	r3, [r7, #12]
 80046ac:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80046ae:	68f8      	ldr	r0, [r7, #12]
 80046b0:	4798      	blx	r3
 80046b2:	4603      	mov	r3, r0
 80046b4:	897a      	ldrh	r2, [r7, #10]
 80046b6:	b29b      	uxth	r3, r3
 80046b8:	1ad3      	subs	r3, r2, r3
 80046ba:	b29b      	uxth	r3, r3
 80046bc:	817b      	strh	r3, [r7, #10]
      break;
 80046be:	e015      	b.n	80046ec <ucg_DrawGlyph+0x90>
    case 2:
      y -= ucg->font_calc_vref(ucg);
 80046c0:	68fb      	ldr	r3, [r7, #12]
 80046c2:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80046c4:	68f8      	ldr	r0, [r7, #12]
 80046c6:	4798      	blx	r3
 80046c8:	4603      	mov	r3, r0
 80046ca:	893a      	ldrh	r2, [r7, #8]
 80046cc:	b29b      	uxth	r3, r3
 80046ce:	1ad3      	subs	r3, r2, r3
 80046d0:	b29b      	uxth	r3, r3
 80046d2:	813b      	strh	r3, [r7, #8]
      break;
 80046d4:	e00a      	b.n	80046ec <ucg_DrawGlyph+0x90>
    case 3:
      x += ucg->font_calc_vref(ucg);
 80046d6:	68fb      	ldr	r3, [r7, #12]
 80046d8:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 80046da:	68f8      	ldr	r0, [r7, #12]
 80046dc:	4798      	blx	r3
 80046de:	4603      	mov	r3, r0
 80046e0:	b29a      	uxth	r2, r3
 80046e2:	897b      	ldrh	r3, [r7, #10]
 80046e4:	4413      	add	r3, r2
 80046e6:	b29b      	uxth	r3, r3
 80046e8:	817b      	strh	r3, [r7, #10]
      break;
 80046ea:	bf00      	nop
  }
  return ucg_font_draw_glyph(ucg, x, y, dir, encoding);
 80046ec:	79f8      	ldrb	r0, [r7, #7]
 80046ee:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 80046f2:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 80046f6:	7e3b      	ldrb	r3, [r7, #24]
 80046f8:	9300      	str	r3, [sp, #0]
 80046fa:	4603      	mov	r3, r0
 80046fc:	68f8      	ldr	r0, [r7, #12]
 80046fe:	f7ff ff6b 	bl	80045d8 <ucg_font_draw_glyph>
 8004702:	4603      	mov	r3, r0
}
 8004704:	4618      	mov	r0, r3
 8004706:	3710      	adds	r7, #16
 8004708:	46bd      	mov	sp, r7
 800470a:	bd80      	pop	{r7, pc}

0800470c <task_drawString>:

ucg_draw_string_t ucg_draw_str;

void task_drawString(void *arg)
{
 800470c:	b580      	push	{r7, lr}
 800470e:	b086      	sub	sp, #24
 8004710:	af02      	add	r7, sp, #8
 8004712:	6078      	str	r0, [r7, #4]
	ucg_int_t delta = 0;
 8004714:	2300      	movs	r3, #0
 8004716:	81fb      	strh	r3, [r7, #14]
	ucg_t *ucg = (ucg_t *)arg;
 8004718:	687b      	ldr	r3, [r7, #4]
 800471a:	60bb      	str	r3, [r7, #8]

	static uint8_t next = 0;
	switch (next)
 800471c:	4b45      	ldr	r3, [pc, #276]	; (8004834 <task_drawString+0x128>)
 800471e:	781b      	ldrb	r3, [r3, #0]
 8004720:	2b00      	cmp	r3, #0
 8004722:	d002      	beq.n	800472a <task_drawString+0x1e>
 8004724:	2b01      	cmp	r3, #1
 8004726:	d01e      	beq.n	8004766 <task_drawString+0x5a>
 8004728:	e07b      	b.n	8004822 <task_drawString+0x116>
	{
		case 0:
			if (bufNumItems(&fontQueue) != 0)
 800472a:	4843      	ldr	r0, [pc, #268]	; (8004838 <task_drawString+0x12c>)
 800472c:	f000 ffcd 	bl	80056ca <bufNumItems>
 8004730:	4603      	mov	r3, r0
 8004732:	2b00      	cmp	r3, #0
 8004734:	d007      	beq.n	8004746 <task_drawString+0x3a>
			{
				bufDeDat(&fontQueue, (uint8_t *)&ucg_draw_str);
 8004736:	4941      	ldr	r1, [pc, #260]	; (800483c <task_drawString+0x130>)
 8004738:	483f      	ldr	r0, [pc, #252]	; (8004838 <task_drawString+0x12c>)
 800473a:	f001 f861 	bl	8005800 <bufDeDat>
				next = 1;
 800473e:	4b3d      	ldr	r3, [pc, #244]	; (8004834 <task_drawString+0x128>)
 8004740:	2201      	movs	r2, #1
 8004742:	701a      	strb	r2, [r3, #0]
					TimerStop(idTaskScanDecodeLen);
					idTaskScanDecodeLen = NO_TIMER;
				}
				next = 0;
			}
			break;
 8004744:	e071      	b.n	800482a <task_drawString+0x11e>
				if (idTaskScanDecodeLen != NO_TIMER)
 8004746:	4b3e      	ldr	r3, [pc, #248]	; (8004840 <task_drawString+0x134>)
 8004748:	781b      	ldrb	r3, [r3, #0]
 800474a:	2bff      	cmp	r3, #255	; 0xff
 800474c:	d007      	beq.n	800475e <task_drawString+0x52>
					TimerStop(idTaskScanDecodeLen);
 800474e:	4b3c      	ldr	r3, [pc, #240]	; (8004840 <task_drawString+0x134>)
 8004750:	781b      	ldrb	r3, [r3, #0]
 8004752:	4618      	mov	r0, r3
 8004754:	f7fd fe5e 	bl	8002414 <TimerStop>
					idTaskScanDecodeLen = NO_TIMER;
 8004758:	4b39      	ldr	r3, [pc, #228]	; (8004840 <task_drawString+0x134>)
 800475a:	22ff      	movs	r2, #255	; 0xff
 800475c:	701a      	strb	r2, [r3, #0]
				next = 0;
 800475e:	4b35      	ldr	r3, [pc, #212]	; (8004834 <task_drawString+0x128>)
 8004760:	2200      	movs	r2, #0
 8004762:	701a      	strb	r2, [r3, #0]
			break;
 8004764:	e061      	b.n	800482a <task_drawString+0x11e>

		case 1:
			if ( *ucg_draw_str.str != '\0' )
 8004766:	4b35      	ldr	r3, [pc, #212]	; (800483c <task_drawString+0x130>)
 8004768:	689b      	ldr	r3, [r3, #8]
 800476a:	781b      	ldrb	r3, [r3, #0]
 800476c:	2b00      	cmp	r3, #0
 800476e:	d054      	beq.n	800481a <task_drawString+0x10e>
			{
				delta = ucg_DrawGlyph(ucg, ucg_draw_str.x, ucg_draw_str.y, ucg_draw_str.dir, (uint8_t)*ucg_draw_str.str);
 8004770:	4b32      	ldr	r3, [pc, #200]	; (800483c <task_drawString+0x130>)
 8004772:	f9b3 1000 	ldrsh.w	r1, [r3]
 8004776:	4b31      	ldr	r3, [pc, #196]	; (800483c <task_drawString+0x130>)
 8004778:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800477c:	4b2f      	ldr	r3, [pc, #188]	; (800483c <task_drawString+0x130>)
 800477e:	7918      	ldrb	r0, [r3, #4]
 8004780:	4b2e      	ldr	r3, [pc, #184]	; (800483c <task_drawString+0x130>)
 8004782:	689b      	ldr	r3, [r3, #8]
 8004784:	781b      	ldrb	r3, [r3, #0]
 8004786:	9300      	str	r3, [sp, #0]
 8004788:	4603      	mov	r3, r0
 800478a:	68b8      	ldr	r0, [r7, #8]
 800478c:	f7ff ff66 	bl	800465c <ucg_DrawGlyph>
 8004790:	4603      	mov	r3, r0
 8004792:	81fb      	strh	r3, [r7, #14]

				switch (ucg_draw_str.dir)
 8004794:	4b29      	ldr	r3, [pc, #164]	; (800483c <task_drawString+0x130>)
 8004796:	791b      	ldrb	r3, [r3, #4]
 8004798:	2b03      	cmp	r3, #3
 800479a:	d837      	bhi.n	800480c <task_drawString+0x100>
 800479c:	a201      	add	r2, pc, #4	; (adr r2, 80047a4 <task_drawString+0x98>)
 800479e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80047a2:	bf00      	nop
 80047a4:	080047b5 	.word	0x080047b5
 80047a8:	080047cb 	.word	0x080047cb
 80047ac:	080047e1 	.word	0x080047e1
 80047b0:	080047f7 	.word	0x080047f7
				{
					case 0:
						ucg_draw_str.x += delta;
 80047b4:	4b21      	ldr	r3, [pc, #132]	; (800483c <task_drawString+0x130>)
 80047b6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80047ba:	b29a      	uxth	r2, r3
 80047bc:	89fb      	ldrh	r3, [r7, #14]
 80047be:	4413      	add	r3, r2
 80047c0:	b29b      	uxth	r3, r3
 80047c2:	b21a      	sxth	r2, r3
 80047c4:	4b1d      	ldr	r3, [pc, #116]	; (800483c <task_drawString+0x130>)
 80047c6:	801a      	strh	r2, [r3, #0]
						break;
 80047c8:	e021      	b.n	800480e <task_drawString+0x102>

					case 1:
						ucg_draw_str.y += delta;
 80047ca:	4b1c      	ldr	r3, [pc, #112]	; (800483c <task_drawString+0x130>)
 80047cc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80047d0:	b29a      	uxth	r2, r3
 80047d2:	89fb      	ldrh	r3, [r7, #14]
 80047d4:	4413      	add	r3, r2
 80047d6:	b29b      	uxth	r3, r3
 80047d8:	b21a      	sxth	r2, r3
 80047da:	4b18      	ldr	r3, [pc, #96]	; (800483c <task_drawString+0x130>)
 80047dc:	805a      	strh	r2, [r3, #2]
						break;
 80047de:	e016      	b.n	800480e <task_drawString+0x102>

					case 2:
						ucg_draw_str.x -= delta;
 80047e0:	4b16      	ldr	r3, [pc, #88]	; (800483c <task_drawString+0x130>)
 80047e2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80047e6:	b29a      	uxth	r2, r3
 80047e8:	89fb      	ldrh	r3, [r7, #14]
 80047ea:	1ad3      	subs	r3, r2, r3
 80047ec:	b29b      	uxth	r3, r3
 80047ee:	b21a      	sxth	r2, r3
 80047f0:	4b12      	ldr	r3, [pc, #72]	; (800483c <task_drawString+0x130>)
 80047f2:	801a      	strh	r2, [r3, #0]
						break;
 80047f4:	e00b      	b.n	800480e <task_drawString+0x102>

					case 3:
						ucg_draw_str.y -= delta;
 80047f6:	4b11      	ldr	r3, [pc, #68]	; (800483c <task_drawString+0x130>)
 80047f8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80047fc:	b29a      	uxth	r2, r3
 80047fe:	89fb      	ldrh	r3, [r7, #14]
 8004800:	1ad3      	subs	r3, r2, r3
 8004802:	b29b      	uxth	r3, r3
 8004804:	b21a      	sxth	r2, r3
 8004806:	4b0d      	ldr	r3, [pc, #52]	; (800483c <task_drawString+0x130>)
 8004808:	805a      	strh	r2, [r3, #2]
						break;
 800480a:	e000      	b.n	800480e <task_drawString+0x102>

					default:
						break;
 800480c:	bf00      	nop
				}

				ucg_draw_str.str++;
 800480e:	4b0b      	ldr	r3, [pc, #44]	; (800483c <task_drawString+0x130>)
 8004810:	689b      	ldr	r3, [r3, #8]
 8004812:	3301      	adds	r3, #1
 8004814:	4a09      	ldr	r2, [pc, #36]	; (800483c <task_drawString+0x130>)
 8004816:	6093      	str	r3, [r2, #8]
			}
			else
			{
				next = 0;
			}
			break;
 8004818:	e007      	b.n	800482a <task_drawString+0x11e>
				next = 0;
 800481a:	4b06      	ldr	r3, [pc, #24]	; (8004834 <task_drawString+0x128>)
 800481c:	2200      	movs	r2, #0
 800481e:	701a      	strb	r2, [r3, #0]
			break;
 8004820:	e003      	b.n	800482a <task_drawString+0x11e>

		default:
			next = 0;
 8004822:	4b04      	ldr	r3, [pc, #16]	; (8004834 <task_drawString+0x128>)
 8004824:	2200      	movs	r2, #0
 8004826:	701a      	strb	r2, [r3, #0]
			break;
 8004828:	bf00      	nop
	}
}
 800482a:	bf00      	nop
 800482c:	3710      	adds	r7, #16
 800482e:	46bd      	mov	sp, r7
 8004830:	bd80      	pop	{r7, pc}
 8004832:	bf00      	nop
 8004834:	2000149c 	.word	0x2000149c
 8004838:	20000480 	.word	0x20000480
 800483c:	20001490 	.word	0x20001490
 8004840:	20000075 	.word	0x20000075

08004844 <ucg_DrawString>:

ucg_int_t ucg_DrawString(ucg_t *ucg, ucg_int_t x, ucg_int_t y, uint8_t dir, const char *str)
{
 8004844:	b580      	push	{r7, lr}
 8004846:	b08a      	sub	sp, #40	; 0x28
 8004848:	af02      	add	r7, sp, #8
 800484a:	60f8      	str	r0, [r7, #12]
 800484c:	4608      	mov	r0, r1
 800484e:	4611      	mov	r1, r2
 8004850:	461a      	mov	r2, r3
 8004852:	4603      	mov	r3, r0
 8004854:	817b      	strh	r3, [r7, #10]
 8004856:	460b      	mov	r3, r1
 8004858:	813b      	strh	r3, [r7, #8]
 800485a:	4613      	mov	r3, r2
 800485c:	71fb      	strb	r3, [r7, #7]
	ucg_int_t sum = 0;
 800485e:	2300      	movs	r3, #0
 8004860:	83fb      	strh	r3, [r7, #30]
	ucg_draw_string_t drawStr;

	drawStr.x = x;
 8004862:	897b      	ldrh	r3, [r7, #10]
 8004864:	823b      	strh	r3, [r7, #16]
	drawStr.y = y;
 8004866:	893b      	ldrh	r3, [r7, #8]
 8004868:	827b      	strh	r3, [r7, #18]
	drawStr.dir = dir;
 800486a:	79fb      	ldrb	r3, [r7, #7]
 800486c:	753b      	strb	r3, [r7, #20]
    drawStr.str = (char *)str;
 800486e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004870:	61bb      	str	r3, [r7, #24]

	bufEnDat(&fontQueue, (uint8_t *)&drawStr);
 8004872:	f107 0310 	add.w	r3, r7, #16
 8004876:	4619      	mov	r1, r3
 8004878:	480c      	ldr	r0, [pc, #48]	; (80048ac <ucg_DrawString+0x68>)
 800487a:	f000 ff71 	bl	8005760 <bufEnDat>

	/* decode glyph */
	if (idTaskScanDecodeLen == NO_TIMER)
 800487e:	4b0c      	ldr	r3, [pc, #48]	; (80048b0 <ucg_DrawString+0x6c>)
 8004880:	781b      	ldrb	r3, [r3, #0]
 8004882:	2bff      	cmp	r3, #255	; 0xff
 8004884:	d10b      	bne.n	800489e <ucg_DrawString+0x5a>
	{
		idTaskScanDecodeLen = TimerStart("ucg_DrawString", 30, TIMER_REPEAT_FOREVER, task_drawString, ucg);
 8004886:	68fb      	ldr	r3, [r7, #12]
 8004888:	9300      	str	r3, [sp, #0]
 800488a:	4b0a      	ldr	r3, [pc, #40]	; (80048b4 <ucg_DrawString+0x70>)
 800488c:	22ff      	movs	r2, #255	; 0xff
 800488e:	211e      	movs	r1, #30
 8004890:	4809      	ldr	r0, [pc, #36]	; (80048b8 <ucg_DrawString+0x74>)
 8004892:	f7fd fd41 	bl	8002318 <TimerStart>
 8004896:	4603      	mov	r3, r0
 8004898:	461a      	mov	r2, r3
 800489a:	4b05      	ldr	r3, [pc, #20]	; (80048b0 <ucg_DrawString+0x6c>)
 800489c:	701a      	strb	r2, [r3, #0]
	}

	return sum;
 800489e:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
}
 80048a2:	4618      	mov	r0, r3
 80048a4:	3720      	adds	r7, #32
 80048a6:	46bd      	mov	sp, r7
 80048a8:	bd80      	pop	{r7, pc}
 80048aa:	bf00      	nop
 80048ac:	20000480 	.word	0x20000480
 80048b0:	20000075 	.word	0x20000075
 80048b4:	0800470d 	.word	0x0800470d
 80048b8:	08006918 	.word	0x08006918

080048bc <ucg_UpdateRefHeight>:
/*===============================================*/

/* set ascent/descent for reference point calculation */

void ucg_UpdateRefHeight(ucg_t *ucg)
{
 80048bc:	b480      	push	{r7}
 80048be:	b083      	sub	sp, #12
 80048c0:	af00      	add	r7, sp, #0
 80048c2:	6078      	str	r0, [r7, #4]
  if ( ucg->font == NULL )
 80048c4:	687b      	ldr	r3, [r7, #4]
 80048c6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80048c8:	2b00      	cmp	r3, #0
 80048ca:	d05d      	beq.n	8004988 <ucg_UpdateRefHeight+0xcc>
    return;
  ucg->font_ref_ascent = ucg->font_info.ascent_A;
 80048cc:	687b      	ldr	r3, [r7, #4]
 80048ce:	f993 209d 	ldrsb.w	r2, [r3, #157]	; 0x9d
 80048d2:	687b      	ldr	r3, [r7, #4]
 80048d4:	f883 20ac 	strb.w	r2, [r3, #172]	; 0xac
  ucg->font_ref_descent = ucg->font_info.descent_g;
 80048d8:	687b      	ldr	r3, [r7, #4]
 80048da:	f993 209e 	ldrsb.w	r2, [r3, #158]	; 0x9e
 80048de:	687b      	ldr	r3, [r7, #4]
 80048e0:	f883 20ad 	strb.w	r2, [r3, #173]	; 0xad
  if ( ucg->font_height_mode == UCG_FONT_HEIGHT_MODE_TEXT )
 80048e4:	687b      	ldr	r3, [r7, #4]
 80048e6:	f893 30ab 	ldrb.w	r3, [r3, #171]	; 0xab
 80048ea:	2b00      	cmp	r3, #0
 80048ec:	d04d      	beq.n	800498a <ucg_UpdateRefHeight+0xce>
  {
  }
  else if ( ucg->font_height_mode == UCG_FONT_HEIGHT_MODE_XTEXT )
 80048ee:	687b      	ldr	r3, [r7, #4]
 80048f0:	f893 30ab 	ldrb.w	r3, [r3, #171]	; 0xab
 80048f4:	2b01      	cmp	r3, #1
 80048f6:	d11c      	bne.n	8004932 <ucg_UpdateRefHeight+0x76>
  {
    if ( ucg->font_ref_ascent < ucg->font_info.ascent_para )
 80048f8:	687b      	ldr	r3, [r7, #4]
 80048fa:	f993 20ac 	ldrsb.w	r2, [r3, #172]	; 0xac
 80048fe:	687b      	ldr	r3, [r7, #4]
 8004900:	f993 309f 	ldrsb.w	r3, [r3, #159]	; 0x9f
 8004904:	429a      	cmp	r2, r3
 8004906:	da05      	bge.n	8004914 <ucg_UpdateRefHeight+0x58>
      ucg->font_ref_ascent = ucg->font_info.ascent_para;
 8004908:	687b      	ldr	r3, [r7, #4]
 800490a:	f993 209f 	ldrsb.w	r2, [r3, #159]	; 0x9f
 800490e:	687b      	ldr	r3, [r7, #4]
 8004910:	f883 20ac 	strb.w	r2, [r3, #172]	; 0xac
    if ( ucg->font_ref_descent > ucg->font_info.descent_para )
 8004914:	687b      	ldr	r3, [r7, #4]
 8004916:	f993 20ad 	ldrsb.w	r2, [r3, #173]	; 0xad
 800491a:	687b      	ldr	r3, [r7, #4]
 800491c:	f993 30a0 	ldrsb.w	r3, [r3, #160]	; 0xa0
 8004920:	429a      	cmp	r2, r3
 8004922:	dd32      	ble.n	800498a <ucg_UpdateRefHeight+0xce>
      ucg->font_ref_descent = ucg->font_info.descent_para;
 8004924:	687b      	ldr	r3, [r7, #4]
 8004926:	f993 20a0 	ldrsb.w	r2, [r3, #160]	; 0xa0
 800492a:	687b      	ldr	r3, [r7, #4]
 800492c:	f883 20ad 	strb.w	r2, [r3, #173]	; 0xad
 8004930:	e02b      	b.n	800498a <ucg_UpdateRefHeight+0xce>
  }
  else
  {
    if ( ucg->font_ref_ascent < ucg->font_info.max_char_height+ucg->font_info.y_offset )
 8004932:	687b      	ldr	r3, [r7, #4]
 8004934:	f993 30ac 	ldrsb.w	r3, [r3, #172]	; 0xac
 8004938:	461a      	mov	r2, r3
 800493a:	687b      	ldr	r3, [r7, #4]
 800493c:	f993 309a 	ldrsb.w	r3, [r3, #154]	; 0x9a
 8004940:	4619      	mov	r1, r3
 8004942:	687b      	ldr	r3, [r7, #4]
 8004944:	f993 309c 	ldrsb.w	r3, [r3, #156]	; 0x9c
 8004948:	440b      	add	r3, r1
 800494a:	429a      	cmp	r2, r3
 800494c:	da0d      	bge.n	800496a <ucg_UpdateRefHeight+0xae>
      ucg->font_ref_ascent = ucg->font_info.max_char_height+ucg->font_info.y_offset;
 800494e:	687b      	ldr	r3, [r7, #4]
 8004950:	f993 309a 	ldrsb.w	r3, [r3, #154]	; 0x9a
 8004954:	b2da      	uxtb	r2, r3
 8004956:	687b      	ldr	r3, [r7, #4]
 8004958:	f993 309c 	ldrsb.w	r3, [r3, #156]	; 0x9c
 800495c:	b2db      	uxtb	r3, r3
 800495e:	4413      	add	r3, r2
 8004960:	b2db      	uxtb	r3, r3
 8004962:	b25a      	sxtb	r2, r3
 8004964:	687b      	ldr	r3, [r7, #4]
 8004966:	f883 20ac 	strb.w	r2, [r3, #172]	; 0xac
    if ( ucg->font_ref_descent > ucg->font_info.y_offset )
 800496a:	687b      	ldr	r3, [r7, #4]
 800496c:	f993 20ad 	ldrsb.w	r2, [r3, #173]	; 0xad
 8004970:	687b      	ldr	r3, [r7, #4]
 8004972:	f993 309c 	ldrsb.w	r3, [r3, #156]	; 0x9c
 8004976:	429a      	cmp	r2, r3
 8004978:	dd07      	ble.n	800498a <ucg_UpdateRefHeight+0xce>
      ucg->font_ref_descent = ucg->font_info.y_offset;
 800497a:	687b      	ldr	r3, [r7, #4]
 800497c:	f993 209c 	ldrsb.w	r2, [r3, #156]	; 0x9c
 8004980:	687b      	ldr	r3, [r7, #4]
 8004982:	f883 20ad 	strb.w	r2, [r3, #173]	; 0xad
 8004986:	e000      	b.n	800498a <ucg_UpdateRefHeight+0xce>
    return;
 8004988:	bf00      	nop
  }  
}
 800498a:	370c      	adds	r7, #12
 800498c:	46bd      	mov	sp, r7
 800498e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004992:	4770      	bx	lr

08004994 <ucg_font_calc_vref_font>:

/*===============================================*/
/* callback procedures to correct the y position */

ucg_int_t ucg_font_calc_vref_font(ucg_t *ucg)
{
 8004994:	b480      	push	{r7}
 8004996:	b083      	sub	sp, #12
 8004998:	af00      	add	r7, sp, #0
 800499a:	6078      	str	r0, [r7, #4]
  return 0;
 800499c:	2300      	movs	r3, #0
}
 800499e:	4618      	mov	r0, r3
 80049a0:	370c      	adds	r7, #12
 80049a2:	46bd      	mov	sp, r7
 80049a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049a8:	4770      	bx	lr
	...

080049ac <ucg_SetFontPosBaseline>:

void ucg_SetFontPosBaseline(ucg_t *ucg)
{
 80049ac:	b480      	push	{r7}
 80049ae:	b083      	sub	sp, #12
 80049b0:	af00      	add	r7, sp, #0
 80049b2:	6078      	str	r0, [r7, #4]
  ucg->font_calc_vref = ucg_font_calc_vref_font;
 80049b4:	687b      	ldr	r3, [r7, #4]
 80049b6:	4a04      	ldr	r2, [pc, #16]	; (80049c8 <ucg_SetFontPosBaseline+0x1c>)
 80049b8:	67da      	str	r2, [r3, #124]	; 0x7c
}
 80049ba:	bf00      	nop
 80049bc:	370c      	adds	r7, #12
 80049be:	46bd      	mov	sp, r7
 80049c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80049c4:	4770      	bx	lr
 80049c6:	bf00      	nop
 80049c8:	08004995 	.word	0x08004995

080049cc <ucg_SetFont>:
}

/*===============================================*/

void ucg_SetFont(ucg_t *ucg, const ucg_fntpgm_uint8_t  *font)
{
 80049cc:	b580      	push	{r7, lr}
 80049ce:	b082      	sub	sp, #8
 80049d0:	af00      	add	r7, sp, #0
 80049d2:	6078      	str	r0, [r7, #4]
 80049d4:	6039      	str	r1, [r7, #0]
  if ( ucg->font != font )
 80049d6:	687b      	ldr	r3, [r7, #4]
 80049d8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80049da:	683a      	ldr	r2, [r7, #0]
 80049dc:	429a      	cmp	r2, r3
 80049de:	d012      	beq.n	8004a06 <ucg_SetFont+0x3a>
  {
    ucg->font = font;
 80049e0:	687b      	ldr	r3, [r7, #4]
 80049e2:	683a      	ldr	r2, [r7, #0]
 80049e4:	679a      	str	r2, [r3, #120]	; 0x78
    ucg_read_font_info(&(ucg->font_info), font);
 80049e6:	687b      	ldr	r3, [r7, #4]
 80049e8:	3390      	adds	r3, #144	; 0x90
 80049ea:	6839      	ldr	r1, [r7, #0]
 80049ec:	4618      	mov	r0, r3
 80049ee:	f7ff fac5 	bl	8003f7c <ucg_read_font_info>
    ucg_UpdateRefHeight(ucg);
 80049f2:	6878      	ldr	r0, [r7, #4]
 80049f4:	f7ff ff62 	bl	80048bc <ucg_UpdateRefHeight>
    //ucg_SetFontPosBaseline(ucg);

    // Init queue font
    bufInit(pQueueFont, &fontQueue, sizeof(ucg_draw_string_t), SIZE_QUEUE_DATA_FONT);
 80049f8:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80049fc:	220c      	movs	r2, #12
 80049fe:	4904      	ldr	r1, [pc, #16]	; (8004a10 <ucg_SetFont+0x44>)
 8004a00:	4804      	ldr	r0, [pc, #16]	; (8004a14 <ucg_SetFont+0x48>)
 8004a02:	f000 fe47 	bl	8005694 <bufInit>
  }
}
 8004a06:	bf00      	nop
 8004a08:	3708      	adds	r7, #8
 8004a0a:	46bd      	mov	sp, r7
 8004a0c:	bd80      	pop	{r7, pc}
 8004a0e:	bf00      	nop
 8004a10:	20000480 	.word	0x20000480
 8004a14:	20000490 	.word	0x20000490

08004a18 <ucg_init_struct>:
uint8_t global_SREG_backup;		// used by the atomic macros
#endif


void ucg_init_struct(ucg_t *ucg)
{
 8004a18:	b480      	push	{r7}
 8004a1a:	b083      	sub	sp, #12
 8004a1c:	af00      	add	r7, sp, #0
 8004a1e:	6078      	str	r0, [r7, #4]
  //memset(ucg, 0, sizeof(ucg_t));
  ucg->is_power_up = 0;
 8004a20:	687a      	ldr	r2, [r7, #4]
 8004a22:	7813      	ldrb	r3, [r2, #0]
 8004a24:	f36f 0300 	bfc	r3, #0, #1
 8004a28:	7013      	strb	r3, [r2, #0]
  ucg->rotate_chain_device_cb = 0;
 8004a2a:	687b      	ldr	r3, [r7, #4]
 8004a2c:	2200      	movs	r2, #0
 8004a2e:	611a      	str	r2, [r3, #16]
  ucg->arg.scale = 1;
 8004a30:	687b      	ldr	r3, [r7, #4]
 8004a32:	2201      	movs	r2, #1
 8004a34:	865a      	strh	r2, [r3, #50]	; 0x32
  //ucg->display_offset.x = 0;
  //ucg->display_offset.y = 0;
  ucg->font = 0;
 8004a36:	687b      	ldr	r3, [r7, #4]
 8004a38:	2200      	movs	r2, #0
 8004a3a:	679a      	str	r2, [r3, #120]	; 0x78
  //ucg->font_mode = UCG_FONT_MODE_NONE;   Old font procedures
  ucg->font_decode.is_transparent = 1;  // new font procedures
 8004a3c:	687b      	ldr	r3, [r7, #4]
 8004a3e:	2201      	movs	r2, #1
 8004a40:	f883 208d 	strb.w	r2, [r3, #141]	; 0x8d
  
  ucg->com_initial_change_sent = 0;
 8004a44:	687b      	ldr	r3, [r7, #4]
 8004a46:	2200      	movs	r2, #0
 8004a48:	f883 20ae 	strb.w	r2, [r3, #174]	; 0xae
  ucg->com_status = 0;
 8004a4c:	687b      	ldr	r3, [r7, #4]
 8004a4e:	2200      	movs	r2, #0
 8004a50:	f883 20af 	strb.w	r2, [r3, #175]	; 0xaf
  ucg->com_cfg_cd = 0;
 8004a54:	687b      	ldr	r3, [r7, #4]
 8004a56:	2200      	movs	r2, #0
 8004a58:	f883 20b0 	strb.w	r2, [r3, #176]	; 0xb0
}
 8004a5c:	bf00      	nop
 8004a5e:	370c      	adds	r7, #12
 8004a60:	46bd      	mov	sp, r7
 8004a62:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004a66:	4770      	bx	lr

08004a68 <ucg_Init>:


ucg_int_t ucg_Init(ucg_t *ucg, ucg_dev_fnptr device_cb, ucg_dev_fnptr ext_cb, ucg_com_fnptr com_cb)
{
 8004a68:	b580      	push	{r7, lr}
 8004a6a:	b086      	sub	sp, #24
 8004a6c:	af00      	add	r7, sp, #0
 8004a6e:	60f8      	str	r0, [r7, #12]
 8004a70:	60b9      	str	r1, [r7, #8]
 8004a72:	607a      	str	r2, [r7, #4]
 8004a74:	603b      	str	r3, [r7, #0]
  ucg_int_t r;
  ucg_init_struct(ucg);
 8004a76:	68f8      	ldr	r0, [r7, #12]
 8004a78:	f7ff ffce 	bl	8004a18 <ucg_init_struct>
  if ( ext_cb == (ucg_dev_fnptr)0 )
 8004a7c:	687b      	ldr	r3, [r7, #4]
 8004a7e:	2b00      	cmp	r3, #0
 8004a80:	d103      	bne.n	8004a8a <ucg_Init+0x22>
    ucg->ext_cb = ucg_ext_none;
 8004a82:	68fb      	ldr	r3, [r7, #12]
 8004a84:	4a0e      	ldr	r2, [pc, #56]	; (8004ac0 <ucg_Init+0x58>)
 8004a86:	60da      	str	r2, [r3, #12]
 8004a88:	e002      	b.n	8004a90 <ucg_Init+0x28>
 else 
    ucg->ext_cb = ext_cb;
 8004a8a:	68fb      	ldr	r3, [r7, #12]
 8004a8c:	687a      	ldr	r2, [r7, #4]
 8004a8e:	60da      	str	r2, [r3, #12]
  ucg->device_cb = device_cb;
 8004a90:	68fb      	ldr	r3, [r7, #12]
 8004a92:	68ba      	ldr	r2, [r7, #8]
 8004a94:	609a      	str	r2, [r3, #8]
  ucg->com_cb = com_cb;
 8004a96:	68fb      	ldr	r3, [r7, #12]
 8004a98:	683a      	ldr	r2, [r7, #0]
 8004a9a:	61da      	str	r2, [r3, #28]
  ucg_SetFontPosBaseline(ucg);
 8004a9c:	68f8      	ldr	r0, [r7, #12]
 8004a9e:	f7ff ff85 	bl	80049ac <ucg_SetFontPosBaseline>
  r = ucg_PowerUp(ucg);
 8004aa2:	68f8      	ldr	r0, [r7, #12]
 8004aa4:	f7ff f980 	bl	8003da8 <ucg_PowerUp>
 8004aa8:	4603      	mov	r3, r0
 8004aaa:	82fb      	strh	r3, [r7, #22]
  ucg_GetDimension(ucg);
 8004aac:	68f8      	ldr	r0, [r7, #12]
 8004aae:	f7ff f9c0 	bl	8003e32 <ucg_GetDimension>
  return r;
 8004ab2:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
}
 8004ab6:	4618      	mov	r0, r3
 8004ab8:	3718      	adds	r7, #24
 8004aba:	46bd      	mov	sp, r7
 8004abc:	bd80      	pop	{r7, pc}
 8004abe:	bf00      	nop
 8004ac0:	08003a01 	.word	0x08003a01

08004ac4 <ucg_Draw90Line>:
*/

#include "ucg.h"

void ucg_Draw90Line(ucg_t *ucg, ucg_int_t x, ucg_int_t y, ucg_int_t len, ucg_int_t dir, ucg_int_t col_idx)
{
 8004ac4:	b580      	push	{r7, lr}
 8004ac6:	b084      	sub	sp, #16
 8004ac8:	af00      	add	r7, sp, #0
 8004aca:	60f8      	str	r0, [r7, #12]
 8004acc:	4608      	mov	r0, r1
 8004ace:	4611      	mov	r1, r2
 8004ad0:	461a      	mov	r2, r3
 8004ad2:	4603      	mov	r3, r0
 8004ad4:	817b      	strh	r3, [r7, #10]
 8004ad6:	460b      	mov	r3, r1
 8004ad8:	813b      	strh	r3, [r7, #8]
 8004ada:	4613      	mov	r3, r2
 8004adc:	80fb      	strh	r3, [r7, #6]
  ucg->arg.pixel.rgb.color[0] = ucg->arg.rgb[col_idx].color[0];
 8004ade:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 8004ae2:	68f9      	ldr	r1, [r7, #12]
 8004ae4:	4613      	mov	r3, r2
 8004ae6:	005b      	lsls	r3, r3, #1
 8004ae8:	4413      	add	r3, r2
 8004aea:	440b      	add	r3, r1
 8004aec:	333a      	adds	r3, #58	; 0x3a
 8004aee:	781a      	ldrb	r2, [r3, #0]
 8004af0:	68fb      	ldr	r3, [r7, #12]
 8004af2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  ucg->arg.pixel.rgb.color[1] = ucg->arg.rgb[col_idx].color[1];
 8004af6:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 8004afa:	68f9      	ldr	r1, [r7, #12]
 8004afc:	4613      	mov	r3, r2
 8004afe:	005b      	lsls	r3, r3, #1
 8004b00:	4413      	add	r3, r2
 8004b02:	440b      	add	r3, r1
 8004b04:	333b      	adds	r3, #59	; 0x3b
 8004b06:	781a      	ldrb	r2, [r3, #0]
 8004b08:	68fb      	ldr	r3, [r7, #12]
 8004b0a:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  ucg->arg.pixel.rgb.color[2] = ucg->arg.rgb[col_idx].color[2];
 8004b0e:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 8004b12:	68f9      	ldr	r1, [r7, #12]
 8004b14:	4613      	mov	r3, r2
 8004b16:	005b      	lsls	r3, r3, #1
 8004b18:	4413      	add	r3, r2
 8004b1a:	440b      	add	r3, r1
 8004b1c:	333c      	adds	r3, #60	; 0x3c
 8004b1e:	781a      	ldrb	r2, [r3, #0]
 8004b20:	68fb      	ldr	r3, [r7, #12]
 8004b22:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
  ucg->arg.pixel.pos.x = x;
 8004b26:	68fb      	ldr	r3, [r7, #12]
 8004b28:	897a      	ldrh	r2, [r7, #10]
 8004b2a:	849a      	strh	r2, [r3, #36]	; 0x24
  ucg->arg.pixel.pos.y = y;
 8004b2c:	68fb      	ldr	r3, [r7, #12]
 8004b2e:	893a      	ldrh	r2, [r7, #8]
 8004b30:	84da      	strh	r2, [r3, #38]	; 0x26
  ucg->arg.len = len;
 8004b32:	68fb      	ldr	r3, [r7, #12]
 8004b34:	88fa      	ldrh	r2, [r7, #6]
 8004b36:	859a      	strh	r2, [r3, #44]	; 0x2c
  ucg->arg.dir = dir;
 8004b38:	68fb      	ldr	r3, [r7, #12]
 8004b3a:	8b3a      	ldrh	r2, [r7, #24]
 8004b3c:	85da      	strh	r2, [r3, #46]	; 0x2e
  ucg_DrawL90FXWithArg(ucg);
 8004b3e:	68f8      	ldr	r0, [r7, #12]
 8004b40:	f7ff f997 	bl	8003e72 <ucg_DrawL90FXWithArg>
}
 8004b44:	bf00      	nop
 8004b46:	3710      	adds	r7, #16
 8004b48:	46bd      	mov	sp, r7
 8004b4a:	bd80      	pop	{r7, pc}

08004b4c <ucg_DrawHLine>:

void ucg_DrawHLine(ucg_t *ucg, ucg_int_t x, ucg_int_t y, ucg_int_t len)
{
 8004b4c:	b580      	push	{r7, lr}
 8004b4e:	b086      	sub	sp, #24
 8004b50:	af02      	add	r7, sp, #8
 8004b52:	60f8      	str	r0, [r7, #12]
 8004b54:	4608      	mov	r0, r1
 8004b56:	4611      	mov	r1, r2
 8004b58:	461a      	mov	r2, r3
 8004b5a:	4603      	mov	r3, r0
 8004b5c:	817b      	strh	r3, [r7, #10]
 8004b5e:	460b      	mov	r3, r1
 8004b60:	813b      	strh	r3, [r7, #8]
 8004b62:	4613      	mov	r3, r2
 8004b64:	80fb      	strh	r3, [r7, #6]
  ucg_Draw90Line(ucg, x, y, len, 0, 0);
 8004b66:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8004b6a:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8004b6e:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 8004b72:	2000      	movs	r0, #0
 8004b74:	9001      	str	r0, [sp, #4]
 8004b76:	2000      	movs	r0, #0
 8004b78:	9000      	str	r0, [sp, #0]
 8004b7a:	68f8      	ldr	r0, [r7, #12]
 8004b7c:	f7ff ffa2 	bl	8004ac4 <ucg_Draw90Line>
}
 8004b80:	bf00      	nop
 8004b82:	3710      	adds	r7, #16
 8004b84:	46bd      	mov	sp, r7
 8004b86:	bd80      	pop	{r7, pc}

08004b88 <ucg_DrawVLine>:

void ucg_DrawVLine(ucg_t *ucg, ucg_int_t x, ucg_int_t y, ucg_int_t len)
{
 8004b88:	b580      	push	{r7, lr}
 8004b8a:	b086      	sub	sp, #24
 8004b8c:	af02      	add	r7, sp, #8
 8004b8e:	60f8      	str	r0, [r7, #12]
 8004b90:	4608      	mov	r0, r1
 8004b92:	4611      	mov	r1, r2
 8004b94:	461a      	mov	r2, r3
 8004b96:	4603      	mov	r3, r0
 8004b98:	817b      	strh	r3, [r7, #10]
 8004b9a:	460b      	mov	r3, r1
 8004b9c:	813b      	strh	r3, [r7, #8]
 8004b9e:	4613      	mov	r3, r2
 8004ba0:	80fb      	strh	r3, [r7, #6]
  ucg_Draw90Line(ucg, x, y, len, 1, 0);
 8004ba2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8004ba6:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8004baa:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 8004bae:	2000      	movs	r0, #0
 8004bb0:	9001      	str	r0, [sp, #4]
 8004bb2:	2001      	movs	r0, #1
 8004bb4:	9000      	str	r0, [sp, #0]
 8004bb6:	68f8      	ldr	r0, [r7, #12]
 8004bb8:	f7ff ff84 	bl	8004ac4 <ucg_Draw90Line>
}
 8004bbc:	bf00      	nop
 8004bbe:	3710      	adds	r7, #16
 8004bc0:	46bd      	mov	sp, r7
 8004bc2:	bd80      	pop	{r7, pc}

08004bc4 <ucg_DrawLine>:
  ucg->arg.dir = dir;
  ucg_DrawL90SEWithArg(ucg);
}

void ucg_DrawLine(ucg_t *ucg, ucg_int_t x1, ucg_int_t y1, ucg_int_t x2, ucg_int_t y2)
{
 8004bc4:	b580      	push	{r7, lr}
 8004bc6:	b088      	sub	sp, #32
 8004bc8:	af00      	add	r7, sp, #0
 8004bca:	60f8      	str	r0, [r7, #12]
 8004bcc:	4608      	mov	r0, r1
 8004bce:	4611      	mov	r1, r2
 8004bd0:	461a      	mov	r2, r3
 8004bd2:	4603      	mov	r3, r0
 8004bd4:	817b      	strh	r3, [r7, #10]
 8004bd6:	460b      	mov	r3, r1
 8004bd8:	813b      	strh	r3, [r7, #8]
 8004bda:	4613      	mov	r3, r2
 8004bdc:	80fb      	strh	r3, [r7, #6]
  ucg_int_t x,y;
  ucg_int_t dx, dy;
  ucg_int_t err;
  ucg_int_t ystep;

  uint8_t swapxy = 0;
 8004bde:	2300      	movs	r3, #0
 8004be0:	74fb      	strb	r3, [r7, #19]
  
  /* no BBX intersection check at the moment... */

  ucg->arg.pixel.rgb.color[0] = ucg->arg.rgb[0].color[0];
 8004be2:	68fb      	ldr	r3, [r7, #12]
 8004be4:	f893 203a 	ldrb.w	r2, [r3, #58]	; 0x3a
 8004be8:	68fb      	ldr	r3, [r7, #12]
 8004bea:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  ucg->arg.pixel.rgb.color[1] = ucg->arg.rgb[0].color[1];
 8004bee:	68fb      	ldr	r3, [r7, #12]
 8004bf0:	f893 203b 	ldrb.w	r2, [r3, #59]	; 0x3b
 8004bf4:	68fb      	ldr	r3, [r7, #12]
 8004bf6:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  ucg->arg.pixel.rgb.color[2] = ucg->arg.rgb[0].color[2];
 8004bfa:	68fb      	ldr	r3, [r7, #12]
 8004bfc:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 8004c00:	68fb      	ldr	r3, [r7, #12]
 8004c02:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
    
  if ( x1 > x2 ) dx = x1-x2; else dx = x2-x1;
 8004c06:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8004c0a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8004c0e:	429a      	cmp	r2, r3
 8004c10:	dd05      	ble.n	8004c1e <ucg_DrawLine+0x5a>
 8004c12:	897a      	ldrh	r2, [r7, #10]
 8004c14:	88fb      	ldrh	r3, [r7, #6]
 8004c16:	1ad3      	subs	r3, r2, r3
 8004c18:	b29b      	uxth	r3, r3
 8004c1a:	837b      	strh	r3, [r7, #26]
 8004c1c:	e004      	b.n	8004c28 <ucg_DrawLine+0x64>
 8004c1e:	88fa      	ldrh	r2, [r7, #6]
 8004c20:	897b      	ldrh	r3, [r7, #10]
 8004c22:	1ad3      	subs	r3, r2, r3
 8004c24:	b29b      	uxth	r3, r3
 8004c26:	837b      	strh	r3, [r7, #26]
  if ( y1 > y2 ) dy = y1-y2; else dy = y2-y1;
 8004c28:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 8004c2c:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8004c30:	429a      	cmp	r2, r3
 8004c32:	dd05      	ble.n	8004c40 <ucg_DrawLine+0x7c>
 8004c34:	893a      	ldrh	r2, [r7, #8]
 8004c36:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8004c38:	1ad3      	subs	r3, r2, r3
 8004c3a:	b29b      	uxth	r3, r3
 8004c3c:	833b      	strh	r3, [r7, #24]
 8004c3e:	e004      	b.n	8004c4a <ucg_DrawLine+0x86>
 8004c40:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8004c42:	893b      	ldrh	r3, [r7, #8]
 8004c44:	1ad3      	subs	r3, r2, r3
 8004c46:	b29b      	uxth	r3, r3
 8004c48:	833b      	strh	r3, [r7, #24]

  if ( dy > dx ) 
 8004c4a:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 8004c4e:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8004c52:	429a      	cmp	r2, r3
 8004c54:	dd13      	ble.n	8004c7e <ucg_DrawLine+0xba>
  {
    swapxy = 1;
 8004c56:	2301      	movs	r3, #1
 8004c58:	74fb      	strb	r3, [r7, #19]
    tmp = dx; dx =dy; dy = tmp;
 8004c5a:	8b7b      	ldrh	r3, [r7, #26]
 8004c5c:	823b      	strh	r3, [r7, #16]
 8004c5e:	8b3b      	ldrh	r3, [r7, #24]
 8004c60:	837b      	strh	r3, [r7, #26]
 8004c62:	8a3b      	ldrh	r3, [r7, #16]
 8004c64:	833b      	strh	r3, [r7, #24]
    tmp = x1; x1 =y1; y1 = tmp;
 8004c66:	897b      	ldrh	r3, [r7, #10]
 8004c68:	823b      	strh	r3, [r7, #16]
 8004c6a:	893b      	ldrh	r3, [r7, #8]
 8004c6c:	817b      	strh	r3, [r7, #10]
 8004c6e:	8a3b      	ldrh	r3, [r7, #16]
 8004c70:	813b      	strh	r3, [r7, #8]
    tmp = x2; x2 =y2; y2 = tmp;
 8004c72:	88fb      	ldrh	r3, [r7, #6]
 8004c74:	823b      	strh	r3, [r7, #16]
 8004c76:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8004c78:	80fb      	strh	r3, [r7, #6]
 8004c7a:	8a3b      	ldrh	r3, [r7, #16]
 8004c7c:	853b      	strh	r3, [r7, #40]	; 0x28
  }
  if ( x1 > x2 ) 
 8004c7e:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8004c82:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8004c86:	429a      	cmp	r2, r3
 8004c88:	dd0b      	ble.n	8004ca2 <ucg_DrawLine+0xde>
  {
    tmp = x1; x1 =x2; x2 = tmp;
 8004c8a:	897b      	ldrh	r3, [r7, #10]
 8004c8c:	823b      	strh	r3, [r7, #16]
 8004c8e:	88fb      	ldrh	r3, [r7, #6]
 8004c90:	817b      	strh	r3, [r7, #10]
 8004c92:	8a3b      	ldrh	r3, [r7, #16]
 8004c94:	80fb      	strh	r3, [r7, #6]
    tmp = y1; y1 =y2; y2 = tmp;
 8004c96:	893b      	ldrh	r3, [r7, #8]
 8004c98:	823b      	strh	r3, [r7, #16]
 8004c9a:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8004c9c:	813b      	strh	r3, [r7, #8]
 8004c9e:	8a3b      	ldrh	r3, [r7, #16]
 8004ca0:	853b      	strh	r3, [r7, #40]	; 0x28
  }
  err = dx >> 1;
 8004ca2:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8004ca6:	105b      	asrs	r3, r3, #1
 8004ca8:	82fb      	strh	r3, [r7, #22]
  if ( y2 > y1 ) ystep = 1; else ystep = -1;
 8004caa:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
 8004cae:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8004cb2:	429a      	cmp	r2, r3
 8004cb4:	dd02      	ble.n	8004cbc <ucg_DrawLine+0xf8>
 8004cb6:	2301      	movs	r3, #1
 8004cb8:	82bb      	strh	r3, [r7, #20]
 8004cba:	e002      	b.n	8004cc2 <ucg_DrawLine+0xfe>
 8004cbc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8004cc0:	82bb      	strh	r3, [r7, #20]
  y = y1;
 8004cc2:	893b      	ldrh	r3, [r7, #8]
 8004cc4:	83bb      	strh	r3, [r7, #28]
  for( x = x1; x <= x2; x++ )
 8004cc6:	897b      	ldrh	r3, [r7, #10]
 8004cc8:	83fb      	strh	r3, [r7, #30]
 8004cca:	e02d      	b.n	8004d28 <ucg_DrawLine+0x164>
  {
    if ( swapxy == 0 ) 
 8004ccc:	7cfb      	ldrb	r3, [r7, #19]
 8004cce:	2b00      	cmp	r3, #0
 8004cd0:	d106      	bne.n	8004ce0 <ucg_DrawLine+0x11c>
    {
      ucg->arg.pixel.pos.x = x;
 8004cd2:	68fb      	ldr	r3, [r7, #12]
 8004cd4:	8bfa      	ldrh	r2, [r7, #30]
 8004cd6:	849a      	strh	r2, [r3, #36]	; 0x24
      ucg->arg.pixel.pos.y = y;
 8004cd8:	68fb      	ldr	r3, [r7, #12]
 8004cda:	8bba      	ldrh	r2, [r7, #28]
 8004cdc:	84da      	strh	r2, [r3, #38]	; 0x26
 8004cde:	e005      	b.n	8004cec <ucg_DrawLine+0x128>
    }
    else 
    {
      ucg->arg.pixel.pos.x = y;
 8004ce0:	68fb      	ldr	r3, [r7, #12]
 8004ce2:	8bba      	ldrh	r2, [r7, #28]
 8004ce4:	849a      	strh	r2, [r3, #36]	; 0x24
      ucg->arg.pixel.pos.y = x;
 8004ce6:	68fb      	ldr	r3, [r7, #12]
 8004ce8:	8bfa      	ldrh	r2, [r7, #30]
 8004cea:	84da      	strh	r2, [r3, #38]	; 0x26
    }
    ucg_DrawPixelWithArg(ucg);  
 8004cec:	68f8      	ldr	r0, [r7, #12]
 8004cee:	f7ff f8b2 	bl	8003e56 <ucg_DrawPixelWithArg>
    err -= (uint8_t)dy;
 8004cf2:	8afa      	ldrh	r2, [r7, #22]
 8004cf4:	8b3b      	ldrh	r3, [r7, #24]
 8004cf6:	b2db      	uxtb	r3, r3
 8004cf8:	b29b      	uxth	r3, r3
 8004cfa:	1ad3      	subs	r3, r2, r3
 8004cfc:	b29b      	uxth	r3, r3
 8004cfe:	82fb      	strh	r3, [r7, #22]
    if ( err < 0 ) 
 8004d00:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8004d04:	2b00      	cmp	r3, #0
 8004d06:	da09      	bge.n	8004d1c <ucg_DrawLine+0x158>
    {
      y += ystep;
 8004d08:	8bba      	ldrh	r2, [r7, #28]
 8004d0a:	8abb      	ldrh	r3, [r7, #20]
 8004d0c:	4413      	add	r3, r2
 8004d0e:	b29b      	uxth	r3, r3
 8004d10:	83bb      	strh	r3, [r7, #28]
      err += dx;
 8004d12:	8afa      	ldrh	r2, [r7, #22]
 8004d14:	8b7b      	ldrh	r3, [r7, #26]
 8004d16:	4413      	add	r3, r2
 8004d18:	b29b      	uxth	r3, r3
 8004d1a:	82fb      	strh	r3, [r7, #22]
  for( x = x1; x <= x2; x++ )
 8004d1c:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8004d20:	b29b      	uxth	r3, r3
 8004d22:	3301      	adds	r3, #1
 8004d24:	b29b      	uxth	r3, r3
 8004d26:	83fb      	strh	r3, [r7, #30]
 8004d28:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 8004d2c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8004d30:	429a      	cmp	r2, r3
 8004d32:	ddcb      	ble.n	8004ccc <ucg_DrawLine+0x108>
    }
  }

}
 8004d34:	bf00      	nop
 8004d36:	bf00      	nop
 8004d38:	3720      	adds	r7, #32
 8004d3a:	46bd      	mov	sp, r7
 8004d3c:	bd80      	pop	{r7, pc}

08004d3e <ucg_SetColor>:
*/

#include "ucg.h"

void ucg_SetColor(ucg_t *ucg, uint8_t idx, uint8_t r, uint8_t g, uint8_t b)
{
 8004d3e:	b480      	push	{r7}
 8004d40:	b083      	sub	sp, #12
 8004d42:	af00      	add	r7, sp, #0
 8004d44:	6078      	str	r0, [r7, #4]
 8004d46:	4608      	mov	r0, r1
 8004d48:	4611      	mov	r1, r2
 8004d4a:	461a      	mov	r2, r3
 8004d4c:	4603      	mov	r3, r0
 8004d4e:	70fb      	strb	r3, [r7, #3]
 8004d50:	460b      	mov	r3, r1
 8004d52:	70bb      	strb	r3, [r7, #2]
 8004d54:	4613      	mov	r3, r2
 8004d56:	707b      	strb	r3, [r7, #1]
  //ucg->arg.pixel.rgb.color[0] = r;
  //ucg->arg.pixel.rgb.color[1] = g;
  //ucg->arg.pixel.rgb.color[2] = b;
  ucg->arg.rgb[idx].color[0] = r;
 8004d58:	78fa      	ldrb	r2, [r7, #3]
 8004d5a:	6879      	ldr	r1, [r7, #4]
 8004d5c:	4613      	mov	r3, r2
 8004d5e:	005b      	lsls	r3, r3, #1
 8004d60:	4413      	add	r3, r2
 8004d62:	440b      	add	r3, r1
 8004d64:	333a      	adds	r3, #58	; 0x3a
 8004d66:	78ba      	ldrb	r2, [r7, #2]
 8004d68:	701a      	strb	r2, [r3, #0]
  ucg->arg.rgb[idx].color[1] = g;
 8004d6a:	78fa      	ldrb	r2, [r7, #3]
 8004d6c:	6879      	ldr	r1, [r7, #4]
 8004d6e:	4613      	mov	r3, r2
 8004d70:	005b      	lsls	r3, r3, #1
 8004d72:	4413      	add	r3, r2
 8004d74:	440b      	add	r3, r1
 8004d76:	333b      	adds	r3, #59	; 0x3b
 8004d78:	787a      	ldrb	r2, [r7, #1]
 8004d7a:	701a      	strb	r2, [r3, #0]
  ucg->arg.rgb[idx].color[2] = b;
 8004d7c:	78fa      	ldrb	r2, [r7, #3]
 8004d7e:	6879      	ldr	r1, [r7, #4]
 8004d80:	4613      	mov	r3, r2
 8004d82:	005b      	lsls	r3, r3, #1
 8004d84:	4413      	add	r3, r2
 8004d86:	440b      	add	r3, r1
 8004d88:	333c      	adds	r3, #60	; 0x3c
 8004d8a:	7c3a      	ldrb	r2, [r7, #16]
 8004d8c:	701a      	strb	r2, [r3, #0]
}
 8004d8e:	bf00      	nop
 8004d90:	370c      	adds	r7, #12
 8004d92:	46bd      	mov	sp, r7
 8004d94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004d98:	4770      	bx	lr

08004d9a <ucg_DrawPixel>:


void ucg_DrawPixel(ucg_t *ucg, ucg_int_t x, ucg_int_t y)
{
 8004d9a:	b580      	push	{r7, lr}
 8004d9c:	b082      	sub	sp, #8
 8004d9e:	af00      	add	r7, sp, #0
 8004da0:	6078      	str	r0, [r7, #4]
 8004da2:	460b      	mov	r3, r1
 8004da4:	807b      	strh	r3, [r7, #2]
 8004da6:	4613      	mov	r3, r2
 8004da8:	803b      	strh	r3, [r7, #0]
  ucg->arg.pixel.rgb.color[0] = ucg->arg.rgb[0].color[0];
 8004daa:	687b      	ldr	r3, [r7, #4]
 8004dac:	f893 203a 	ldrb.w	r2, [r3, #58]	; 0x3a
 8004db0:	687b      	ldr	r3, [r7, #4]
 8004db2:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  ucg->arg.pixel.rgb.color[1] = ucg->arg.rgb[0].color[1];
 8004db6:	687b      	ldr	r3, [r7, #4]
 8004db8:	f893 203b 	ldrb.w	r2, [r3, #59]	; 0x3b
 8004dbc:	687b      	ldr	r3, [r7, #4]
 8004dbe:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  ucg->arg.pixel.rgb.color[2] = ucg->arg.rgb[0].color[2];
 8004dc2:	687b      	ldr	r3, [r7, #4]
 8004dc4:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 8004dc8:	687b      	ldr	r3, [r7, #4]
 8004dca:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
  
  ucg->arg.pixel.pos.x = x;
 8004dce:	687b      	ldr	r3, [r7, #4]
 8004dd0:	887a      	ldrh	r2, [r7, #2]
 8004dd2:	849a      	strh	r2, [r3, #36]	; 0x24
  ucg->arg.pixel.pos.y = y;
 8004dd4:	687b      	ldr	r3, [r7, #4]
 8004dd6:	883a      	ldrh	r2, [r7, #0]
 8004dd8:	84da      	strh	r2, [r3, #38]	; 0x26
  ucg_DrawPixelWithArg(ucg);  
 8004dda:	6878      	ldr	r0, [r7, #4]
 8004ddc:	f7ff f83b 	bl	8003e56 <ucg_DrawPixelWithArg>
}
 8004de0:	bf00      	nop
 8004de2:	3708      	adds	r7, #8
 8004de4:	46bd      	mov	sp, r7
 8004de6:	bd80      	pop	{r7, pc}

08004de8 <pge_Next>:

/*===========================================*/
/* line draw algorithm */

static uint8_t pge_Next(struct pg_edge_struct *pge)
{
 8004de8:	b480      	push	{r7}
 8004dea:	b083      	sub	sp, #12
 8004dec:	af00      	add	r7, sp, #0
 8004dee:	6078      	str	r0, [r7, #4]
  if ( pge->current_y >= pge->max_y )
 8004df0:	687b      	ldr	r3, [r7, #4]
 8004df2:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
 8004df6:	687b      	ldr	r3, [r7, #4]
 8004df8:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8004dfc:	429a      	cmp	r2, r3
 8004dfe:	db01      	blt.n	8004e04 <pge_Next+0x1c>
    return 0;
 8004e00:	2300      	movs	r3, #0
 8004e02:	e042      	b.n	8004e8a <pge_Next+0xa2>
  
  pge->current_x += pge->current_x_offset;
 8004e04:	687b      	ldr	r3, [r7, #4]
 8004e06:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8004e0a:	b29a      	uxth	r2, r3
 8004e0c:	687b      	ldr	r3, [r7, #4]
 8004e0e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8004e12:	b29b      	uxth	r3, r3
 8004e14:	4413      	add	r3, r2
 8004e16:	b29b      	uxth	r3, r3
 8004e18:	b21a      	sxth	r2, r3
 8004e1a:	687b      	ldr	r3, [r7, #4]
 8004e1c:	819a      	strh	r2, [r3, #12]
  pge->error += pge->error_offset;
 8004e1e:	687b      	ldr	r3, [r7, #4]
 8004e20:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8004e24:	b29a      	uxth	r2, r3
 8004e26:	687b      	ldr	r3, [r7, #4]
 8004e28:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8004e2c:	b29b      	uxth	r3, r3
 8004e2e:	4413      	add	r3, r2
 8004e30:	b29b      	uxth	r3, r3
 8004e32:	b21a      	sxth	r2, r3
 8004e34:	687b      	ldr	r3, [r7, #4]
 8004e36:	81da      	strh	r2, [r3, #14]
  if ( pge->error > 0 )
 8004e38:	687b      	ldr	r3, [r7, #4]
 8004e3a:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8004e3e:	2b00      	cmp	r3, #0
 8004e40:	dd19      	ble.n	8004e76 <pge_Next+0x8e>
  {
    pge->current_x += pge->x_direction;
 8004e42:	687b      	ldr	r3, [r7, #4]
 8004e44:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8004e48:	b29a      	uxth	r2, r3
 8004e4a:	687b      	ldr	r3, [r7, #4]
 8004e4c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8004e50:	b29b      	uxth	r3, r3
 8004e52:	4413      	add	r3, r2
 8004e54:	b29b      	uxth	r3, r3
 8004e56:	b21a      	sxth	r2, r3
 8004e58:	687b      	ldr	r3, [r7, #4]
 8004e5a:	819a      	strh	r2, [r3, #12]
    pge->error -= pge->height;
 8004e5c:	687b      	ldr	r3, [r7, #4]
 8004e5e:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8004e62:	b29a      	uxth	r2, r3
 8004e64:	687b      	ldr	r3, [r7, #4]
 8004e66:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8004e6a:	b29b      	uxth	r3, r3
 8004e6c:	1ad3      	subs	r3, r2, r3
 8004e6e:	b29b      	uxth	r3, r3
 8004e70:	b21a      	sxth	r2, r3
 8004e72:	687b      	ldr	r3, [r7, #4]
 8004e74:	81da      	strh	r2, [r3, #14]
  }  
  
  pge->current_y++;
 8004e76:	687b      	ldr	r3, [r7, #4]
 8004e78:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8004e7c:	b29b      	uxth	r3, r3
 8004e7e:	3301      	adds	r3, #1
 8004e80:	b29b      	uxth	r3, r3
 8004e82:	b21a      	sxth	r2, r3
 8004e84:	687b      	ldr	r3, [r7, #4]
 8004e86:	811a      	strh	r2, [r3, #8]
  return 1;
 8004e88:	2301      	movs	r3, #1
}
 8004e8a:	4618      	mov	r0, r3
 8004e8c:	370c      	adds	r7, #12
 8004e8e:	46bd      	mov	sp, r7
 8004e90:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004e94:	4770      	bx	lr

08004e96 <pge_Init>:

/* assumes y2 > y1 */
static void pge_Init(struct pg_edge_struct *pge, pg_word_t x1, pg_word_t y1, pg_word_t x2, pg_word_t y2)
{
 8004e96:	b480      	push	{r7}
 8004e98:	b087      	sub	sp, #28
 8004e9a:	af00      	add	r7, sp, #0
 8004e9c:	60f8      	str	r0, [r7, #12]
 8004e9e:	4608      	mov	r0, r1
 8004ea0:	4611      	mov	r1, r2
 8004ea2:	461a      	mov	r2, r3
 8004ea4:	4603      	mov	r3, r0
 8004ea6:	817b      	strh	r3, [r7, #10]
 8004ea8:	460b      	mov	r3, r1
 8004eaa:	813b      	strh	r3, [r7, #8]
 8004eac:	4613      	mov	r3, r2
 8004eae:	80fb      	strh	r3, [r7, #6]
  pg_word_t dx = x2 - x1;
 8004eb0:	88fa      	ldrh	r2, [r7, #6]
 8004eb2:	897b      	ldrh	r3, [r7, #10]
 8004eb4:	1ad3      	subs	r3, r2, r3
 8004eb6:	b29b      	uxth	r3, r3
 8004eb8:	82bb      	strh	r3, [r7, #20]
  pg_word_t width;

  pge->height = y2 - y1;
 8004eba:	8c3a      	ldrh	r2, [r7, #32]
 8004ebc:	893b      	ldrh	r3, [r7, #8]
 8004ebe:	1ad3      	subs	r3, r2, r3
 8004ec0:	b29b      	uxth	r3, r3
 8004ec2:	b21a      	sxth	r2, r3
 8004ec4:	68fb      	ldr	r3, [r7, #12]
 8004ec6:	805a      	strh	r2, [r3, #2]
  pge->max_y = y2;
 8004ec8:	68fb      	ldr	r3, [r7, #12]
 8004eca:	8c3a      	ldrh	r2, [r7, #32]
 8004ecc:	815a      	strh	r2, [r3, #10]
  pge->current_y = y1;
 8004ece:	68fb      	ldr	r3, [r7, #12]
 8004ed0:	893a      	ldrh	r2, [r7, #8]
 8004ed2:	811a      	strh	r2, [r3, #8]
  pge->current_x = x1;
 8004ed4:	68fb      	ldr	r3, [r7, #12]
 8004ed6:	897a      	ldrh	r2, [r7, #10]
 8004ed8:	819a      	strh	r2, [r3, #12]

  if ( dx >= 0 )
 8004eda:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8004ede:	2b00      	cmp	r3, #0
 8004ee0:	db08      	blt.n	8004ef4 <pge_Init+0x5e>
  {
    pge->x_direction = 1;
 8004ee2:	68fb      	ldr	r3, [r7, #12]
 8004ee4:	2201      	movs	r2, #1
 8004ee6:	801a      	strh	r2, [r3, #0]
    width = dx;
 8004ee8:	8abb      	ldrh	r3, [r7, #20]
 8004eea:	82fb      	strh	r3, [r7, #22]
    pge->error = 0;
 8004eec:	68fb      	ldr	r3, [r7, #12]
 8004eee:	2200      	movs	r2, #0
 8004ef0:	81da      	strh	r2, [r3, #14]
 8004ef2:	e011      	b.n	8004f18 <pge_Init+0x82>
  }
  else
  {
    pge->x_direction = -1;
 8004ef4:	68fb      	ldr	r3, [r7, #12]
 8004ef6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8004efa:	801a      	strh	r2, [r3, #0]
    width = -dx;
 8004efc:	8abb      	ldrh	r3, [r7, #20]
 8004efe:	425b      	negs	r3, r3
 8004f00:	b29b      	uxth	r3, r3
 8004f02:	82fb      	strh	r3, [r7, #22]
    pge->error = 1 - pge->height;
 8004f04:	68fb      	ldr	r3, [r7, #12]
 8004f06:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8004f0a:	b29b      	uxth	r3, r3
 8004f0c:	f1c3 0301 	rsb	r3, r3, #1
 8004f10:	b29b      	uxth	r3, r3
 8004f12:	b21a      	sxth	r2, r3
 8004f14:	68fb      	ldr	r3, [r7, #12]
 8004f16:	81da      	strh	r2, [r3, #14]
  }
  
  pge->current_x_offset = dx / pge->height;
 8004f18:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8004f1c:	68fa      	ldr	r2, [r7, #12]
 8004f1e:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 8004f22:	fb93 f3f2 	sdiv	r3, r3, r2
 8004f26:	b21a      	sxth	r2, r3
 8004f28:	68fb      	ldr	r3, [r7, #12]
 8004f2a:	809a      	strh	r2, [r3, #4]
  pge->error_offset = width % pge->height;
 8004f2c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8004f30:	68fa      	ldr	r2, [r7, #12]
 8004f32:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 8004f36:	fb93 f1f2 	sdiv	r1, r3, r2
 8004f3a:	fb01 f202 	mul.w	r2, r1, r2
 8004f3e:	1a9b      	subs	r3, r3, r2
 8004f40:	b21a      	sxth	r2, r3
 8004f42:	68fb      	ldr	r3, [r7, #12]
 8004f44:	80da      	strh	r2, [r3, #6]
}
 8004f46:	bf00      	nop
 8004f48:	371c      	adds	r7, #28
 8004f4a:	46bd      	mov	sp, r7
 8004f4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f50:	4770      	bx	lr

08004f52 <pg_inc>:

/*===========================================*/
/* convex polygon algorithm */

static uint8_t pg_inc(pg_struct *pg, uint8_t i)
{
 8004f52:	b480      	push	{r7}
 8004f54:	b083      	sub	sp, #12
 8004f56:	af00      	add	r7, sp, #0
 8004f58:	6078      	str	r0, [r7, #4]
 8004f5a:	460b      	mov	r3, r1
 8004f5c:	70fb      	strb	r3, [r7, #3]
    i++;
 8004f5e:	78fb      	ldrb	r3, [r7, #3]
 8004f60:	3301      	adds	r3, #1
 8004f62:	70fb      	strb	r3, [r7, #3]
    if ( i >= pg->cnt )
 8004f64:	687b      	ldr	r3, [r7, #4]
 8004f66:	7c1b      	ldrb	r3, [r3, #16]
 8004f68:	78fa      	ldrb	r2, [r7, #3]
 8004f6a:	429a      	cmp	r2, r3
 8004f6c:	d301      	bcc.n	8004f72 <pg_inc+0x20>
      i = 0;
 8004f6e:	2300      	movs	r3, #0
 8004f70:	70fb      	strb	r3, [r7, #3]
    return i;
 8004f72:	78fb      	ldrb	r3, [r7, #3]
}
 8004f74:	4618      	mov	r0, r3
 8004f76:	370c      	adds	r7, #12
 8004f78:	46bd      	mov	sp, r7
 8004f7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f7e:	4770      	bx	lr

08004f80 <pg_dec>:

static uint8_t pg_dec(pg_struct *pg, uint8_t i)
{
 8004f80:	b480      	push	{r7}
 8004f82:	b083      	sub	sp, #12
 8004f84:	af00      	add	r7, sp, #0
 8004f86:	6078      	str	r0, [r7, #4]
 8004f88:	460b      	mov	r3, r1
 8004f8a:	70fb      	strb	r3, [r7, #3]
    i--;
 8004f8c:	78fb      	ldrb	r3, [r7, #3]
 8004f8e:	3b01      	subs	r3, #1
 8004f90:	70fb      	strb	r3, [r7, #3]
    if ( i >= pg->cnt )
 8004f92:	687b      	ldr	r3, [r7, #4]
 8004f94:	7c1b      	ldrb	r3, [r3, #16]
 8004f96:	78fa      	ldrb	r2, [r7, #3]
 8004f98:	429a      	cmp	r2, r3
 8004f9a:	d303      	bcc.n	8004fa4 <pg_dec+0x24>
      i = pg->cnt-1;
 8004f9c:	687b      	ldr	r3, [r7, #4]
 8004f9e:	7c1b      	ldrb	r3, [r3, #16]
 8004fa0:	3b01      	subs	r3, #1
 8004fa2:	70fb      	strb	r3, [r7, #3]
    return i;
 8004fa4:	78fb      	ldrb	r3, [r7, #3]
}
 8004fa6:	4618      	mov	r0, r3
 8004fa8:	370c      	adds	r7, #12
 8004faa:	46bd      	mov	sp, r7
 8004fac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004fb0:	4770      	bx	lr

08004fb2 <pg_expand_min_y>:

static void pg_expand_min_y(pg_struct *pg, pg_word_t min_y, uint8_t pge_idx)
{
 8004fb2:	b580      	push	{r7, lr}
 8004fb4:	b084      	sub	sp, #16
 8004fb6:	af00      	add	r7, sp, #0
 8004fb8:	6078      	str	r0, [r7, #4]
 8004fba:	460b      	mov	r3, r1
 8004fbc:	807b      	strh	r3, [r7, #2]
 8004fbe:	4613      	mov	r3, r2
 8004fc0:	707b      	strb	r3, [r7, #1]
  uint8_t i = pg->pge[pge_idx].curr_idx;
 8004fc2:	787a      	ldrb	r2, [r7, #1]
 8004fc4:	6879      	ldr	r1, [r7, #4]
 8004fc6:	4613      	mov	r3, r2
 8004fc8:	005b      	lsls	r3, r3, #1
 8004fca:	4413      	add	r3, r2
 8004fcc:	00db      	lsls	r3, r3, #3
 8004fce:	440b      	add	r3, r1
 8004fd0:	3328      	adds	r3, #40	; 0x28
 8004fd2:	781b      	ldrb	r3, [r3, #0]
 8004fd4:	73fb      	strb	r3, [r7, #15]
  for(;;)
  {
    i = pg->pge[pge_idx].next_idx_fn(pg, i);
 8004fd6:	787a      	ldrb	r2, [r7, #1]
 8004fd8:	6879      	ldr	r1, [r7, #4]
 8004fda:	4613      	mov	r3, r2
 8004fdc:	005b      	lsls	r3, r3, #1
 8004fde:	4413      	add	r3, r2
 8004fe0:	00db      	lsls	r3, r3, #3
 8004fe2:	440b      	add	r3, r1
 8004fe4:	3324      	adds	r3, #36	; 0x24
 8004fe6:	681b      	ldr	r3, [r3, #0]
 8004fe8:	7bfa      	ldrb	r2, [r7, #15]
 8004fea:	4611      	mov	r1, r2
 8004fec:	6878      	ldr	r0, [r7, #4]
 8004fee:	4798      	blx	r3
 8004ff0:	4603      	mov	r3, r0
 8004ff2:	73fb      	strb	r3, [r7, #15]
    if ( pg->list[i].y != min_y )
 8004ff4:	7bfb      	ldrb	r3, [r7, #15]
 8004ff6:	687a      	ldr	r2, [r7, #4]
 8004ff8:	009b      	lsls	r3, r3, #2
 8004ffa:	4413      	add	r3, r2
 8004ffc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005000:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 8005004:	429a      	cmp	r2, r3
 8005006:	d10a      	bne.n	800501e <pg_expand_min_y+0x6c>
      break;	
    pg->pge[pge_idx].curr_idx = i;
 8005008:	787a      	ldrb	r2, [r7, #1]
 800500a:	6879      	ldr	r1, [r7, #4]
 800500c:	4613      	mov	r3, r2
 800500e:	005b      	lsls	r3, r3, #1
 8005010:	4413      	add	r3, r2
 8005012:	00db      	lsls	r3, r3, #3
 8005014:	440b      	add	r3, r1
 8005016:	3328      	adds	r3, #40	; 0x28
 8005018:	7bfa      	ldrb	r2, [r7, #15]
 800501a:	701a      	strb	r2, [r3, #0]
    i = pg->pge[pge_idx].next_idx_fn(pg, i);
 800501c:	e7db      	b.n	8004fd6 <pg_expand_min_y+0x24>
      break;	
 800501e:	bf00      	nop
  }
}
 8005020:	bf00      	nop
 8005022:	3710      	adds	r7, #16
 8005024:	46bd      	mov	sp, r7
 8005026:	bd80      	pop	{r7, pc}

08005028 <pg_prepare>:

static uint8_t pg_prepare(pg_struct *pg)
{
 8005028:	b580      	push	{r7, lr}
 800502a:	b084      	sub	sp, #16
 800502c:	af00      	add	r7, sp, #0
 800502e:	6078      	str	r0, [r7, #4]
  pg_word_t max_y;
  pg_word_t min_y;
  uint8_t i;

  /* setup the next index procedures */
  pg->pge[PG_RIGHT].next_idx_fn = pg_inc;
 8005030:	687b      	ldr	r3, [r7, #4]
 8005032:	4a49      	ldr	r2, [pc, #292]	; (8005158 <pg_prepare+0x130>)
 8005034:	63da      	str	r2, [r3, #60]	; 0x3c
  pg->pge[PG_LEFT].next_idx_fn = pg_dec;
 8005036:	687b      	ldr	r3, [r7, #4]
 8005038:	4a48      	ldr	r2, [pc, #288]	; (800515c <pg_prepare+0x134>)
 800503a:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* search for highest and lowest point */
  max_y = pg->list[0].y;
 800503c:	687b      	ldr	r3, [r7, #4]
 800503e:	885b      	ldrh	r3, [r3, #2]
 8005040:	81fb      	strh	r3, [r7, #14]
  min_y = pg->list[0].y;
 8005042:	687b      	ldr	r3, [r7, #4]
 8005044:	885b      	ldrh	r3, [r3, #2]
 8005046:	81bb      	strh	r3, [r7, #12]
  pg->pge[PG_LEFT].curr_idx = 0;
 8005048:	687b      	ldr	r3, [r7, #4]
 800504a:	2200      	movs	r2, #0
 800504c:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  for( i = 1; i < pg->cnt; i++ )
 8005050:	2301      	movs	r3, #1
 8005052:	72fb      	strb	r3, [r7, #11]
 8005054:	e026      	b.n	80050a4 <pg_prepare+0x7c>
  {
    if ( max_y < pg->list[i].y )
 8005056:	7afb      	ldrb	r3, [r7, #11]
 8005058:	687a      	ldr	r2, [r7, #4]
 800505a:	009b      	lsls	r3, r3, #2
 800505c:	4413      	add	r3, r2
 800505e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005062:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8005066:	429a      	cmp	r2, r3
 8005068:	da05      	bge.n	8005076 <pg_prepare+0x4e>
    {
      max_y = pg->list[i].y;
 800506a:	7afb      	ldrb	r3, [r7, #11]
 800506c:	687a      	ldr	r2, [r7, #4]
 800506e:	009b      	lsls	r3, r3, #2
 8005070:	4413      	add	r3, r2
 8005072:	885b      	ldrh	r3, [r3, #2]
 8005074:	81fb      	strh	r3, [r7, #14]
    }
    if ( min_y > pg->list[i].y )
 8005076:	7afb      	ldrb	r3, [r7, #11]
 8005078:	687a      	ldr	r2, [r7, #4]
 800507a:	009b      	lsls	r3, r3, #2
 800507c:	4413      	add	r3, r2
 800507e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005082:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8005086:	429a      	cmp	r2, r3
 8005088:	dd09      	ble.n	800509e <pg_prepare+0x76>
    {
      pg->pge[PG_LEFT].curr_idx = i;
 800508a:	687b      	ldr	r3, [r7, #4]
 800508c:	7afa      	ldrb	r2, [r7, #11]
 800508e:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
      min_y = pg->list[i].y;
 8005092:	7afb      	ldrb	r3, [r7, #11]
 8005094:	687a      	ldr	r2, [r7, #4]
 8005096:	009b      	lsls	r3, r3, #2
 8005098:	4413      	add	r3, r2
 800509a:	885b      	ldrh	r3, [r3, #2]
 800509c:	81bb      	strh	r3, [r7, #12]
  for( i = 1; i < pg->cnt; i++ )
 800509e:	7afb      	ldrb	r3, [r7, #11]
 80050a0:	3301      	adds	r3, #1
 80050a2:	72fb      	strb	r3, [r7, #11]
 80050a4:	687b      	ldr	r3, [r7, #4]
 80050a6:	7c1b      	ldrb	r3, [r3, #16]
 80050a8:	7afa      	ldrb	r2, [r7, #11]
 80050aa:	429a      	cmp	r2, r3
 80050ac:	d3d3      	bcc.n	8005056 <pg_prepare+0x2e>
    }
  }

  /* calculate total number of scan lines */
  pg->total_scan_line_cnt = max_y;
 80050ae:	687b      	ldr	r3, [r7, #4]
 80050b0:	89fa      	ldrh	r2, [r7, #14]
 80050b2:	825a      	strh	r2, [r3, #18]
  pg->total_scan_line_cnt -= min_y;
 80050b4:	687b      	ldr	r3, [r7, #4]
 80050b6:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80050ba:	b29a      	uxth	r2, r3
 80050bc:	89bb      	ldrh	r3, [r7, #12]
 80050be:	1ad3      	subs	r3, r2, r3
 80050c0:	b29b      	uxth	r3, r3
 80050c2:	b21a      	sxth	r2, r3
 80050c4:	687b      	ldr	r3, [r7, #4]
 80050c6:	825a      	strh	r2, [r3, #18]
  
  /* exit if polygon height is zero */
  if ( pg->total_scan_line_cnt == 0 )
 80050c8:	687b      	ldr	r3, [r7, #4]
 80050ca:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80050ce:	2b00      	cmp	r3, #0
 80050d0:	d101      	bne.n	80050d6 <pg_prepare+0xae>
    return 0;
 80050d2:	2300      	movs	r3, #0
 80050d4:	e03b      	b.n	800514e <pg_prepare+0x126>
  
  /* if the minimum y side is flat, try to find the lowest and highest x points */
  pg->pge[PG_RIGHT].curr_idx = pg->pge[PG_LEFT].curr_idx;  
 80050d6:	687b      	ldr	r3, [r7, #4]
 80050d8:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
 80050dc:	687b      	ldr	r3, [r7, #4]
 80050de:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  pg_expand_min_y(pg, min_y, PG_RIGHT);
 80050e2:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80050e6:	2201      	movs	r2, #1
 80050e8:	4619      	mov	r1, r3
 80050ea:	6878      	ldr	r0, [r7, #4]
 80050ec:	f7ff ff61 	bl	8004fb2 <pg_expand_min_y>
  pg_expand_min_y(pg, min_y, PG_LEFT);
 80050f0:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80050f4:	2200      	movs	r2, #0
 80050f6:	4619      	mov	r1, r3
 80050f8:	6878      	ldr	r0, [r7, #4]
 80050fa:	f7ff ff5a 	bl	8004fb2 <pg_expand_min_y>
  
  /* check if the min side is really flat (depends on the x values) */
  pg->is_min_y_not_flat = 1;
 80050fe:	687b      	ldr	r3, [r7, #4]
 8005100:	2201      	movs	r2, #1
 8005102:	745a      	strb	r2, [r3, #17]
  if ( pg->list[pg->pge[PG_LEFT].curr_idx].x != pg->list[pg->pge[PG_RIGHT].curr_idx].x )
 8005104:	687b      	ldr	r3, [r7, #4]
 8005106:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 800510a:	461a      	mov	r2, r3
 800510c:	687b      	ldr	r3, [r7, #4]
 800510e:	f933 2022 	ldrsh.w	r2, [r3, r2, lsl #2]
 8005112:	687b      	ldr	r3, [r7, #4]
 8005114:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8005118:	4619      	mov	r1, r3
 800511a:	687b      	ldr	r3, [r7, #4]
 800511c:	f933 3021 	ldrsh.w	r3, [r3, r1, lsl #2]
 8005120:	429a      	cmp	r2, r3
 8005122:	d003      	beq.n	800512c <pg_prepare+0x104>
  {
    pg->is_min_y_not_flat = 0;
 8005124:	687b      	ldr	r3, [r7, #4]
 8005126:	2200      	movs	r2, #0
 8005128:	745a      	strb	r2, [r3, #17]
 800512a:	e00f      	b.n	800514c <pg_prepare+0x124>
  }
  else
  {
    pg->total_scan_line_cnt--;
 800512c:	687b      	ldr	r3, [r7, #4]
 800512e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8005132:	b29b      	uxth	r3, r3
 8005134:	3b01      	subs	r3, #1
 8005136:	b29b      	uxth	r3, r3
 8005138:	b21a      	sxth	r2, r3
 800513a:	687b      	ldr	r3, [r7, #4]
 800513c:	825a      	strh	r2, [r3, #18]
    if ( pg->total_scan_line_cnt == 0 )
 800513e:	687b      	ldr	r3, [r7, #4]
 8005140:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8005144:	2b00      	cmp	r3, #0
 8005146:	d101      	bne.n	800514c <pg_prepare+0x124>
      return 0;
 8005148:	2300      	movs	r3, #0
 800514a:	e000      	b.n	800514e <pg_prepare+0x126>
  }

  return 1;
 800514c:	2301      	movs	r3, #1
}
 800514e:	4618      	mov	r0, r3
 8005150:	3710      	adds	r7, #16
 8005152:	46bd      	mov	sp, r7
 8005154:	bd80      	pop	{r7, pc}
 8005156:	bf00      	nop
 8005158:	08004f53 	.word	0x08004f53
 800515c:	08004f81 	.word	0x08004f81

08005160 <pg_hline>:

static void pg_hline(pg_struct *pg, ucg_t *ucg)
{
 8005160:	b580      	push	{r7, lr}
 8005162:	b084      	sub	sp, #16
 8005164:	af00      	add	r7, sp, #0
 8005166:	6078      	str	r0, [r7, #4]
 8005168:	6039      	str	r1, [r7, #0]
  pg_word_t x1, x2, y;
  x1 = pg->pge[PG_LEFT].current_x;
 800516a:	687b      	ldr	r3, [r7, #4]
 800516c:	8c1b      	ldrh	r3, [r3, #32]
 800516e:	81fb      	strh	r3, [r7, #14]
  x2 = pg->pge[PG_RIGHT].current_x;
 8005170:	687b      	ldr	r3, [r7, #4]
 8005172:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8005174:	81bb      	strh	r3, [r7, #12]
  y = pg->pge[PG_RIGHT].current_y;
 8005176:	687b      	ldr	r3, [r7, #4]
 8005178:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 800517a:	817b      	strh	r3, [r7, #10]
  
  if ( y < 0 )
 800517c:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8005180:	2b00      	cmp	r3, #0
 8005182:	db5c      	blt.n	800523e <pg_hline+0xde>
    return;
  if ( y >= ucg_GetHeight(ucg) )
 8005184:	683b      	ldr	r3, [r7, #0]
 8005186:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800518a:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 800518e:	429a      	cmp	r2, r3
 8005190:	da57      	bge.n	8005242 <pg_hline+0xe2>
    return;
  if ( x1 < x2 )
 8005192:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8005196:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 800519a:	429a      	cmp	r2, r3
 800519c:	da27      	bge.n	80051ee <pg_hline+0x8e>
  {
    if ( x2 < 0 )
 800519e:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80051a2:	2b00      	cmp	r3, #0
 80051a4:	db4f      	blt.n	8005246 <pg_hline+0xe6>
      return;
    if ( x1 >= ucg_GetWidth(ucg) )
 80051a6:	683b      	ldr	r3, [r7, #0]
 80051a8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80051ac:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 80051b0:	429a      	cmp	r2, r3
 80051b2:	da4a      	bge.n	800524a <pg_hline+0xea>
      return;
    if ( x1 < 0 )
 80051b4:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80051b8:	2b00      	cmp	r3, #0
 80051ba:	da01      	bge.n	80051c0 <pg_hline+0x60>
      x1 = 0;
 80051bc:	2300      	movs	r3, #0
 80051be:	81fb      	strh	r3, [r7, #14]
    if ( x2 >= ucg_GetWidth(ucg) )
 80051c0:	683b      	ldr	r3, [r7, #0]
 80051c2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80051c6:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 80051ca:	429a      	cmp	r2, r3
 80051cc:	db02      	blt.n	80051d4 <pg_hline+0x74>
      x2 = ucg_GetWidth(ucg);
 80051ce:	683b      	ldr	r3, [r7, #0]
 80051d0:	885b      	ldrh	r3, [r3, #2]
 80051d2:	81bb      	strh	r3, [r7, #12]
    ucg_DrawHLine(ucg, x1, y, x2 - x1);
 80051d4:	89ba      	ldrh	r2, [r7, #12]
 80051d6:	89fb      	ldrh	r3, [r7, #14]
 80051d8:	1ad3      	subs	r3, r2, r3
 80051da:	b29b      	uxth	r3, r3
 80051dc:	b21b      	sxth	r3, r3
 80051de:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 80051e2:	f9b7 100e 	ldrsh.w	r1, [r7, #14]
 80051e6:	6838      	ldr	r0, [r7, #0]
 80051e8:	f7ff fcb0 	bl	8004b4c <ucg_DrawHLine>
 80051ec:	e032      	b.n	8005254 <pg_hline+0xf4>
  }
  else
  {
    if ( x1 < 0 )
 80051ee:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80051f2:	2b00      	cmp	r3, #0
 80051f4:	db2b      	blt.n	800524e <pg_hline+0xee>
      return;
    if ( x2 >= ucg_GetWidth(ucg) )
 80051f6:	683b      	ldr	r3, [r7, #0]
 80051f8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80051fc:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8005200:	429a      	cmp	r2, r3
 8005202:	da26      	bge.n	8005252 <pg_hline+0xf2>
      return;
    if ( x2 < 0 )
 8005204:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8005208:	2b00      	cmp	r3, #0
 800520a:	da01      	bge.n	8005210 <pg_hline+0xb0>
      x1 = 0;
 800520c:	2300      	movs	r3, #0
 800520e:	81fb      	strh	r3, [r7, #14]
    if ( x1 >= ucg_GetWidth(ucg) )
 8005210:	683b      	ldr	r3, [r7, #0]
 8005212:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005216:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 800521a:	429a      	cmp	r2, r3
 800521c:	db02      	blt.n	8005224 <pg_hline+0xc4>
      x1 = ucg_GetWidth(ucg);
 800521e:	683b      	ldr	r3, [r7, #0]
 8005220:	885b      	ldrh	r3, [r3, #2]
 8005222:	81fb      	strh	r3, [r7, #14]
    ucg_DrawHLine(ucg, x2, y, x1 - x2);
 8005224:	89fa      	ldrh	r2, [r7, #14]
 8005226:	89bb      	ldrh	r3, [r7, #12]
 8005228:	1ad3      	subs	r3, r2, r3
 800522a:	b29b      	uxth	r3, r3
 800522c:	b21b      	sxth	r3, r3
 800522e:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8005232:	f9b7 100c 	ldrsh.w	r1, [r7, #12]
 8005236:	6838      	ldr	r0, [r7, #0]
 8005238:	f7ff fc88 	bl	8004b4c <ucg_DrawHLine>
 800523c:	e00a      	b.n	8005254 <pg_hline+0xf4>
    return;
 800523e:	bf00      	nop
 8005240:	e008      	b.n	8005254 <pg_hline+0xf4>
    return;
 8005242:	bf00      	nop
 8005244:	e006      	b.n	8005254 <pg_hline+0xf4>
      return;
 8005246:	bf00      	nop
 8005248:	e004      	b.n	8005254 <pg_hline+0xf4>
      return;
 800524a:	bf00      	nop
 800524c:	e002      	b.n	8005254 <pg_hline+0xf4>
      return;
 800524e:	bf00      	nop
 8005250:	e000      	b.n	8005254 <pg_hline+0xf4>
      return;
 8005252:	bf00      	nop
  }
}
 8005254:	3710      	adds	r7, #16
 8005256:	46bd      	mov	sp, r7
 8005258:	bd80      	pop	{r7, pc}

0800525a <pg_line_init>:

static void pg_line_init(pg_struct * pg, uint8_t pge_index)
{
 800525a:	b580      	push	{r7, lr}
 800525c:	b088      	sub	sp, #32
 800525e:	af02      	add	r7, sp, #8
 8005260:	6078      	str	r0, [r7, #4]
 8005262:	460b      	mov	r3, r1
 8005264:	70fb      	strb	r3, [r7, #3]
  struct pg_edge_struct  *pge = pg->pge+pge_index;
 8005266:	687b      	ldr	r3, [r7, #4]
 8005268:	f103 0114 	add.w	r1, r3, #20
 800526c:	78fa      	ldrb	r2, [r7, #3]
 800526e:	4613      	mov	r3, r2
 8005270:	005b      	lsls	r3, r3, #1
 8005272:	4413      	add	r3, r2
 8005274:	00db      	lsls	r3, r3, #3
 8005276:	440b      	add	r3, r1
 8005278:	617b      	str	r3, [r7, #20]
  pg_word_t x1;
  pg_word_t y1;
  pg_word_t x2;
  pg_word_t y2;

  idx = pge->curr_idx;  
 800527a:	697b      	ldr	r3, [r7, #20]
 800527c:	7d1b      	ldrb	r3, [r3, #20]
 800527e:	74fb      	strb	r3, [r7, #19]
  y1 = pg->list[idx].y;
 8005280:	7cfb      	ldrb	r3, [r7, #19]
 8005282:	687a      	ldr	r2, [r7, #4]
 8005284:	009b      	lsls	r3, r3, #2
 8005286:	4413      	add	r3, r2
 8005288:	885b      	ldrh	r3, [r3, #2]
 800528a:	823b      	strh	r3, [r7, #16]
  x1 = pg->list[idx].x;
 800528c:	7cfa      	ldrb	r2, [r7, #19]
 800528e:	687b      	ldr	r3, [r7, #4]
 8005290:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
 8005294:	81fb      	strh	r3, [r7, #14]
  idx = pge->next_idx_fn(pg, idx);
 8005296:	697b      	ldr	r3, [r7, #20]
 8005298:	691b      	ldr	r3, [r3, #16]
 800529a:	7cfa      	ldrb	r2, [r7, #19]
 800529c:	4611      	mov	r1, r2
 800529e:	6878      	ldr	r0, [r7, #4]
 80052a0:	4798      	blx	r3
 80052a2:	4603      	mov	r3, r0
 80052a4:	74fb      	strb	r3, [r7, #19]
  y2 = pg->list[idx].y;
 80052a6:	7cfb      	ldrb	r3, [r7, #19]
 80052a8:	687a      	ldr	r2, [r7, #4]
 80052aa:	009b      	lsls	r3, r3, #2
 80052ac:	4413      	add	r3, r2
 80052ae:	885b      	ldrh	r3, [r3, #2]
 80052b0:	81bb      	strh	r3, [r7, #12]
  x2 = pg->list[idx].x; 
 80052b2:	7cfa      	ldrb	r2, [r7, #19]
 80052b4:	687b      	ldr	r3, [r7, #4]
 80052b6:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
 80052ba:	817b      	strh	r3, [r7, #10]
  pge->curr_idx = idx;
 80052bc:	697b      	ldr	r3, [r7, #20]
 80052be:	7cfa      	ldrb	r2, [r7, #19]
 80052c0:	751a      	strb	r2, [r3, #20]
  
  pge_Init(pge, x1, y1, x2, y2);
 80052c2:	f9b7 000a 	ldrsh.w	r0, [r7, #10]
 80052c6:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 80052ca:	f9b7 100e 	ldrsh.w	r1, [r7, #14]
 80052ce:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80052d2:	9300      	str	r3, [sp, #0]
 80052d4:	4603      	mov	r3, r0
 80052d6:	6978      	ldr	r0, [r7, #20]
 80052d8:	f7ff fddd 	bl	8004e96 <pge_Init>
}
 80052dc:	bf00      	nop
 80052de:	3718      	adds	r7, #24
 80052e0:	46bd      	mov	sp, r7
 80052e2:	bd80      	pop	{r7, pc}

080052e4 <pg_exec>:

static void pg_exec(pg_struct *pg, ucg_t *ucg)
{
 80052e4:	b580      	push	{r7, lr}
 80052e6:	b084      	sub	sp, #16
 80052e8:	af00      	add	r7, sp, #0
 80052ea:	6078      	str	r0, [r7, #4]
 80052ec:	6039      	str	r1, [r7, #0]
  pg_word_t i = pg->total_scan_line_cnt;
 80052ee:	687b      	ldr	r3, [r7, #4]
 80052f0:	8a5b      	ldrh	r3, [r3, #18]
 80052f2:	81fb      	strh	r3, [r7, #14]

  /* first line is skipped if the min y line is not flat */
  pg_line_init(pg, PG_LEFT);		
 80052f4:	2100      	movs	r1, #0
 80052f6:	6878      	ldr	r0, [r7, #4]
 80052f8:	f7ff ffaf 	bl	800525a <pg_line_init>
  pg_line_init(pg, PG_RIGHT);
 80052fc:	2101      	movs	r1, #1
 80052fe:	6878      	ldr	r0, [r7, #4]
 8005300:	f7ff ffab 	bl	800525a <pg_line_init>
  
  if ( pg->is_min_y_not_flat != 0 )
 8005304:	687b      	ldr	r3, [r7, #4]
 8005306:	7c5b      	ldrb	r3, [r3, #17]
 8005308:	2b00      	cmp	r3, #0
 800530a:	d009      	beq.n	8005320 <pg_exec+0x3c>
  {
    pge_Next(&(pg->pge[PG_LEFT])); 
 800530c:	687b      	ldr	r3, [r7, #4]
 800530e:	3314      	adds	r3, #20
 8005310:	4618      	mov	r0, r3
 8005312:	f7ff fd69 	bl	8004de8 <pge_Next>
    pge_Next(&(pg->pge[PG_RIGHT]));
 8005316:	687b      	ldr	r3, [r7, #4]
 8005318:	332c      	adds	r3, #44	; 0x2c
 800531a:	4618      	mov	r0, r3
 800531c:	f7ff fd64 	bl	8004de8 <pge_Next>
  }

  do
  {
    pg_hline(pg, ucg);
 8005320:	6839      	ldr	r1, [r7, #0]
 8005322:	6878      	ldr	r0, [r7, #4]
 8005324:	f7ff ff1c 	bl	8005160 <pg_hline>
    while ( pge_Next(&(pg->pge[PG_LEFT])) == 0 )
 8005328:	e003      	b.n	8005332 <pg_exec+0x4e>
    {
      pg_line_init(pg, PG_LEFT);
 800532a:	2100      	movs	r1, #0
 800532c:	6878      	ldr	r0, [r7, #4]
 800532e:	f7ff ff94 	bl	800525a <pg_line_init>
    while ( pge_Next(&(pg->pge[PG_LEFT])) == 0 )
 8005332:	687b      	ldr	r3, [r7, #4]
 8005334:	3314      	adds	r3, #20
 8005336:	4618      	mov	r0, r3
 8005338:	f7ff fd56 	bl	8004de8 <pge_Next>
 800533c:	4603      	mov	r3, r0
 800533e:	2b00      	cmp	r3, #0
 8005340:	d0f3      	beq.n	800532a <pg_exec+0x46>
    }
    while ( pge_Next(&(pg->pge[PG_RIGHT])) == 0 )
 8005342:	e003      	b.n	800534c <pg_exec+0x68>
    {
      pg_line_init(pg, PG_RIGHT);
 8005344:	2101      	movs	r1, #1
 8005346:	6878      	ldr	r0, [r7, #4]
 8005348:	f7ff ff87 	bl	800525a <pg_line_init>
    while ( pge_Next(&(pg->pge[PG_RIGHT])) == 0 )
 800534c:	687b      	ldr	r3, [r7, #4]
 800534e:	332c      	adds	r3, #44	; 0x2c
 8005350:	4618      	mov	r0, r3
 8005352:	f7ff fd49 	bl	8004de8 <pge_Next>
 8005356:	4603      	mov	r3, r0
 8005358:	2b00      	cmp	r3, #0
 800535a:	d0f3      	beq.n	8005344 <pg_exec+0x60>
    }
    i--;
 800535c:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8005360:	b29b      	uxth	r3, r3
 8005362:	3b01      	subs	r3, #1
 8005364:	b29b      	uxth	r3, r3
 8005366:	81fb      	strh	r3, [r7, #14]
  } while( i > 0 );
 8005368:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800536c:	2b00      	cmp	r3, #0
 800536e:	dcd7      	bgt.n	8005320 <pg_exec+0x3c>
}
 8005370:	bf00      	nop
 8005372:	bf00      	nop
 8005374:	3710      	adds	r7, #16
 8005376:	46bd      	mov	sp, r7
 8005378:	bd80      	pop	{r7, pc}

0800537a <pg_ClearPolygonXY>:

/*===========================================*/
/* API procedures */

void pg_ClearPolygonXY(pg_struct *pg)
{
 800537a:	b480      	push	{r7}
 800537c:	b083      	sub	sp, #12
 800537e:	af00      	add	r7, sp, #0
 8005380:	6078      	str	r0, [r7, #4]
  pg->cnt = 0;
 8005382:	687b      	ldr	r3, [r7, #4]
 8005384:	2200      	movs	r2, #0
 8005386:	741a      	strb	r2, [r3, #16]
}
 8005388:	bf00      	nop
 800538a:	370c      	adds	r7, #12
 800538c:	46bd      	mov	sp, r7
 800538e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005392:	4770      	bx	lr

08005394 <pg_AddPolygonXY>:

void pg_AddPolygonXY(pg_struct *pg, ucg_t *ucg, int16_t x, int16_t y)
{
 8005394:	b480      	push	{r7}
 8005396:	b085      	sub	sp, #20
 8005398:	af00      	add	r7, sp, #0
 800539a:	60f8      	str	r0, [r7, #12]
 800539c:	60b9      	str	r1, [r7, #8]
 800539e:	4611      	mov	r1, r2
 80053a0:	461a      	mov	r2, r3
 80053a2:	460b      	mov	r3, r1
 80053a4:	80fb      	strh	r3, [r7, #6]
 80053a6:	4613      	mov	r3, r2
 80053a8:	80bb      	strh	r3, [r7, #4]
  if ( pg->cnt < PG_MAX_POINTS )
 80053aa:	68fb      	ldr	r3, [r7, #12]
 80053ac:	7c1b      	ldrb	r3, [r3, #16]
 80053ae:	2b03      	cmp	r3, #3
 80053b0:	d813      	bhi.n	80053da <pg_AddPolygonXY+0x46>
  {
    pg->list[pg->cnt].x = x;
 80053b2:	68fb      	ldr	r3, [r7, #12]
 80053b4:	7c1b      	ldrb	r3, [r3, #16]
 80053b6:	4619      	mov	r1, r3
 80053b8:	68fb      	ldr	r3, [r7, #12]
 80053ba:	88fa      	ldrh	r2, [r7, #6]
 80053bc:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
    pg->list[pg->cnt].y = y;
 80053c0:	68fb      	ldr	r3, [r7, #12]
 80053c2:	7c1b      	ldrb	r3, [r3, #16]
 80053c4:	68fa      	ldr	r2, [r7, #12]
 80053c6:	009b      	lsls	r3, r3, #2
 80053c8:	4413      	add	r3, r2
 80053ca:	88ba      	ldrh	r2, [r7, #4]
 80053cc:	805a      	strh	r2, [r3, #2]
    pg->cnt++;
 80053ce:	68fb      	ldr	r3, [r7, #12]
 80053d0:	7c1b      	ldrb	r3, [r3, #16]
 80053d2:	3301      	adds	r3, #1
 80053d4:	b2da      	uxtb	r2, r3
 80053d6:	68fb      	ldr	r3, [r7, #12]
 80053d8:	741a      	strb	r2, [r3, #16]
  }
}
 80053da:	bf00      	nop
 80053dc:	3714      	adds	r7, #20
 80053de:	46bd      	mov	sp, r7
 80053e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80053e4:	4770      	bx	lr

080053e6 <pg_DrawPolygon>:

void pg_DrawPolygon(pg_struct *pg, ucg_t *ucg)
{
 80053e6:	b580      	push	{r7, lr}
 80053e8:	b082      	sub	sp, #8
 80053ea:	af00      	add	r7, sp, #0
 80053ec:	6078      	str	r0, [r7, #4]
 80053ee:	6039      	str	r1, [r7, #0]
  if ( pg_prepare(pg) == 0 )
 80053f0:	6878      	ldr	r0, [r7, #4]
 80053f2:	f7ff fe19 	bl	8005028 <pg_prepare>
 80053f6:	4603      	mov	r3, r0
 80053f8:	2b00      	cmp	r3, #0
 80053fa:	d004      	beq.n	8005406 <pg_DrawPolygon+0x20>
    return;
  pg_exec(pg, ucg);
 80053fc:	6839      	ldr	r1, [r7, #0]
 80053fe:	6878      	ldr	r0, [r7, #4]
 8005400:	f7ff ff70 	bl	80052e4 <pg_exec>
 8005404:	e000      	b.n	8005408 <pg_DrawPolygon+0x22>
    return;
 8005406:	bf00      	nop
}
 8005408:	3708      	adds	r7, #8
 800540a:	46bd      	mov	sp, r7
 800540c:	bd80      	pop	{r7, pc}
	...

08005410 <ucg_ClearPolygonXY>:

pg_struct ucg_pg;

void ucg_ClearPolygonXY(void)
{
 8005410:	b580      	push	{r7, lr}
 8005412:	af00      	add	r7, sp, #0
  pg_ClearPolygonXY(&ucg_pg);
 8005414:	4802      	ldr	r0, [pc, #8]	; (8005420 <ucg_ClearPolygonXY+0x10>)
 8005416:	f7ff ffb0 	bl	800537a <pg_ClearPolygonXY>
}
 800541a:	bf00      	nop
 800541c:	bd80      	pop	{r7, pc}
 800541e:	bf00      	nop
 8005420:	200014a0 	.word	0x200014a0

08005424 <ucg_AddPolygonXY>:

void ucg_AddPolygonXY(ucg_t *ucg, int16_t x, int16_t y)
{
 8005424:	b580      	push	{r7, lr}
 8005426:	b082      	sub	sp, #8
 8005428:	af00      	add	r7, sp, #0
 800542a:	6078      	str	r0, [r7, #4]
 800542c:	460b      	mov	r3, r1
 800542e:	807b      	strh	r3, [r7, #2]
 8005430:	4613      	mov	r3, r2
 8005432:	803b      	strh	r3, [r7, #0]
  pg_AddPolygonXY(&ucg_pg, ucg, x, y);
 8005434:	f9b7 3000 	ldrsh.w	r3, [r7]
 8005438:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 800543c:	6879      	ldr	r1, [r7, #4]
 800543e:	4803      	ldr	r0, [pc, #12]	; (800544c <ucg_AddPolygonXY+0x28>)
 8005440:	f7ff ffa8 	bl	8005394 <pg_AddPolygonXY>
}
 8005444:	bf00      	nop
 8005446:	3708      	adds	r7, #8
 8005448:	46bd      	mov	sp, r7
 800544a:	bd80      	pop	{r7, pc}
 800544c:	200014a0 	.word	0x200014a0

08005450 <ucg_DrawPolygon>:

void ucg_DrawPolygon(ucg_t *ucg)
{
 8005450:	b580      	push	{r7, lr}
 8005452:	b082      	sub	sp, #8
 8005454:	af00      	add	r7, sp, #0
 8005456:	6078      	str	r0, [r7, #4]
  pg_DrawPolygon(&ucg_pg, ucg);
 8005458:	6879      	ldr	r1, [r7, #4]
 800545a:	4803      	ldr	r0, [pc, #12]	; (8005468 <ucg_DrawPolygon+0x18>)
 800545c:	f7ff ffc3 	bl	80053e6 <pg_DrawPolygon>
}
 8005460:	bf00      	nop
 8005462:	3708      	adds	r7, #8
 8005464:	46bd      	mov	sp, r7
 8005466:	bd80      	pop	{r7, pc}
 8005468:	200014a0 	.word	0x200014a0

0800546c <ucg_DrawTriangle>:

void ucg_DrawTriangle(ucg_t *ucg, int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2)
{
 800546c:	b580      	push	{r7, lr}
 800546e:	b084      	sub	sp, #16
 8005470:	af00      	add	r7, sp, #0
 8005472:	60f8      	str	r0, [r7, #12]
 8005474:	4608      	mov	r0, r1
 8005476:	4611      	mov	r1, r2
 8005478:	461a      	mov	r2, r3
 800547a:	4603      	mov	r3, r0
 800547c:	817b      	strh	r3, [r7, #10]
 800547e:	460b      	mov	r3, r1
 8005480:	813b      	strh	r3, [r7, #8]
 8005482:	4613      	mov	r3, r2
 8005484:	80fb      	strh	r3, [r7, #6]
  ucg_ClearPolygonXY();
 8005486:	f7ff ffc3 	bl	8005410 <ucg_ClearPolygonXY>
  ucg_AddPolygonXY(ucg, x0, y0);
 800548a:	f9b7 2008 	ldrsh.w	r2, [r7, #8]
 800548e:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8005492:	4619      	mov	r1, r3
 8005494:	68f8      	ldr	r0, [r7, #12]
 8005496:	f7ff ffc5 	bl	8005424 <ucg_AddPolygonXY>
  ucg_AddPolygonXY(ucg, x1, y1);
 800549a:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 800549e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80054a2:	4619      	mov	r1, r3
 80054a4:	68f8      	ldr	r0, [r7, #12]
 80054a6:	f7ff ffbd 	bl	8005424 <ucg_AddPolygonXY>
  ucg_AddPolygonXY(ucg, x2, y2);
 80054aa:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 80054ae:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80054b2:	4619      	mov	r1, r3
 80054b4:	68f8      	ldr	r0, [r7, #12]
 80054b6:	f7ff ffb5 	bl	8005424 <ucg_AddPolygonXY>
  ucg_DrawPolygon(ucg);
 80054ba:	68f8      	ldr	r0, [r7, #12]
 80054bc:	f7ff ffc8 	bl	8005450 <ucg_DrawPolygon>
}
 80054c0:	bf00      	nop
 80054c2:	3710      	adds	r7, #16
 80054c4:	46bd      	mov	sp, r7
 80054c6:	bd80      	pop	{r7, pc}

080054c8 <ucg_UndoRotate>:
#include "ucg.h"
#include <assert.h>

/* Side-Effects: Update dimension and reset clip range to max */
void ucg_UndoRotate(ucg_t *ucg)
{
 80054c8:	b580      	push	{r7, lr}
 80054ca:	b082      	sub	sp, #8
 80054cc:	af00      	add	r7, sp, #0
 80054ce:	6078      	str	r0, [r7, #4]
  if ( ucg->rotate_chain_device_cb != NULL )
 80054d0:	687b      	ldr	r3, [r7, #4]
 80054d2:	691b      	ldr	r3, [r3, #16]
 80054d4:	2b00      	cmp	r3, #0
 80054d6:	d006      	beq.n	80054e6 <ucg_UndoRotate+0x1e>
  {
    ucg->device_cb = ucg->rotate_chain_device_cb;
 80054d8:	687b      	ldr	r3, [r7, #4]
 80054da:	691a      	ldr	r2, [r3, #16]
 80054dc:	687b      	ldr	r3, [r7, #4]
 80054de:	609a      	str	r2, [r3, #8]
    ucg->rotate_chain_device_cb = NULL;
 80054e0:	687b      	ldr	r3, [r7, #4]
 80054e2:	2200      	movs	r2, #0
 80054e4:	611a      	str	r2, [r3, #16]
  }
  ucg_GetDimension(ucg);
 80054e6:	6878      	ldr	r0, [r7, #4]
 80054e8:	f7fe fca3 	bl	8003e32 <ucg_GetDimension>
  ucg_SetMaxClipRange(ucg);
 80054ec:	6878      	ldr	r0, [r7, #4]
 80054ee:	f7fe fc88 	bl	8003e02 <ucg_SetMaxClipRange>
}
 80054f2:	bf00      	nop
 80054f4:	3708      	adds	r7, #8
 80054f6:	46bd      	mov	sp, r7
 80054f8:	bd80      	pop	{r7, pc}

080054fa <ucg_rotate_180_xy>:

/*================================================*/
/* 180 degree */

static void ucg_rotate_180_xy(ucg_t *ucg, ucg_xy_t *xy)
{
 80054fa:	b480      	push	{r7}
 80054fc:	b085      	sub	sp, #20
 80054fe:	af00      	add	r7, sp, #0
 8005500:	6078      	str	r0, [r7, #4]
 8005502:	6039      	str	r1, [r7, #0]
    ucg_int_t x, y;
    y = ucg->rotate_dimension.h;
 8005504:	687b      	ldr	r3, [r7, #4]
 8005506:	8adb      	ldrh	r3, [r3, #22]
 8005508:	81fb      	strh	r3, [r7, #14]
    y -= xy->y;
 800550a:	89fa      	ldrh	r2, [r7, #14]
 800550c:	683b      	ldr	r3, [r7, #0]
 800550e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8005512:	b29b      	uxth	r3, r3
 8005514:	1ad3      	subs	r3, r2, r3
 8005516:	b29b      	uxth	r3, r3
 8005518:	81fb      	strh	r3, [r7, #14]
    y--;
 800551a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 800551e:	b29b      	uxth	r3, r3
 8005520:	3b01      	subs	r3, #1
 8005522:	b29b      	uxth	r3, r3
 8005524:	81fb      	strh	r3, [r7, #14]
    xy->y = y;
 8005526:	683b      	ldr	r3, [r7, #0]
 8005528:	89fa      	ldrh	r2, [r7, #14]
 800552a:	805a      	strh	r2, [r3, #2]
  
    x = ucg->rotate_dimension.w;
 800552c:	687b      	ldr	r3, [r7, #4]
 800552e:	8a9b      	ldrh	r3, [r3, #20]
 8005530:	81bb      	strh	r3, [r7, #12]
    x -= xy->x;
 8005532:	89ba      	ldrh	r2, [r7, #12]
 8005534:	683b      	ldr	r3, [r7, #0]
 8005536:	f9b3 3000 	ldrsh.w	r3, [r3]
 800553a:	b29b      	uxth	r3, r3
 800553c:	1ad3      	subs	r3, r2, r3
 800553e:	b29b      	uxth	r3, r3
 8005540:	81bb      	strh	r3, [r7, #12]
    x--;
 8005542:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8005546:	b29b      	uxth	r3, r3
 8005548:	3b01      	subs	r3, #1
 800554a:	b29b      	uxth	r3, r3
 800554c:	81bb      	strh	r3, [r7, #12]
    xy->x = x;
 800554e:	683b      	ldr	r3, [r7, #0]
 8005550:	89ba      	ldrh	r2, [r7, #12]
 8005552:	801a      	strh	r2, [r3, #0]
  
}
 8005554:	bf00      	nop
 8005556:	3714      	adds	r7, #20
 8005558:	46bd      	mov	sp, r7
 800555a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800555e:	4770      	bx	lr

08005560 <ucg_dev_rotate180>:

ucg_int_t ucg_dev_rotate180(ucg_t *ucg, ucg_int_t msg, void *data)
{
 8005560:	b580      	push	{r7, lr}
 8005562:	b084      	sub	sp, #16
 8005564:	af00      	add	r7, sp, #0
 8005566:	60f8      	str	r0, [r7, #12]
 8005568:	460b      	mov	r3, r1
 800556a:	607a      	str	r2, [r7, #4]
 800556c:	817b      	strh	r3, [r7, #10]
  switch(msg)
 800556e:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8005572:	3b0c      	subs	r3, #12
 8005574:	2b0b      	cmp	r3, #11
 8005576:	d866      	bhi.n	8005646 <ucg_dev_rotate180+0xe6>
 8005578:	a201      	add	r2, pc, #4	; (adr r2, 8005580 <ucg_dev_rotate180+0x20>)
 800557a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800557e:	bf00      	nop
 8005580:	080055cf 	.word	0x080055cf
 8005584:	08005647 	.word	0x08005647
 8005588:	08005647 	.word	0x08005647
 800558c:	080055b1 	.word	0x080055b1
 8005590:	08005647 	.word	0x08005647
 8005594:	08005647 	.word	0x08005647
 8005598:	08005647 	.word	0x08005647
 800559c:	08005647 	.word	0x08005647
 80055a0:	08005617 	.word	0x08005617
 80055a4:	08005617 	.word	0x08005617
 80055a8:	08005647 	.word	0x08005647
 80055ac:	08005617 	.word	0x08005617
  {
    case UCG_MSG_GET_DIMENSION:
      ucg->rotate_chain_device_cb(ucg, msg, &(ucg->rotate_dimension)); 
 80055b0:	68fb      	ldr	r3, [r7, #12]
 80055b2:	691b      	ldr	r3, [r3, #16]
 80055b4:	68fa      	ldr	r2, [r7, #12]
 80055b6:	3214      	adds	r2, #20
 80055b8:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 80055bc:	68f8      	ldr	r0, [r7, #12]
 80055be:	4798      	blx	r3
      *((ucg_wh_t *)data) = (ucg->rotate_dimension);
 80055c0:	687a      	ldr	r2, [r7, #4]
 80055c2:	68fb      	ldr	r3, [r7, #12]
 80055c4:	3314      	adds	r3, #20
 80055c6:	6818      	ldr	r0, [r3, #0]
 80055c8:	6010      	str	r0, [r2, #0]
      return 1;
 80055ca:	2301      	movs	r3, #1
 80055cc:	e043      	b.n	8005656 <ucg_dev_rotate180+0xf6>
    case UCG_MSG_SET_CLIP_BOX:
      /* calculate and rotate lower right point of the clip box */
      ((ucg_box_t * )data)->ul.y += ((ucg_box_t * )data)->size.h-1;
 80055ce:	687b      	ldr	r3, [r7, #4]
 80055d0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80055d4:	b29a      	uxth	r2, r3
 80055d6:	687b      	ldr	r3, [r7, #4]
 80055d8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80055dc:	b29b      	uxth	r3, r3
 80055de:	4413      	add	r3, r2
 80055e0:	b29b      	uxth	r3, r3
 80055e2:	3b01      	subs	r3, #1
 80055e4:	b29b      	uxth	r3, r3
 80055e6:	b21a      	sxth	r2, r3
 80055e8:	687b      	ldr	r3, [r7, #4]
 80055ea:	805a      	strh	r2, [r3, #2]
      ((ucg_box_t * )data)->ul.x += ((ucg_box_t * )data)->size.w-1;
 80055ec:	687b      	ldr	r3, [r7, #4]
 80055ee:	f9b3 3000 	ldrsh.w	r3, [r3]
 80055f2:	b29a      	uxth	r2, r3
 80055f4:	687b      	ldr	r3, [r7, #4]
 80055f6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80055fa:	b29b      	uxth	r3, r3
 80055fc:	4413      	add	r3, r2
 80055fe:	b29b      	uxth	r3, r3
 8005600:	3b01      	subs	r3, #1
 8005602:	b29b      	uxth	r3, r3
 8005604:	b21a      	sxth	r2, r3
 8005606:	687b      	ldr	r3, [r7, #4]
 8005608:	801a      	strh	r2, [r3, #0]
      ucg_rotate_180_xy(ucg, &(((ucg_box_t * )data)->ul)); 
 800560a:	687b      	ldr	r3, [r7, #4]
 800560c:	4619      	mov	r1, r3
 800560e:	68f8      	ldr	r0, [r7, #12]
 8005610:	f7ff ff73 	bl	80054fa <ucg_rotate_180_xy>
      /* box dimensions are the same */
      break;
 8005614:	e017      	b.n	8005646 <ucg_dev_rotate180+0xe6>
#ifdef UCG_MSG_DRAW_L90BF
    case UCG_MSG_DRAW_L90BF:
#endif /* UCG_MSG_DRAW_L90BF */
    case UCG_MSG_DRAW_L90SE:
    //case UCG_MSG_DRAW_L90RL:
      ucg->arg.dir+=2;
 8005616:	68fb      	ldr	r3, [r7, #12]
 8005618:	f9b3 302e 	ldrsh.w	r3, [r3, #46]	; 0x2e
 800561c:	b29b      	uxth	r3, r3
 800561e:	3302      	adds	r3, #2
 8005620:	b29b      	uxth	r3, r3
 8005622:	b21a      	sxth	r2, r3
 8005624:	68fb      	ldr	r3, [r7, #12]
 8005626:	85da      	strh	r2, [r3, #46]	; 0x2e
      ucg->arg.dir&=3;
 8005628:	68fb      	ldr	r3, [r7, #12]
 800562a:	f9b3 302e 	ldrsh.w	r3, [r3, #46]	; 0x2e
 800562e:	f003 0303 	and.w	r3, r3, #3
 8005632:	b21a      	sxth	r2, r3
 8005634:	68fb      	ldr	r3, [r7, #12]
 8005636:	85da      	strh	r2, [r3, #46]	; 0x2e
      ucg_rotate_180_xy(ucg, &(ucg->arg.pixel.pos)); 
 8005638:	68fb      	ldr	r3, [r7, #12]
 800563a:	3324      	adds	r3, #36	; 0x24
 800563c:	4619      	mov	r1, r3
 800563e:	68f8      	ldr	r0, [r7, #12]
 8005640:	f7ff ff5b 	bl	80054fa <ucg_rotate_180_xy>
      break;
 8005644:	bf00      	nop
  }
  return ucg->rotate_chain_device_cb(ucg, msg, data);  
 8005646:	68fb      	ldr	r3, [r7, #12]
 8005648:	691b      	ldr	r3, [r3, #16]
 800564a:	f9b7 100a 	ldrsh.w	r1, [r7, #10]
 800564e:	687a      	ldr	r2, [r7, #4]
 8005650:	68f8      	ldr	r0, [r7, #12]
 8005652:	4798      	blx	r3
 8005654:	4603      	mov	r3, r0
}
 8005656:	4618      	mov	r0, r3
 8005658:	3710      	adds	r7, #16
 800565a:	46bd      	mov	sp, r7
 800565c:	bd80      	pop	{r7, pc}
 800565e:	bf00      	nop

08005660 <ucg_SetRotate180>:

/* Side-Effects: Update dimension and reset clip range to max */
void ucg_SetRotate180(ucg_t *ucg)
{
 8005660:	b580      	push	{r7, lr}
 8005662:	b082      	sub	sp, #8
 8005664:	af00      	add	r7, sp, #0
 8005666:	6078      	str	r0, [r7, #4]
  ucg_UndoRotate(ucg);
 8005668:	6878      	ldr	r0, [r7, #4]
 800566a:	f7ff ff2d 	bl	80054c8 <ucg_UndoRotate>
  ucg->rotate_chain_device_cb = ucg->device_cb;
 800566e:	687b      	ldr	r3, [r7, #4]
 8005670:	689a      	ldr	r2, [r3, #8]
 8005672:	687b      	ldr	r3, [r7, #4]
 8005674:	611a      	str	r2, [r3, #16]
  ucg->device_cb = ucg_dev_rotate180;
 8005676:	687b      	ldr	r3, [r7, #4]
 8005678:	4a05      	ldr	r2, [pc, #20]	; (8005690 <ucg_SetRotate180+0x30>)
 800567a:	609a      	str	r2, [r3, #8]
  ucg_GetDimension(ucg);
 800567c:	6878      	ldr	r0, [r7, #4]
 800567e:	f7fe fbd8 	bl	8003e32 <ucg_GetDimension>
  ucg_SetMaxClipRange(ucg);
 8005682:	6878      	ldr	r0, [r7, #4]
 8005684:	f7fe fbbd 	bl	8003e02 <ucg_SetMaxClipRange>
}
 8005688:	bf00      	nop
 800568a:	3708      	adds	r7, #8
 800568c:	46bd      	mov	sp, r7
 800568e:	bd80      	pop	{r7, pc}
 8005690:	08005561 	.word	0x08005561

08005694 <bufInit>:
bufInit(
    void *pBuffer,
    buffqueue_p pQueue,
	uint8_t sizeofElement,
	uint16_t numberOfElement
) {
 8005694:	b580      	push	{r7, lr}
 8005696:	b084      	sub	sp, #16
 8005698:	af00      	add	r7, sp, #0
 800569a:	60f8      	str	r0, [r7, #12]
 800569c:	60b9      	str	r1, [r7, #8]
 800569e:	4611      	mov	r1, r2
 80056a0:	461a      	mov	r2, r3
 80056a2:	460b      	mov	r3, r1
 80056a4:	71fb      	strb	r3, [r7, #7]
 80056a6:	4613      	mov	r3, r2
 80056a8:	80bb      	strh	r3, [r7, #4]
    pQueue->wSize = numberOfElement;
 80056aa:	68bb      	ldr	r3, [r7, #8]
 80056ac:	88ba      	ldrh	r2, [r7, #4]
 80056ae:	801a      	strh	r2, [r3, #0]
    pQueue->byItemSize = sizeofElement;
 80056b0:	68bb      	ldr	r3, [r7, #8]
 80056b2:	79fa      	ldrb	r2, [r7, #7]
 80056b4:	711a      	strb	r2, [r3, #4]
    pQueue->pData = (uint8_t *)pBuffer;
 80056b6:	68bb      	ldr	r3, [r7, #8]
 80056b8:	68fa      	ldr	r2, [r7, #12]
 80056ba:	60da      	str	r2, [r3, #12]
    bufFlush(pQueue);
 80056bc:	68b8      	ldr	r0, [r7, #8]
 80056be:	f000 f836 	bl	800572e <bufFlush>
}
 80056c2:	bf00      	nop
 80056c4:	3710      	adds	r7, #16
 80056c6:	46bd      	mov	sp, r7
 80056c8:	bd80      	pop	{r7, pc}

080056ca <bufNumItems>:
 * @return The number of items in the ring buffer
 */
uint16_t
bufNumItems(
	buffqueue_p pQueue
) {
 80056ca:	b480      	push	{r7}
 80056cc:	b083      	sub	sp, #12
 80056ce:	af00      	add	r7, sp, #0
 80056d0:	6078      	str	r0, [r7, #4]
    return pQueue->wCountEle;
 80056d2:	687b      	ldr	r3, [r7, #4]
 80056d4:	885b      	ldrh	r3, [r3, #2]
}
 80056d6:	4618      	mov	r0, r3
 80056d8:	370c      	adds	r7, #12
 80056da:	46bd      	mov	sp, r7
 80056dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80056e0:	4770      	bx	lr

080056e2 <bufIsFull>:
 * @return 1 if full; 0 otherwise
 */
uint8_t
bufIsFull(
    buffqueue_p pQueue
) {
 80056e2:	b480      	push	{r7}
 80056e4:	b083      	sub	sp, #12
 80056e6:	af00      	add	r7, sp, #0
 80056e8:	6078      	str	r0, [r7, #4]
    return (pQueue->wCountEle >= pQueue->wSize);
 80056ea:	687b      	ldr	r3, [r7, #4]
 80056ec:	885a      	ldrh	r2, [r3, #2]
 80056ee:	687b      	ldr	r3, [r7, #4]
 80056f0:	881b      	ldrh	r3, [r3, #0]
 80056f2:	429a      	cmp	r2, r3
 80056f4:	bf2c      	ite	cs
 80056f6:	2301      	movcs	r3, #1
 80056f8:	2300      	movcc	r3, #0
 80056fa:	b2db      	uxtb	r3, r3
}
 80056fc:	4618      	mov	r0, r3
 80056fe:	370c      	adds	r7, #12
 8005700:	46bd      	mov	sp, r7
 8005702:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005706:	4770      	bx	lr

08005708 <bufIsEmpty>:
 * @return 1 if empty; 0 otherwise
 */
uint8_t
bufIsEmpty(
    buffqueue_p pQueue
) {
 8005708:	b480      	push	{r7}
 800570a:	b083      	sub	sp, #12
 800570c:	af00      	add	r7, sp, #0
 800570e:	6078      	str	r0, [r7, #4]
    return (pQueue->wHeadIndex == pQueue->wTailIndex);
 8005710:	687b      	ldr	r3, [r7, #4]
 8005712:	88da      	ldrh	r2, [r3, #6]
 8005714:	687b      	ldr	r3, [r7, #4]
 8005716:	891b      	ldrh	r3, [r3, #8]
 8005718:	429a      	cmp	r2, r3
 800571a:	bf0c      	ite	eq
 800571c:	2301      	moveq	r3, #1
 800571e:	2300      	movne	r3, #0
 8005720:	b2db      	uxtb	r3, r3
}
 8005722:	4618      	mov	r0, r3
 8005724:	370c      	adds	r7, #12
 8005726:	46bd      	mov	sp, r7
 8005728:	f85d 7b04 	ldr.w	r7, [sp], #4
 800572c:	4770      	bx	lr

0800572e <bufFlush>:
 * @retval None
 */
void
bufFlush(
    buffqueue_p pQueue
) {
 800572e:	b580      	push	{r7, lr}
 8005730:	b082      	sub	sp, #8
 8005732:	af00      	add	r7, sp, #0
 8005734:	6078      	str	r0, [r7, #4]
    pQueue->wHeadIndex = 0;
 8005736:	687b      	ldr	r3, [r7, #4]
 8005738:	2200      	movs	r2, #0
 800573a:	80da      	strh	r2, [r3, #6]
    pQueue->wTailIndex = 0;
 800573c:	687b      	ldr	r3, [r7, #4]
 800573e:	2200      	movs	r2, #0
 8005740:	811a      	strh	r2, [r3, #8]
    pQueue->wCountEle = 0;
 8005742:	687b      	ldr	r3, [r7, #4]
 8005744:	2200      	movs	r2, #0
 8005746:	805a      	strh	r2, [r3, #2]
    
    memsetl(pQueue->pData, 0, pQueue->wSize);
 8005748:	687b      	ldr	r3, [r7, #4]
 800574a:	68d8      	ldr	r0, [r3, #12]
 800574c:	687b      	ldr	r3, [r7, #4]
 800574e:	881b      	ldrh	r3, [r3, #0]
 8005750:	461a      	mov	r2, r3
 8005752:	2100      	movs	r1, #0
 8005754:	f000 f899 	bl	800588a <memsetl>
}
 8005758:	bf00      	nop
 800575a:	3708      	adds	r7, #8
 800575c:	46bd      	mov	sp, r7
 800575e:	bd80      	pop	{r7, pc}

08005760 <bufEnDat>:
 */
uint8_t
bufEnDat(
    buffqueue_p pQueue,
	uint8_t *pReceiverData
) {
 8005760:	b580      	push	{r7, lr}
 8005762:	b084      	sub	sp, #16
 8005764:	af00      	add	r7, sp, #0
 8005766:	6078      	str	r0, [r7, #4]
 8005768:	6039      	str	r1, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 800576a:	b672      	cpsid	i
}
 800576c:	bf00      	nop
	__disable_irq();
    
    /* Place data in buffer */
    for (uint8_t i = 0; i < pQueue->byItemSize; i++) {
 800576e:	2300      	movs	r3, #0
 8005770:	73fb      	strb	r3, [r7, #15]
 8005772:	e021      	b.n	80057b8 <bufEnDat+0x58>
        pQueue->pData[pQueue->wHeadIndex] = pReceiverData[i];
 8005774:	7bfb      	ldrb	r3, [r7, #15]
 8005776:	683a      	ldr	r2, [r7, #0]
 8005778:	441a      	add	r2, r3
 800577a:	687b      	ldr	r3, [r7, #4]
 800577c:	68db      	ldr	r3, [r3, #12]
 800577e:	6879      	ldr	r1, [r7, #4]
 8005780:	88c9      	ldrh	r1, [r1, #6]
 8005782:	440b      	add	r3, r1
 8005784:	7812      	ldrb	r2, [r2, #0]
 8005786:	701a      	strb	r2, [r3, #0]
        pQueue->wHeadIndex = ((pQueue->wHeadIndex + 1)  & (pQueue->wSize - 1));
 8005788:	687b      	ldr	r3, [r7, #4]
 800578a:	88db      	ldrh	r3, [r3, #6]
 800578c:	3301      	adds	r3, #1
 800578e:	b29b      	uxth	r3, r3
 8005790:	b21a      	sxth	r2, r3
 8005792:	687b      	ldr	r3, [r7, #4]
 8005794:	881b      	ldrh	r3, [r3, #0]
 8005796:	3b01      	subs	r3, #1
 8005798:	b29b      	uxth	r3, r3
 800579a:	b21b      	sxth	r3, r3
 800579c:	4013      	ands	r3, r2
 800579e:	b21b      	sxth	r3, r3
 80057a0:	b29a      	uxth	r2, r3
 80057a2:	687b      	ldr	r3, [r7, #4]
 80057a4:	80da      	strh	r2, [r3, #6]
        pQueue->wCountEle++;
 80057a6:	687b      	ldr	r3, [r7, #4]
 80057a8:	885b      	ldrh	r3, [r3, #2]
 80057aa:	3301      	adds	r3, #1
 80057ac:	b29a      	uxth	r2, r3
 80057ae:	687b      	ldr	r3, [r7, #4]
 80057b0:	805a      	strh	r2, [r3, #2]
    for (uint8_t i = 0; i < pQueue->byItemSize; i++) {
 80057b2:	7bfb      	ldrb	r3, [r7, #15]
 80057b4:	3301      	adds	r3, #1
 80057b6:	73fb      	strb	r3, [r7, #15]
 80057b8:	687b      	ldr	r3, [r7, #4]
 80057ba:	791b      	ldrb	r3, [r3, #4]
 80057bc:	7bfa      	ldrb	r2, [r7, #15]
 80057be:	429a      	cmp	r2, r3
 80057c0:	d3d8      	bcc.n	8005774 <bufEnDat+0x14>
    }
    
    if (bufIsFull(pQueue)) {
 80057c2:	6878      	ldr	r0, [r7, #4]
 80057c4:	f7ff ff8d 	bl	80056e2 <bufIsFull>
 80057c8:	4603      	mov	r3, r0
 80057ca:	2b00      	cmp	r3, #0
 80057cc:	d011      	beq.n	80057f2 <bufEnDat+0x92>
        /* Is going to overwrite the oldest byte */
        /* Increase tail index */
        pQueue->wTailIndex = (pQueue->wTailIndex + pQueue->byItemSize) & (pQueue->wSize - 1);
 80057ce:	687b      	ldr	r3, [r7, #4]
 80057d0:	891a      	ldrh	r2, [r3, #8]
 80057d2:	687b      	ldr	r3, [r7, #4]
 80057d4:	791b      	ldrb	r3, [r3, #4]
 80057d6:	b29b      	uxth	r3, r3
 80057d8:	4413      	add	r3, r2
 80057da:	b29b      	uxth	r3, r3
 80057dc:	b21a      	sxth	r2, r3
 80057de:	687b      	ldr	r3, [r7, #4]
 80057e0:	881b      	ldrh	r3, [r3, #0]
 80057e2:	3b01      	subs	r3, #1
 80057e4:	b29b      	uxth	r3, r3
 80057e6:	b21b      	sxth	r3, r3
 80057e8:	4013      	ands	r3, r2
 80057ea:	b21b      	sxth	r3, r3
 80057ec:	b29a      	uxth	r2, r3
 80057ee:	687b      	ldr	r3, [r7, #4]
 80057f0:	811a      	strh	r2, [r3, #8]
  __ASM volatile ("cpsie i" : : : "memory");
 80057f2:	b662      	cpsie	i
}
 80057f4:	bf00      	nop
    }
    
    __enable_irq();
    return ERR_OK;
 80057f6:	2300      	movs	r3, #0
}
 80057f8:	4618      	mov	r0, r3
 80057fa:	3710      	adds	r7, #16
 80057fc:	46bd      	mov	sp, r7
 80057fe:	bd80      	pop	{r7, pc}

08005800 <bufDeDat>:
 */
uint8_t
bufDeDat(
    buffqueue_p pQueue,
	uint8_t *pBuffer
) {
 8005800:	b580      	push	{r7, lr}
 8005802:	b084      	sub	sp, #16
 8005804:	af00      	add	r7, sp, #0
 8005806:	6078      	str	r0, [r7, #4]
 8005808:	6039      	str	r1, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 800580a:	b672      	cpsid	i
}
 800580c:	bf00      	nop
	__disable_irq();
    
    if (bufIsEmpty(pQueue)) {
 800580e:	6878      	ldr	r0, [r7, #4]
 8005810:	f7ff ff7a 	bl	8005708 <bufIsEmpty>
 8005814:	4603      	mov	r3, r0
 8005816:	2b00      	cmp	r3, #0
 8005818:	d006      	beq.n	8005828 <bufDeDat+0x28>
        /* No items */
        pQueue->wCountEle = 0;
 800581a:	687b      	ldr	r3, [r7, #4]
 800581c:	2200      	movs	r2, #0
 800581e:	805a      	strh	r2, [r3, #2]
  __ASM volatile ("cpsie i" : : : "memory");
 8005820:	b662      	cpsie	i
}
 8005822:	bf00      	nop
        __enable_irq();
        return ERR_BUF_EMPTY;
 8005824:	2302      	movs	r3, #2
 8005826:	e02c      	b.n	8005882 <bufDeDat+0x82>
    }
    
    for (uint8_t i = 0; i < pQueue->byItemSize; i++) {
 8005828:	2300      	movs	r3, #0
 800582a:	73fb      	strb	r3, [r7, #15]
 800582c:	e021      	b.n	8005872 <bufDeDat+0x72>
        pBuffer[i] = pQueue->pData[pQueue->wTailIndex];
 800582e:	687b      	ldr	r3, [r7, #4]
 8005830:	68db      	ldr	r3, [r3, #12]
 8005832:	687a      	ldr	r2, [r7, #4]
 8005834:	8912      	ldrh	r2, [r2, #8]
 8005836:	441a      	add	r2, r3
 8005838:	7bfb      	ldrb	r3, [r7, #15]
 800583a:	6839      	ldr	r1, [r7, #0]
 800583c:	440b      	add	r3, r1
 800583e:	7812      	ldrb	r2, [r2, #0]
 8005840:	701a      	strb	r2, [r3, #0]
        pQueue->wTailIndex = ((pQueue->wTailIndex + 1) & (pQueue->wSize - 1));
 8005842:	687b      	ldr	r3, [r7, #4]
 8005844:	891b      	ldrh	r3, [r3, #8]
 8005846:	3301      	adds	r3, #1
 8005848:	b29b      	uxth	r3, r3
 800584a:	b21a      	sxth	r2, r3
 800584c:	687b      	ldr	r3, [r7, #4]
 800584e:	881b      	ldrh	r3, [r3, #0]
 8005850:	3b01      	subs	r3, #1
 8005852:	b29b      	uxth	r3, r3
 8005854:	b21b      	sxth	r3, r3
 8005856:	4013      	ands	r3, r2
 8005858:	b21b      	sxth	r3, r3
 800585a:	b29a      	uxth	r2, r3
 800585c:	687b      	ldr	r3, [r7, #4]
 800585e:	811a      	strh	r2, [r3, #8]
        pQueue->wCountEle--;
 8005860:	687b      	ldr	r3, [r7, #4]
 8005862:	885b      	ldrh	r3, [r3, #2]
 8005864:	3b01      	subs	r3, #1
 8005866:	b29a      	uxth	r2, r3
 8005868:	687b      	ldr	r3, [r7, #4]
 800586a:	805a      	strh	r2, [r3, #2]
    for (uint8_t i = 0; i < pQueue->byItemSize; i++) {
 800586c:	7bfb      	ldrb	r3, [r7, #15]
 800586e:	3301      	adds	r3, #1
 8005870:	73fb      	strb	r3, [r7, #15]
 8005872:	687b      	ldr	r3, [r7, #4]
 8005874:	791b      	ldrb	r3, [r3, #4]
 8005876:	7bfa      	ldrb	r2, [r7, #15]
 8005878:	429a      	cmp	r2, r3
 800587a:	d3d8      	bcc.n	800582e <bufDeDat+0x2e>
  __ASM volatile ("cpsie i" : : : "memory");
 800587c:	b662      	cpsie	i
}
 800587e:	bf00      	nop
    }
    
    __enable_irq();
    return ERR_OK;
 8005880:	2300      	movs	r3, #0
}
 8005882:	4618      	mov	r0, r3
 8005884:	3710      	adds	r7, #16
 8005886:	46bd      	mov	sp, r7
 8005888:	bd80      	pop	{r7, pc}

0800588a <memsetl>:
void
memsetl(
	uint8_t *dst,
	uint8_t value,
	uint16_t size
) {
 800588a:	b480      	push	{r7}
 800588c:	b083      	sub	sp, #12
 800588e:	af00      	add	r7, sp, #0
 8005890:	6078      	str	r0, [r7, #4]
 8005892:	460b      	mov	r3, r1
 8005894:	70fb      	strb	r3, [r7, #3]
 8005896:	4613      	mov	r3, r2
 8005898:	803b      	strh	r3, [r7, #0]
    while (size--) {
 800589a:	e004      	b.n	80058a6 <memsetl+0x1c>
        *dst++ = value;
 800589c:	687b      	ldr	r3, [r7, #4]
 800589e:	1c5a      	adds	r2, r3, #1
 80058a0:	607a      	str	r2, [r7, #4]
 80058a2:	78fa      	ldrb	r2, [r7, #3]
 80058a4:	701a      	strb	r2, [r3, #0]
    while (size--) {
 80058a6:	883b      	ldrh	r3, [r7, #0]
 80058a8:	1e5a      	subs	r2, r3, #1
 80058aa:	803a      	strh	r2, [r7, #0]
 80058ac:	2b00      	cmp	r3, #0
 80058ae:	d1f5      	bne.n	800589c <memsetl+0x12>
    }    
}
 80058b0:	bf00      	nop
 80058b2:	bf00      	nop
 80058b4:	370c      	adds	r7, #12
 80058b6:	46bd      	mov	sp, r7
 80058b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80058bc:	4770      	bx	lr
	...

080058c0 <AppInitCommon>:
    }
    return dwTimeTotal;
}

// Hàm khởi tạo ứng dụng
static void AppInitCommon(void) {
 80058c0:	b580      	push	{r7, lr}
 80058c2:	af00      	add	r7, sp, #0
    SystemCoreClockUpdate();
 80058c4:	f7fa fd12 	bl	80002ec <SystemCoreClockUpdate>
    TimerInit();
 80058c8:	f7fc fd04 	bl	80022d4 <TimerInit>
    EventSchedulerInit(AppStateManager);
 80058cc:	4811      	ldr	r0, [pc, #68]	; (8005914 <AppInitCommon+0x54>)
 80058ce:	f7fc fc67 	bl	80021a0 <EventSchedulerInit>
    EventButton_Init();
 80058d2:	f7fb feb3 	bl	800163c <EventButton_Init>
    LedControl_Init();
 80058d6:	f7fc f947 	bl	8001b68 <LedControl_Init>
    FLASH_Init();
 80058da:	f7fc f847 	bl	800196c <FLASH_Init>
    parameteInit();
 80058de:	f000 f9cb 	bl	8005c78 <parameteInit>

    Ucglib4WireSWSPI_begin(&ucg, UCG_FONT_MODE_SOLID);
 80058e2:	2100      	movs	r1, #0
 80058e4:	480c      	ldr	r0, [pc, #48]	; (8005918 <AppInitCommon+0x58>)
 80058e6:	f7fd f877 	bl	80029d8 <Ucglib4WireSWSPI_begin>
    ucg_ClearScreen(&ucg);
 80058ea:	480b      	ldr	r0, [pc, #44]	; (8005918 <AppInitCommon+0x58>)
 80058ec:	f7fd f8bc 	bl	8002a68 <ucg_ClearScreen>
    ucg_SetRotate180(&ucg);
 80058f0:	4809      	ldr	r0, [pc, #36]	; (8005918 <AppInitCommon+0x58>)
 80058f2:	f7ff feb5 	bl	8005660 <ucg_SetRotate180>
    time_initial = GetMilSecTick();
 80058f6:	f7fc fddd 	bl	80024b4 <GetMilSecTick>
 80058fa:	4603      	mov	r3, r0
 80058fc:	b2da      	uxtb	r2, r3
 80058fe:	4b07      	ldr	r3, [pc, #28]	; (800591c <AppInitCommon+0x5c>)
 8005900:	701a      	strb	r2, [r3, #0]
    i = currentFontIndex = 0;
 8005902:	4b07      	ldr	r3, [pc, #28]	; (8005920 <AppInitCommon+0x60>)
 8005904:	2200      	movs	r2, #0
 8005906:	701a      	strb	r2, [r3, #0]
 8005908:	4b05      	ldr	r3, [pc, #20]	; (8005920 <AppInitCommon+0x60>)
 800590a:	781a      	ldrb	r2, [r3, #0]
 800590c:	4b05      	ldr	r3, [pc, #20]	; (8005924 <AppInitCommon+0x64>)
 800590e:	701a      	strb	r2, [r3, #0]
}
 8005910:	bf00      	nop
 8005912:	bd80      	pop	{r7, pc}
 8005914:	080059ad 	.word	0x080059ad
 8005918:	200014f8 	.word	0x200014f8
 800591c:	200014e7 	.word	0x200014e7
 8005920:	20000076 	.word	0x20000076
 8005924:	200014eb 	.word	0x200014eb

08005928 <LoadConfiguration>:

// Hàm load cấu hình
void LoadConfiguration(void) {
 8005928:	b580      	push	{r7, lr}
 800592a:	b082      	sub	sp, #8
 800592c:	af02      	add	r7, sp, #8
    ucg_SetColor(&ucg, 0, 225, 225, 225);
 800592e:	23e1      	movs	r3, #225	; 0xe1
 8005930:	9300      	str	r3, [sp, #0]
 8005932:	23e1      	movs	r3, #225	; 0xe1
 8005934:	22e1      	movs	r2, #225	; 0xe1
 8005936:	2100      	movs	r1, #0
 8005938:	4816      	ldr	r0, [pc, #88]	; (8005994 <LoadConfiguration+0x6c>)
 800593a:	f7ff fa00 	bl	8004d3e <ucg_SetColor>
    ucg_SetColor(&ucg, 1, 0, 0, 0);
 800593e:	2300      	movs	r3, #0
 8005940:	9300      	str	r3, [sp, #0]
 8005942:	2300      	movs	r3, #0
 8005944:	2200      	movs	r2, #0
 8005946:	2101      	movs	r1, #1
 8005948:	4812      	ldr	r0, [pc, #72]	; (8005994 <LoadConfiguration+0x6c>)
 800594a:	f7ff f9f8 	bl	8004d3e <ucg_SetColor>
    ucg_SetFont(&ucg, Font[currentFontIndex]);
 800594e:	4b12      	ldr	r3, [pc, #72]	; (8005998 <LoadConfiguration+0x70>)
 8005950:	781b      	ldrb	r3, [r3, #0]
 8005952:	461a      	mov	r2, r3
 8005954:	4b11      	ldr	r3, [pc, #68]	; (800599c <LoadConfiguration+0x74>)
 8005956:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800595a:	4619      	mov	r1, r3
 800595c:	480d      	ldr	r0, [pc, #52]	; (8005994 <LoadConfiguration+0x6c>)
 800595e:	f7ff f835 	bl	80049cc <ucg_SetFont>

    ucg_DrawString(&ucg, 0, 50, 0, "Hello ");
 8005962:	4b0f      	ldr	r3, [pc, #60]	; (80059a0 <LoadConfiguration+0x78>)
 8005964:	9300      	str	r3, [sp, #0]
 8005966:	2300      	movs	r3, #0
 8005968:	2232      	movs	r2, #50	; 0x32
 800596a:	2100      	movs	r1, #0
 800596c:	4809      	ldr	r0, [pc, #36]	; (8005994 <LoadConfiguration+0x6c>)
 800596e:	f7fe ff69 	bl	8004844 <ucg_DrawString>
    ucg_DrawString(&ucg, 0, 70, 0, "IOT Programming");
 8005972:	4b0c      	ldr	r3, [pc, #48]	; (80059a4 <LoadConfiguration+0x7c>)
 8005974:	9300      	str	r3, [sp, #0]
 8005976:	2300      	movs	r3, #0
 8005978:	2246      	movs	r2, #70	; 0x46
 800597a:	2100      	movs	r1, #0
 800597c:	4805      	ldr	r0, [pc, #20]	; (8005994 <LoadConfiguration+0x6c>)
 800597e:	f7fe ff61 	bl	8004844 <ucg_DrawString>
    needReinitialize = 1;
 8005982:	4b09      	ldr	r3, [pc, #36]	; (80059a8 <LoadConfiguration+0x80>)
 8005984:	2201      	movs	r2, #1
 8005986:	701a      	strb	r2, [r3, #0]
    setup();
 8005988:	f000 f9fe 	bl	8005d88 <setup>
}
 800598c:	bf00      	nop
 800598e:	46bd      	mov	sp, r7
 8005990:	bd80      	pop	{r7, pc}
 8005992:	bf00      	nop
 8005994:	200014f8 	.word	0x200014f8
 8005998:	20000076 	.word	0x20000076
 800599c:	20000078 	.word	0x20000078
 80059a0:	08006928 	.word	0x08006928
 80059a4:	08006930 	.word	0x08006930
 80059a8:	200014ec 	.word	0x200014ec

080059ac <AppStateManager>:
    status = false;  // Đánh dấu rằng font đã được cài đặt
    currentFontIndex = fontIndex; // Cập nhật chỉ số font hiện tại
}

// Quản lý trạng thái ứng dụng
void AppStateManager(uint8_t event) {
 80059ac:	b580      	push	{r7, lr}
 80059ae:	b082      	sub	sp, #8
 80059b0:	af00      	add	r7, sp, #0
 80059b2:	4603      	mov	r3, r0
 80059b4:	71fb      	strb	r3, [r7, #7]
    switch (GetStateApp()) {
 80059b6:	f000 f843 	bl	8005a40 <GetStateApp>
 80059ba:	4603      	mov	r3, r0
 80059bc:	2b02      	cmp	r3, #2
 80059be:	d021      	beq.n	8005a04 <AppStateManager+0x58>
 80059c0:	2b02      	cmp	r3, #2
 80059c2:	dc21      	bgt.n	8005a08 <AppStateManager+0x5c>
 80059c4:	2b00      	cmp	r3, #0
 80059c6:	d002      	beq.n	80059ce <AppStateManager+0x22>
 80059c8:	2b01      	cmp	r3, #1
 80059ca:	d009      	beq.n	80059e0 <AppStateManager+0x34>
            }
            break;
        case STATE_APP_RESET:
            break;
        default:
            break;
 80059cc:	e01c      	b.n	8005a08 <AppStateManager+0x5c>
            if (event == EVENT_APP_INIT) {
 80059ce:	79fb      	ldrb	r3, [r7, #7]
 80059d0:	2b01      	cmp	r3, #1
 80059d2:	d11b      	bne.n	8005a0c <AppStateManager+0x60>
                LoadConfiguration();
 80059d4:	f7ff ffa8 	bl	8005928 <LoadConfiguration>
                SetStateApp(STATE_APP_IDLE);
 80059d8:	2001      	movs	r0, #1
 80059da:	f000 f821 	bl	8005a20 <SetStateApp>
            break;
 80059de:	e015      	b.n	8005a0c <AppStateManager+0x60>
            DeviceStateMachine(event);
 80059e0:	79fb      	ldrb	r3, [r7, #7]
 80059e2:	4618      	mov	r0, r3
 80059e4:	f000 f838 	bl	8005a58 <DeviceStateMachine>
            if (needReinitialize == 1) {
 80059e8:	4b0c      	ldr	r3, [pc, #48]	; (8005a1c <AppStateManager+0x70>)
 80059ea:	781b      	ldrb	r3, [r3, #0]
 80059ec:	2b01      	cmp	r3, #1
 80059ee:	d10f      	bne.n	8005a10 <AppStateManager+0x64>
                SetStateApp(STATE_APP_STARTUP);
 80059f0:	2000      	movs	r0, #0
 80059f2:	f000 f815 	bl	8005a20 <SetStateApp>
                EventSchedulerAdd(EVENT_APP_INIT);
 80059f6:	2001      	movs	r0, #1
 80059f8:	f7fc fbee 	bl	80021d8 <EventSchedulerAdd>
                needReinitialize = 0;
 80059fc:	4b07      	ldr	r3, [pc, #28]	; (8005a1c <AppStateManager+0x70>)
 80059fe:	2200      	movs	r2, #0
 8005a00:	701a      	strb	r2, [r3, #0]
            break;
 8005a02:	e005      	b.n	8005a10 <AppStateManager+0x64>
            break;
 8005a04:	bf00      	nop
 8005a06:	e004      	b.n	8005a12 <AppStateManager+0x66>
            break;
 8005a08:	bf00      	nop
 8005a0a:	e002      	b.n	8005a12 <AppStateManager+0x66>
            break;
 8005a0c:	bf00      	nop
 8005a0e:	e000      	b.n	8005a12 <AppStateManager+0x66>
            break;
 8005a10:	bf00      	nop
    }
}
 8005a12:	bf00      	nop
 8005a14:	3708      	adds	r7, #8
 8005a16:	46bd      	mov	sp, r7
 8005a18:	bd80      	pop	{r7, pc}
 8005a1a:	bf00      	nop
 8005a1c:	200014ec 	.word	0x200014ec

08005a20 <SetStateApp>:

// Hàm đặt trạng thái ứng dụng
static void SetStateApp(state_app_t state) {
 8005a20:	b480      	push	{r7}
 8005a22:	b083      	sub	sp, #12
 8005a24:	af00      	add	r7, sp, #0
 8005a26:	4603      	mov	r3, r0
 8005a28:	71fb      	strb	r3, [r7, #7]
    eCurrentState = state;
 8005a2a:	4a04      	ldr	r2, [pc, #16]	; (8005a3c <SetStateApp+0x1c>)
 8005a2c:	79fb      	ldrb	r3, [r7, #7]
 8005a2e:	7013      	strb	r3, [r2, #0]
}
 8005a30:	bf00      	nop
 8005a32:	370c      	adds	r7, #12
 8005a34:	46bd      	mov	sp, r7
 8005a36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a3a:	4770      	bx	lr
 8005a3c:	200014e4 	.word	0x200014e4

08005a40 <GetStateApp>:

// Hàm lấy trạng thái ứng dụng
static state_app_t GetStateApp(void) {
 8005a40:	b480      	push	{r7}
 8005a42:	af00      	add	r7, sp, #0
    return eCurrentState;
 8005a44:	4b03      	ldr	r3, [pc, #12]	; (8005a54 <GetStateApp+0x14>)
 8005a46:	781b      	ldrb	r3, [r3, #0]
}
 8005a48:	4618      	mov	r0, r3
 8005a4a:	46bd      	mov	sp, r7
 8005a4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005a50:	4770      	bx	lr
 8005a52:	bf00      	nop
 8005a54:	200014e4 	.word	0x200014e4

08005a58 <DeviceStateMachine>:

// Quản lý trạng thái của thiết bị
void DeviceStateMachine(uint8_t event) {
 8005a58:	b580      	push	{r7, lr}
 8005a5a:	b084      	sub	sp, #16
 8005a5c:	af02      	add	r7, sp, #8
 8005a5e:	4603      	mov	r3, r0
 8005a60:	71fb      	strb	r3, [r7, #7]
    switch (event) {
 8005a62:	79fb      	ldrb	r3, [r7, #7]
 8005a64:	2b05      	cmp	r3, #5
 8005a66:	f000 809d 	beq.w	8005ba4 <DeviceStateMachine+0x14c>
 8005a6a:	2b05      	cmp	r3, #5
 8005a6c:	f300 80d1 	bgt.w	8005c12 <DeviceStateMachine+0x1ba>
 8005a70:	2b01      	cmp	r3, #1
 8005a72:	d060      	beq.n	8005b36 <DeviceStateMachine+0xde>
 8005a74:	2b03      	cmp	r3, #3
 8005a76:	f040 80cc 	bne.w	8005c12 <DeviceStateMachine+0x1ba>
        case EVENT_OF_BUTTON_3_PRESS_LOGIC:
            if (buttoncount == 0) {
 8005a7a:	4b6b      	ldr	r3, [pc, #428]	; (8005c28 <DeviceStateMachine+0x1d0>)
 8005a7c:	781b      	ldrb	r3, [r3, #0]
 8005a7e:	2b00      	cmp	r3, #0
 8005a80:	d124      	bne.n	8005acc <DeviceStateMachine+0x74>
                ucg_SetColor(&ucg, 0, 0, 0, 225);
 8005a82:	23e1      	movs	r3, #225	; 0xe1
 8005a84:	9300      	str	r3, [sp, #0]
 8005a86:	2300      	movs	r3, #0
 8005a88:	2200      	movs	r2, #0
 8005a8a:	2100      	movs	r1, #0
 8005a8c:	4867      	ldr	r0, [pc, #412]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005a8e:	f7ff f956 	bl	8004d3e <ucg_SetColor>
                ucg_SetColor(&ucg, 1, 0, 0, 0);
 8005a92:	2300      	movs	r3, #0
 8005a94:	9300      	str	r3, [sp, #0]
 8005a96:	2300      	movs	r3, #0
 8005a98:	2200      	movs	r2, #0
 8005a9a:	2101      	movs	r1, #1
 8005a9c:	4863      	ldr	r0, [pc, #396]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005a9e:	f7ff f94e 	bl	8004d3e <ucg_SetColor>
                BuzzerControl_SetMelody(pbeep);
 8005aa2:	4863      	ldr	r0, [pc, #396]	; (8005c30 <DeviceStateMachine+0x1d8>)
 8005aa4:	f7fb ff16 	bl	80018d4 <BuzzerControl_SetMelody>
                buttoncount = 1;
 8005aa8:	4b5f      	ldr	r3, [pc, #380]	; (8005c28 <DeviceStateMachine+0x1d0>)
 8005aaa:	2201      	movs	r2, #1
 8005aac:	701a      	strb	r2, [r3, #0]
                Mode = 1;
 8005aae:	4b61      	ldr	r3, [pc, #388]	; (8005c34 <DeviceStateMachine+0x1dc>)
 8005ab0:	2201      	movs	r2, #1
 8005ab2:	701a      	strb	r2, [r3, #0]
                LedControl_BlinkStart(LED_ALL_ID, BLINK_RED, 4, 200, LED_COLOR_BLACK);
 8005ab4:	2304      	movs	r3, #4
 8005ab6:	9300      	str	r3, [sp, #0]
 8005ab8:	23c8      	movs	r3, #200	; 0xc8
 8005aba:	2204      	movs	r2, #4
 8005abc:	2100      	movs	r1, #0
 8005abe:	2003      	movs	r0, #3
 8005ac0:	f7fc fa54 	bl	8001f6c <LedControl_BlinkStart>
                BuzzerControl_SetMelody(pbeep);
 8005ac4:	485a      	ldr	r0, [pc, #360]	; (8005c30 <DeviceStateMachine+0x1d8>)
 8005ac6:	f7fb ff05 	bl	80018d4 <BuzzerControl_SetMelody>
                // Lưu font hiện tại vào flash khi thoát khỏi chế độ đổi font
                if (Mode == 0) {
                    SaveFontToFlash(currentFontIndex);
                }
            }
            break;
 8005aca:	e0a4      	b.n	8005c16 <DeviceStateMachine+0x1be>
                ucg_SetColor(&ucg, 0, 225, 225, 225); // Chuyển màu chữ về trắng
 8005acc:	23e1      	movs	r3, #225	; 0xe1
 8005ace:	9300      	str	r3, [sp, #0]
 8005ad0:	23e1      	movs	r3, #225	; 0xe1
 8005ad2:	22e1      	movs	r2, #225	; 0xe1
 8005ad4:	2100      	movs	r1, #0
 8005ad6:	4855      	ldr	r0, [pc, #340]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005ad8:	f7ff f931 	bl	8004d3e <ucg_SetColor>
                ucg_SetColor(&ucg, 1, 0, 0, 0);
 8005adc:	2300      	movs	r3, #0
 8005ade:	9300      	str	r3, [sp, #0]
 8005ae0:	2300      	movs	r3, #0
 8005ae2:	2200      	movs	r2, #0
 8005ae4:	2101      	movs	r1, #1
 8005ae6:	4851      	ldr	r0, [pc, #324]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005ae8:	f7ff f929 	bl	8004d3e <ucg_SetColor>
                BuzzerControl_SetMelody(pbeep);
 8005aec:	4850      	ldr	r0, [pc, #320]	; (8005c30 <DeviceStateMachine+0x1d8>)
 8005aee:	f7fb fef1 	bl	80018d4 <BuzzerControl_SetMelody>
                buttoncount = 0;
 8005af2:	4b4d      	ldr	r3, [pc, #308]	; (8005c28 <DeviceStateMachine+0x1d0>)
 8005af4:	2200      	movs	r2, #0
 8005af6:	701a      	strb	r2, [r3, #0]
                Mode = 0; // Thoát chế độ đổi font
 8005af8:	4b4e      	ldr	r3, [pc, #312]	; (8005c34 <DeviceStateMachine+0x1dc>)
 8005afa:	2200      	movs	r2, #0
 8005afc:	701a      	strb	r2, [r3, #0]
                LedControl_BlinkStart(LED_ALL_ID, BLINK_GREEN, 4, 200, LED_COLOR_BLACK);
 8005afe:	2304      	movs	r3, #4
 8005b00:	9300      	str	r3, [sp, #0]
 8005b02:	23c8      	movs	r3, #200	; 0xc8
 8005b04:	2204      	movs	r2, #4
 8005b06:	2102      	movs	r1, #2
 8005b08:	2003      	movs	r0, #3
 8005b0a:	f7fc fa2f 	bl	8001f6c <LedControl_BlinkStart>
                BuzzerControl_SetMelody(p2beep);
 8005b0e:	484a      	ldr	r0, [pc, #296]	; (8005c38 <DeviceStateMachine+0x1e0>)
 8005b10:	f7fb fee0 	bl	80018d4 <BuzzerControl_SetMelody>
                status = true;
 8005b14:	4b49      	ldr	r3, [pc, #292]	; (8005c3c <DeviceStateMachine+0x1e4>)
 8005b16:	2201      	movs	r2, #1
 8005b18:	701a      	strb	r2, [r3, #0]
                currentFontIndex = i; // Cập nhật giá trị của biến `currentFontIndex`
 8005b1a:	4b49      	ldr	r3, [pc, #292]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005b1c:	781a      	ldrb	r2, [r3, #0]
 8005b1e:	4b49      	ldr	r3, [pc, #292]	; (8005c44 <DeviceStateMachine+0x1ec>)
 8005b20:	701a      	strb	r2, [r3, #0]
                if (Mode == 0) {
 8005b22:	4b44      	ldr	r3, [pc, #272]	; (8005c34 <DeviceStateMachine+0x1dc>)
 8005b24:	781b      	ldrb	r3, [r3, #0]
 8005b26:	2b00      	cmp	r3, #0
 8005b28:	d175      	bne.n	8005c16 <DeviceStateMachine+0x1be>
                    SaveFontToFlash(currentFontIndex);
 8005b2a:	4b46      	ldr	r3, [pc, #280]	; (8005c44 <DeviceStateMachine+0x1ec>)
 8005b2c:	781b      	ldrb	r3, [r3, #0]
 8005b2e:	4618      	mov	r0, r3
 8005b30:	f000 f88c 	bl	8005c4c <SaveFontToFlash>
            break;
 8005b34:	e06f      	b.n	8005c16 <DeviceStateMachine+0x1be>

        case EVENT_OF_BUTTON_1_PRESS_LOGIC:
            if (Mode == 1 && i <= 18) {
 8005b36:	4b3f      	ldr	r3, [pc, #252]	; (8005c34 <DeviceStateMachine+0x1dc>)
 8005b38:	781b      	ldrb	r3, [r3, #0]
 8005b3a:	2b01      	cmp	r3, #1
 8005b3c:	d16d      	bne.n	8005c1a <DeviceStateMachine+0x1c2>
 8005b3e:	4b40      	ldr	r3, [pc, #256]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005b40:	781b      	ldrb	r3, [r3, #0]
 8005b42:	2b12      	cmp	r3, #18
 8005b44:	d869      	bhi.n	8005c1a <DeviceStateMachine+0x1c2>
                i++;
 8005b46:	4b3e      	ldr	r3, [pc, #248]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005b48:	781b      	ldrb	r3, [r3, #0]
 8005b4a:	3301      	adds	r3, #1
 8005b4c:	b2da      	uxtb	r2, r3
 8005b4e:	4b3c      	ldr	r3, [pc, #240]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005b50:	701a      	strb	r2, [r3, #0]
                currentFontIndex = i;
 8005b52:	4b3b      	ldr	r3, [pc, #236]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005b54:	781a      	ldrb	r2, [r3, #0]
 8005b56:	4b3b      	ldr	r3, [pc, #236]	; (8005c44 <DeviceStateMachine+0x1ec>)
 8005b58:	701a      	strb	r2, [r3, #0]
                ucg_ClearScreen(&ucg);
 8005b5a:	4834      	ldr	r0, [pc, #208]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005b5c:	f7fc ff84 	bl	8002a68 <ucg_ClearScreen>
                ucg_SetColor(&ucg, 0, 0, 0, 225);
 8005b60:	23e1      	movs	r3, #225	; 0xe1
 8005b62:	9300      	str	r3, [sp, #0]
 8005b64:	2300      	movs	r3, #0
 8005b66:	2200      	movs	r2, #0
 8005b68:	2100      	movs	r1, #0
 8005b6a:	4830      	ldr	r0, [pc, #192]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005b6c:	f7ff f8e7 	bl	8004d3e <ucg_SetColor>
                ucg_SetFont(&ucg, Font[i]);
 8005b70:	4b33      	ldr	r3, [pc, #204]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005b72:	781b      	ldrb	r3, [r3, #0]
 8005b74:	461a      	mov	r2, r3
 8005b76:	4b34      	ldr	r3, [pc, #208]	; (8005c48 <DeviceStateMachine+0x1f0>)
 8005b78:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005b7c:	4619      	mov	r1, r3
 8005b7e:	482b      	ldr	r0, [pc, #172]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005b80:	f7fe ff24 	bl	80049cc <ucg_SetFont>
                buttoncount = 1;
 8005b84:	4b28      	ldr	r3, [pc, #160]	; (8005c28 <DeviceStateMachine+0x1d0>)
 8005b86:	2201      	movs	r2, #1
 8005b88:	701a      	strb	r2, [r3, #0]
                BuzzerControl_SetMelody(pbeep);
 8005b8a:	4829      	ldr	r0, [pc, #164]	; (8005c30 <DeviceStateMachine+0x1d8>)
 8005b8c:	f7fb fea2 	bl	80018d4 <BuzzerControl_SetMelody>

                // Lưu font hiện tại vào flash khi thoát khỏi chế độ đổi font
                if (Mode == 0) {
 8005b90:	4b28      	ldr	r3, [pc, #160]	; (8005c34 <DeviceStateMachine+0x1dc>)
 8005b92:	781b      	ldrb	r3, [r3, #0]
 8005b94:	2b00      	cmp	r3, #0
 8005b96:	d140      	bne.n	8005c1a <DeviceStateMachine+0x1c2>
                    SaveFontToFlash(currentFontIndex);
 8005b98:	4b2a      	ldr	r3, [pc, #168]	; (8005c44 <DeviceStateMachine+0x1ec>)
 8005b9a:	781b      	ldrb	r3, [r3, #0]
 8005b9c:	4618      	mov	r0, r3
 8005b9e:	f000 f855 	bl	8005c4c <SaveFontToFlash>
                }
            }
            break;
 8005ba2:	e03a      	b.n	8005c1a <DeviceStateMachine+0x1c2>

        case EVENT_OF_BUTTON_5_PRESS_LOGIC:
            if (Mode == 1 && i >= 1) {
 8005ba4:	4b23      	ldr	r3, [pc, #140]	; (8005c34 <DeviceStateMachine+0x1dc>)
 8005ba6:	781b      	ldrb	r3, [r3, #0]
 8005ba8:	2b01      	cmp	r3, #1
 8005baa:	d138      	bne.n	8005c1e <DeviceStateMachine+0x1c6>
 8005bac:	4b24      	ldr	r3, [pc, #144]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005bae:	781b      	ldrb	r3, [r3, #0]
 8005bb0:	2b00      	cmp	r3, #0
 8005bb2:	d034      	beq.n	8005c1e <DeviceStateMachine+0x1c6>
                i--;
 8005bb4:	4b22      	ldr	r3, [pc, #136]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005bb6:	781b      	ldrb	r3, [r3, #0]
 8005bb8:	3b01      	subs	r3, #1
 8005bba:	b2da      	uxtb	r2, r3
 8005bbc:	4b20      	ldr	r3, [pc, #128]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005bbe:	701a      	strb	r2, [r3, #0]
                currentFontIndex = i;
 8005bc0:	4b1f      	ldr	r3, [pc, #124]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005bc2:	781a      	ldrb	r2, [r3, #0]
 8005bc4:	4b1f      	ldr	r3, [pc, #124]	; (8005c44 <DeviceStateMachine+0x1ec>)
 8005bc6:	701a      	strb	r2, [r3, #0]
                ucg_ClearScreen(&ucg);
 8005bc8:	4818      	ldr	r0, [pc, #96]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005bca:	f7fc ff4d 	bl	8002a68 <ucg_ClearScreen>
                ucg_SetColor(&ucg, 0, 0, 0, 225);
 8005bce:	23e1      	movs	r3, #225	; 0xe1
 8005bd0:	9300      	str	r3, [sp, #0]
 8005bd2:	2300      	movs	r3, #0
 8005bd4:	2200      	movs	r2, #0
 8005bd6:	2100      	movs	r1, #0
 8005bd8:	4814      	ldr	r0, [pc, #80]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005bda:	f7ff f8b0 	bl	8004d3e <ucg_SetColor>
                ucg_SetFont(&ucg, Font[i]);
 8005bde:	4b18      	ldr	r3, [pc, #96]	; (8005c40 <DeviceStateMachine+0x1e8>)
 8005be0:	781b      	ldrb	r3, [r3, #0]
 8005be2:	461a      	mov	r2, r3
 8005be4:	4b18      	ldr	r3, [pc, #96]	; (8005c48 <DeviceStateMachine+0x1f0>)
 8005be6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8005bea:	4619      	mov	r1, r3
 8005bec:	480f      	ldr	r0, [pc, #60]	; (8005c2c <DeviceStateMachine+0x1d4>)
 8005bee:	f7fe feed 	bl	80049cc <ucg_SetFont>
                buttoncount = 1;
 8005bf2:	4b0d      	ldr	r3, [pc, #52]	; (8005c28 <DeviceStateMachine+0x1d0>)
 8005bf4:	2201      	movs	r2, #1
 8005bf6:	701a      	strb	r2, [r3, #0]
                BuzzerControl_SetMelody(pbeep);
 8005bf8:	480d      	ldr	r0, [pc, #52]	; (8005c30 <DeviceStateMachine+0x1d8>)
 8005bfa:	f7fb fe6b 	bl	80018d4 <BuzzerControl_SetMelody>

                // Lưu font hiện tại vào flash khi thoát khỏi chế độ đổi font
                if (Mode == 0) {
 8005bfe:	4b0d      	ldr	r3, [pc, #52]	; (8005c34 <DeviceStateMachine+0x1dc>)
 8005c00:	781b      	ldrb	r3, [r3, #0]
 8005c02:	2b00      	cmp	r3, #0
 8005c04:	d10b      	bne.n	8005c1e <DeviceStateMachine+0x1c6>
                    SaveFontToFlash(currentFontIndex);
 8005c06:	4b0f      	ldr	r3, [pc, #60]	; (8005c44 <DeviceStateMachine+0x1ec>)
 8005c08:	781b      	ldrb	r3, [r3, #0]
 8005c0a:	4618      	mov	r0, r3
 8005c0c:	f000 f81e 	bl	8005c4c <SaveFontToFlash>
                }
            }
            break;
 8005c10:	e005      	b.n	8005c1e <DeviceStateMachine+0x1c6>

        default:
            break;
 8005c12:	bf00      	nop
 8005c14:	e004      	b.n	8005c20 <DeviceStateMachine+0x1c8>
            break;
 8005c16:	bf00      	nop
 8005c18:	e002      	b.n	8005c20 <DeviceStateMachine+0x1c8>
            break;
 8005c1a:	bf00      	nop
 8005c1c:	e000      	b.n	8005c20 <DeviceStateMachine+0x1c8>
            break;
 8005c1e:	bf00      	nop
    }
}
 8005c20:	bf00      	nop
 8005c22:	3708      	adds	r7, #8
 8005c24:	46bd      	mov	sp, r7
 8005c26:	bd80      	pop	{r7, pc}
 8005c28:	200014e6 	.word	0x200014e6
 8005c2c:	200014f8 	.word	0x200014f8
 8005c30:	20000058 	.word	0x20000058
 8005c34:	200014ea 	.word	0x200014ea
 8005c38:	20000060 	.word	0x20000060
 8005c3c:	20000077 	.word	0x20000077
 8005c40:	200014eb 	.word	0x200014eb
 8005c44:	20000076 	.word	0x20000076
 8005c48:	20000078 	.word	0x20000078

08005c4c <SaveFontToFlash>:

// Hàm lưu font hiện tại vào flash
static void SaveFontToFlash(uint8_t byFont) {
 8005c4c:	b580      	push	{r7, lr}
 8005c4e:	b084      	sub	sp, #16
 8005c50:	af00      	add	r7, sp, #0
 8005c52:	4603      	mov	r3, r0
 8005c54:	71fb      	strb	r3, [r7, #7]
    p_UserData_t pReadWriteData;
    pReadWriteData = FLASH_GetUserData();
 8005c56:	f7fb fea7 	bl	80019a8 <FLASH_GetUserData>
 8005c5a:	60f8      	str	r0, [r7, #12]
    pReadWriteData->Font = byFont;
 8005c5c:	68fb      	ldr	r3, [r7, #12]
 8005c5e:	79fa      	ldrb	r2, [r7, #7]
 8005c60:	711a      	strb	r2, [r3, #4]
    pReadWriteData->Used = FLASH_USERDATA_VALID;
 8005c62:	68fb      	ldr	r3, [r7, #12]
 8005c64:	f04f 325a 	mov.w	r2, #1515870810	; 0x5a5a5a5a
 8005c68:	601a      	str	r2, [r3, #0]
    FLASH_RamToFlash();
 8005c6a:	f7fb fe97 	bl	800199c <FLASH_RamToFlash>
}
 8005c6e:	bf00      	nop
 8005c70:	3710      	adds	r7, #16
 8005c72:	46bd      	mov	sp, r7
 8005c74:	bd80      	pop	{r7, pc}
	...

08005c78 <parameteInit>:

// Hàm khởi tạo tham số
static void parameteInit() {
 8005c78:	b580      	push	{r7, lr}
 8005c7a:	af00      	add	r7, sp, #0
    g_pReadWriteData = FLASH_GetUserData();
 8005c7c:	f7fb fe94 	bl	80019a8 <FLASH_GetUserData>
 8005c80:	4603      	mov	r3, r0
 8005c82:	4a04      	ldr	r2, [pc, #16]	; (8005c94 <parameteInit+0x1c>)
 8005c84:	6013      	str	r3, [r2, #0]
    g_loadFont = g_pReadWriteData->Font;
 8005c86:	4b03      	ldr	r3, [pc, #12]	; (8005c94 <parameteInit+0x1c>)
 8005c88:	681b      	ldr	r3, [r3, #0]
 8005c8a:	791a      	ldrb	r2, [r3, #4]
 8005c8c:	4b02      	ldr	r3, [pc, #8]	; (8005c98 <parameteInit+0x20>)
 8005c8e:	701a      	strb	r2, [r3, #0]
}
 8005c90:	bf00      	nop
 8005c92:	bd80      	pop	{r7, pc}
 8005c94:	200014f0 	.word	0x200014f0
 8005c98:	200014f4 	.word	0x200014f4

08005c9c <Task_Screen_Update>:

// Hàm cập nhật màn hình
static void Task_Screen_Update(void) {
 8005c9c:	b580      	push	{r7, lr}
 8005c9e:	b082      	sub	sp, #8
 8005ca0:	af02      	add	r7, sp, #8
    if (reset == 0) {
 8005ca2:	4b11      	ldr	r3, [pc, #68]	; (8005ce8 <Task_Screen_Update+0x4c>)
 8005ca4:	781b      	ldrb	r3, [r3, #0]
 8005ca6:	2b00      	cmp	r3, #0
 8005ca8:	d105      	bne.n	8005cb6 <Task_Screen_Update+0x1a>
        ucg_ClearScreen(&ucg);
 8005caa:	4810      	ldr	r0, [pc, #64]	; (8005cec <Task_Screen_Update+0x50>)
 8005cac:	f7fc fedc 	bl	8002a68 <ucg_ClearScreen>
        reset = 1;
 8005cb0:	4b0d      	ldr	r3, [pc, #52]	; (8005ce8 <Task_Screen_Update+0x4c>)
 8005cb2:	2201      	movs	r2, #1
 8005cb4:	701a      	strb	r2, [r3, #0]
    }
    memset(src1, 0, sizeof(src1));
 8005cb6:	2232      	movs	r2, #50	; 0x32
 8005cb8:	2100      	movs	r1, #0
 8005cba:	480d      	ldr	r0, [pc, #52]	; (8005cf0 <Task_Screen_Update+0x54>)
 8005cbc:	f000 f990 	bl	8005fe0 <memset>
    sprintf(src1, "Font%3d             ", currentFontIndex + 1);
 8005cc0:	4b0c      	ldr	r3, [pc, #48]	; (8005cf4 <Task_Screen_Update+0x58>)
 8005cc2:	781b      	ldrb	r3, [r3, #0]
 8005cc4:	3301      	adds	r3, #1
 8005cc6:	461a      	mov	r2, r3
 8005cc8:	490b      	ldr	r1, [pc, #44]	; (8005cf8 <Task_Screen_Update+0x5c>)
 8005cca:	4809      	ldr	r0, [pc, #36]	; (8005cf0 <Task_Screen_Update+0x54>)
 8005ccc:	f000 f968 	bl	8005fa0 <siprintf>
    ucg_DrawString(&ucg, 40, 15, 0, src1);
 8005cd0:	4b07      	ldr	r3, [pc, #28]	; (8005cf0 <Task_Screen_Update+0x54>)
 8005cd2:	9300      	str	r3, [sp, #0]
 8005cd4:	2300      	movs	r3, #0
 8005cd6:	220f      	movs	r2, #15
 8005cd8:	2128      	movs	r1, #40	; 0x28
 8005cda:	4804      	ldr	r0, [pc, #16]	; (8005cec <Task_Screen_Update+0x50>)
 8005cdc:	f7fe fdb2 	bl	8004844 <ucg_DrawString>
}
 8005ce0:	bf00      	nop
 8005ce2:	46bd      	mov	sp, r7
 8005ce4:	bd80      	pop	{r7, pc}
 8005ce6:	bf00      	nop
 8005ce8:	200014e8 	.word	0x200014e8
 8005cec:	200014f8 	.word	0x200014f8
 8005cf0:	200015ac 	.word	0x200015ac
 8005cf4:	20000076 	.word	0x20000076
 8005cf8:	08006940 	.word	0x08006940

08005cfc <main>:

// Hàm main
int main(void) {
 8005cfc:	b580      	push	{r7, lr}
 8005cfe:	af00      	add	r7, sp, #0
    AppInitCommon();
 8005d00:	f7ff fdde 	bl	80058c0 <AppInitCommon>
    SetStateApp(STATE_APP_STARTUP);
 8005d04:	2000      	movs	r0, #0
 8005d06:	f7ff fe8b 	bl	8005a20 <SetStateApp>
    EventSchedulerAdd(EVENT_APP_INIT);
 8005d0a:	2001      	movs	r0, #1
 8005d0c:	f7fc fa64 	bl	80021d8 <EventSchedulerAdd>

    while (1) {
        processTimerScheduler();
 8005d10:	f7fc fbdc 	bl	80024cc <processTimerScheduler>
        processEventScheduler();
 8005d14:	f7fc fa76 	bl	8002204 <processEventScheduler>
        DeviceStateMachine(event);
 8005d18:	4b03      	ldr	r3, [pc, #12]	; (8005d28 <main+0x2c>)
 8005d1a:	781b      	ldrb	r3, [r3, #0]
 8005d1c:	4618      	mov	r0, r3
 8005d1e:	f7ff fe9b 	bl	8005a58 <DeviceStateMachine>
        Screen_Scan();
 8005d22:	f000 f803 	bl	8005d2c <Screen_Scan>
        processTimerScheduler();
 8005d26:	e7f3      	b.n	8005d10 <main+0x14>
 8005d28:	200014e5 	.word	0x200014e5

08005d2c <Screen_Scan>:
        TimerStop(IdTimerCancle);
    }
}

// Hàm quét màn hình
void Screen_Scan() {
 8005d2c:	b580      	push	{r7, lr}
 8005d2e:	b084      	sub	sp, #16
 8005d30:	af02      	add	r7, sp, #8
    uint32_t currentTime = GetMilSecTick();
 8005d32:	f7fc fbbf 	bl	80024b4 <GetMilSecTick>
 8005d36:	6078      	str	r0, [r7, #4]
    if (currentTime - lastUpdateTime >= updateInterval) {
 8005d38:	4b0e      	ldr	r3, [pc, #56]	; (8005d74 <Screen_Scan+0x48>)
 8005d3a:	681b      	ldr	r3, [r3, #0]
 8005d3c:	687a      	ldr	r2, [r7, #4]
 8005d3e:	1ad2      	subs	r2, r2, r3
 8005d40:	4b0d      	ldr	r3, [pc, #52]	; (8005d78 <Screen_Scan+0x4c>)
 8005d42:	681b      	ldr	r3, [r3, #0]
 8005d44:	429a      	cmp	r2, r3
 8005d46:	d311      	bcc.n	8005d6c <Screen_Scan+0x40>
        lastUpdateTime = currentTime;
 8005d48:	4a0a      	ldr	r2, [pc, #40]	; (8005d74 <Screen_Scan+0x48>)
 8005d4a:	687b      	ldr	r3, [r7, #4]
 8005d4c:	6013      	str	r3, [r2, #0]
        Task_Screen_Update();
 8005d4e:	f7ff ffa5 	bl	8005c9c <Task_Screen_Update>
        IdTimerCancle = TimerStart("delay", 5000, TIMER_REPEAT_FOREVER, (void *)Task_Screen_Update, NULL);
 8005d52:	2300      	movs	r3, #0
 8005d54:	9300      	str	r3, [sp, #0]
 8005d56:	4b09      	ldr	r3, [pc, #36]	; (8005d7c <Screen_Scan+0x50>)
 8005d58:	22ff      	movs	r2, #255	; 0xff
 8005d5a:	f241 3188 	movw	r1, #5000	; 0x1388
 8005d5e:	4808      	ldr	r0, [pc, #32]	; (8005d80 <Screen_Scan+0x54>)
 8005d60:	f7fc fada 	bl	8002318 <TimerStart>
 8005d64:	4603      	mov	r3, r0
 8005d66:	461a      	mov	r2, r3
 8005d68:	4b06      	ldr	r3, [pc, #24]	; (8005d84 <Screen_Scan+0x58>)
 8005d6a:	701a      	strb	r2, [r3, #0]
    }
}
 8005d6c:	bf00      	nop
 8005d6e:	3708      	adds	r7, #8
 8005d70:	46bd      	mov	sp, r7
 8005d72:	bd80      	pop	{r7, pc}
 8005d74:	200015e0 	.word	0x200015e0
 8005d78:	200000c8 	.word	0x200000c8
 8005d7c:	08005c9d 	.word	0x08005c9d
 8005d80:	08006958 	.word	0x08006958
 8005d84:	200014e9 	.word	0x200014e9

08005d88 <setup>:

// Hàm setup (cài đặt ban đầu)
void setup() {
 8005d88:	b580      	push	{r7, lr}
 8005d8a:	b084      	sub	sp, #16
 8005d8c:	af04      	add	r7, sp, #16
    // Vẽ hình 1 ngôi nhà
    ucg_DrawLine(&ucg, 2, 126, 41, 126);
 8005d8e:	237e      	movs	r3, #126	; 0x7e
 8005d90:	9300      	str	r3, [sp, #0]
 8005d92:	2329      	movs	r3, #41	; 0x29
 8005d94:	227e      	movs	r2, #126	; 0x7e
 8005d96:	2102      	movs	r1, #2
 8005d98:	4850      	ldr	r0, [pc, #320]	; (8005edc <setup+0x154>)
 8005d9a:	f7fe ff13 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 2, 101, 2, 126);
 8005d9e:	237e      	movs	r3, #126	; 0x7e
 8005da0:	9300      	str	r3, [sp, #0]
 8005da2:	2302      	movs	r3, #2
 8005da4:	2265      	movs	r2, #101	; 0x65
 8005da6:	2102      	movs	r1, #2
 8005da8:	484c      	ldr	r0, [pc, #304]	; (8005edc <setup+0x154>)
 8005daa:	f7fe ff0b 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 2, 101, 41, 101);
 8005dae:	2365      	movs	r3, #101	; 0x65
 8005db0:	9300      	str	r3, [sp, #0]
 8005db2:	2329      	movs	r3, #41	; 0x29
 8005db4:	2265      	movs	r2, #101	; 0x65
 8005db6:	2102      	movs	r1, #2
 8005db8:	4848      	ldr	r0, [pc, #288]	; (8005edc <setup+0x154>)
 8005dba:	f7fe ff03 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 41, 101, 41, 126);
 8005dbe:	237e      	movs	r3, #126	; 0x7e
 8005dc0:	9300      	str	r3, [sp, #0]
 8005dc2:	2329      	movs	r3, #41	; 0x29
 8005dc4:	2265      	movs	r2, #101	; 0x65
 8005dc6:	2129      	movs	r1, #41	; 0x29
 8005dc8:	4844      	ldr	r0, [pc, #272]	; (8005edc <setup+0x154>)
 8005dca:	f7fe fefb 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawTriangle(&ucg, 2, 101, 22, 90, 41, 101);
 8005dce:	2365      	movs	r3, #101	; 0x65
 8005dd0:	9302      	str	r3, [sp, #8]
 8005dd2:	2329      	movs	r3, #41	; 0x29
 8005dd4:	9301      	str	r3, [sp, #4]
 8005dd6:	235a      	movs	r3, #90	; 0x5a
 8005dd8:	9300      	str	r3, [sp, #0]
 8005dda:	2316      	movs	r3, #22
 8005ddc:	2265      	movs	r2, #101	; 0x65
 8005dde:	2102      	movs	r1, #2
 8005de0:	483e      	ldr	r0, [pc, #248]	; (8005edc <setup+0x154>)
 8005de2:	f7ff fb43 	bl	800546c <ucg_DrawTriangle>
    ucg_DrawLine(&ucg, 27, 125, 35, 125);
 8005de6:	237d      	movs	r3, #125	; 0x7d
 8005de8:	9300      	str	r3, [sp, #0]
 8005dea:	2323      	movs	r3, #35	; 0x23
 8005dec:	227d      	movs	r2, #125	; 0x7d
 8005dee:	211b      	movs	r1, #27
 8005df0:	483a      	ldr	r0, [pc, #232]	; (8005edc <setup+0x154>)
 8005df2:	f7fe fee7 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 27, 125, 27, 112);
 8005df6:	2370      	movs	r3, #112	; 0x70
 8005df8:	9300      	str	r3, [sp, #0]
 8005dfa:	231b      	movs	r3, #27
 8005dfc:	227d      	movs	r2, #125	; 0x7d
 8005dfe:	211b      	movs	r1, #27
 8005e00:	4836      	ldr	r0, [pc, #216]	; (8005edc <setup+0x154>)
 8005e02:	f7fe fedf 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 27, 112, 35, 112);
 8005e06:	2370      	movs	r3, #112	; 0x70
 8005e08:	9300      	str	r3, [sp, #0]
 8005e0a:	2323      	movs	r3, #35	; 0x23
 8005e0c:	2270      	movs	r2, #112	; 0x70
 8005e0e:	211b      	movs	r1, #27
 8005e10:	4832      	ldr	r0, [pc, #200]	; (8005edc <setup+0x154>)
 8005e12:	f7fe fed7 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 35, 125, 35, 112);
 8005e16:	2370      	movs	r3, #112	; 0x70
 8005e18:	9300      	str	r3, [sp, #0]
 8005e1a:	2323      	movs	r3, #35	; 0x23
 8005e1c:	227d      	movs	r2, #125	; 0x7d
 8005e1e:	2123      	movs	r1, #35	; 0x23
 8005e20:	482e      	ldr	r0, [pc, #184]	; (8005edc <setup+0x154>)
 8005e22:	f7fe fecf 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawCircle(&ucg, 12, 110, 5, UCG_DRAW_ALL);
 8005e26:	230f      	movs	r3, #15
 8005e28:	9300      	str	r3, [sp, #0]
 8005e2a:	2305      	movs	r3, #5
 8005e2c:	226e      	movs	r2, #110	; 0x6e
 8005e2e:	210c      	movs	r1, #12
 8005e30:	482a      	ldr	r0, [pc, #168]	; (8005edc <setup+0x154>)
 8005e32:	f7fd f89b 	bl	8002f6c <ucg_DrawCircle>

    // Vẽ hình 1 xe tải
    ucg_DrawFrame(&ucg, 50, 108, 30, 15);
 8005e36:	230f      	movs	r3, #15
 8005e38:	9300      	str	r3, [sp, #0]
 8005e3a:	231e      	movs	r3, #30
 8005e3c:	226c      	movs	r2, #108	; 0x6c
 8005e3e:	2132      	movs	r1, #50	; 0x32
 8005e40:	4826      	ldr	r0, [pc, #152]	; (8005edc <setup+0x154>)
 8005e42:	f7fc fe39 	bl	8002ab8 <ucg_DrawFrame>
    ucg_DrawLine(&ucg, 50, 121, 79, 121);
 8005e46:	2379      	movs	r3, #121	; 0x79
 8005e48:	9300      	str	r3, [sp, #0]
 8005e4a:	234f      	movs	r3, #79	; 0x4f
 8005e4c:	2279      	movs	r2, #121	; 0x79
 8005e4e:	2132      	movs	r1, #50	; 0x32
 8005e50:	4822      	ldr	r0, [pc, #136]	; (8005edc <setup+0x154>)
 8005e52:	f7fe feb7 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 50, 106, 79, 106);
 8005e56:	236a      	movs	r3, #106	; 0x6a
 8005e58:	9300      	str	r3, [sp, #0]
 8005e5a:	234f      	movs	r3, #79	; 0x4f
 8005e5c:	226a      	movs	r2, #106	; 0x6a
 8005e5e:	2132      	movs	r1, #50	; 0x32
 8005e60:	481e      	ldr	r0, [pc, #120]	; (8005edc <setup+0x154>)
 8005e62:	f7fe feaf 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 80, 122, 92, 122);
 8005e66:	237a      	movs	r3, #122	; 0x7a
 8005e68:	9300      	str	r3, [sp, #0]
 8005e6a:	235c      	movs	r3, #92	; 0x5c
 8005e6c:	227a      	movs	r2, #122	; 0x7a
 8005e6e:	2150      	movs	r1, #80	; 0x50
 8005e70:	481a      	ldr	r0, [pc, #104]	; (8005edc <setup+0x154>)
 8005e72:	f7fe fea7 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 92, 121, 92, 118);
 8005e76:	2376      	movs	r3, #118	; 0x76
 8005e78:	9300      	str	r3, [sp, #0]
 8005e7a:	235c      	movs	r3, #92	; 0x5c
 8005e7c:	2279      	movs	r2, #121	; 0x79
 8005e7e:	215c      	movs	r1, #92	; 0x5c
 8005e80:	4816      	ldr	r0, [pc, #88]	; (8005edc <setup+0x154>)
 8005e82:	f7fe fe9f 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 86, 112, 92, 118);
 8005e86:	2376      	movs	r3, #118	; 0x76
 8005e88:	9300      	str	r3, [sp, #0]
 8005e8a:	235c      	movs	r3, #92	; 0x5c
 8005e8c:	2270      	movs	r2, #112	; 0x70
 8005e8e:	2156      	movs	r1, #86	; 0x56
 8005e90:	4812      	ldr	r0, [pc, #72]	; (8005edc <setup+0x154>)
 8005e92:	f7fe fe97 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawLine(&ucg, 80, 112, 85, 112);
 8005e96:	2370      	movs	r3, #112	; 0x70
 8005e98:	9300      	str	r3, [sp, #0]
 8005e9a:	2355      	movs	r3, #85	; 0x55
 8005e9c:	2270      	movs	r2, #112	; 0x70
 8005e9e:	2150      	movs	r1, #80	; 0x50
 8005ea0:	480e      	ldr	r0, [pc, #56]	; (8005edc <setup+0x154>)
 8005ea2:	f7fe fe8f 	bl	8004bc4 <ucg_DrawLine>
    ucg_DrawCircle(&ucg, 55, 125, 2, UCG_DRAW_ALL);
 8005ea6:	230f      	movs	r3, #15
 8005ea8:	9300      	str	r3, [sp, #0]
 8005eaa:	2302      	movs	r3, #2
 8005eac:	227d      	movs	r2, #125	; 0x7d
 8005eae:	2137      	movs	r1, #55	; 0x37
 8005eb0:	480a      	ldr	r0, [pc, #40]	; (8005edc <setup+0x154>)
 8005eb2:	f7fd f85b 	bl	8002f6c <ucg_DrawCircle>
    ucg_DrawCircle(&ucg, 75, 125, 2, UCG_DRAW_ALL);
 8005eb6:	230f      	movs	r3, #15
 8005eb8:	9300      	str	r3, [sp, #0]
 8005eba:	2302      	movs	r3, #2
 8005ebc:	227d      	movs	r2, #125	; 0x7d
 8005ebe:	214b      	movs	r1, #75	; 0x4b
 8005ec0:	4806      	ldr	r0, [pc, #24]	; (8005edc <setup+0x154>)
 8005ec2:	f7fd f853 	bl	8002f6c <ucg_DrawCircle>
    ucg_DrawCircle(&ucg, 87, 125, 2, UCG_DRAW_ALL);
 8005ec6:	230f      	movs	r3, #15
 8005ec8:	9300      	str	r3, [sp, #0]
 8005eca:	2302      	movs	r3, #2
 8005ecc:	227d      	movs	r2, #125	; 0x7d
 8005ece:	2157      	movs	r1, #87	; 0x57
 8005ed0:	4802      	ldr	r0, [pc, #8]	; (8005edc <setup+0x154>)
 8005ed2:	f7fd f84b 	bl	8002f6c <ucg_DrawCircle>
}
 8005ed6:	bf00      	nop
 8005ed8:	46bd      	mov	sp, r7
 8005eda:	bd80      	pop	{r7, pc}
 8005edc:	200014f8 	.word	0x200014f8

08005ee0 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 8005ee0:	b580      	push	{r7, lr}
 8005ee2:	b086      	sub	sp, #24
 8005ee4:	af00      	add	r7, sp, #0
 8005ee6:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8005ee8:	4a14      	ldr	r2, [pc, #80]	; (8005f3c <_sbrk+0x5c>)
 8005eea:	4b15      	ldr	r3, [pc, #84]	; (8005f40 <_sbrk+0x60>)
 8005eec:	1ad3      	subs	r3, r2, r3
 8005eee:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 8005ef0:	697b      	ldr	r3, [r7, #20]
 8005ef2:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8005ef4:	4b13      	ldr	r3, [pc, #76]	; (8005f44 <_sbrk+0x64>)
 8005ef6:	681b      	ldr	r3, [r3, #0]
 8005ef8:	2b00      	cmp	r3, #0
 8005efa:	d102      	bne.n	8005f02 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8005efc:	4b11      	ldr	r3, [pc, #68]	; (8005f44 <_sbrk+0x64>)
 8005efe:	4a12      	ldr	r2, [pc, #72]	; (8005f48 <_sbrk+0x68>)
 8005f00:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 8005f02:	4b10      	ldr	r3, [pc, #64]	; (8005f44 <_sbrk+0x64>)
 8005f04:	681a      	ldr	r2, [r3, #0]
 8005f06:	687b      	ldr	r3, [r7, #4]
 8005f08:	4413      	add	r3, r2
 8005f0a:	693a      	ldr	r2, [r7, #16]
 8005f0c:	429a      	cmp	r2, r3
 8005f0e:	d207      	bcs.n	8005f20 <_sbrk+0x40>
  {
    errno = ENOMEM;
 8005f10:	f000 f86e 	bl	8005ff0 <__errno>
 8005f14:	4603      	mov	r3, r0
 8005f16:	220c      	movs	r2, #12
 8005f18:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8005f1a:	f04f 33ff 	mov.w	r3, #4294967295
 8005f1e:	e009      	b.n	8005f34 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 8005f20:	4b08      	ldr	r3, [pc, #32]	; (8005f44 <_sbrk+0x64>)
 8005f22:	681b      	ldr	r3, [r3, #0]
 8005f24:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8005f26:	4b07      	ldr	r3, [pc, #28]	; (8005f44 <_sbrk+0x64>)
 8005f28:	681a      	ldr	r2, [r3, #0]
 8005f2a:	687b      	ldr	r3, [r7, #4]
 8005f2c:	4413      	add	r3, r2
 8005f2e:	4a05      	ldr	r2, [pc, #20]	; (8005f44 <_sbrk+0x64>)
 8005f30:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 8005f32:	68fb      	ldr	r3, [r7, #12]
}
 8005f34:	4618      	mov	r0, r3
 8005f36:	3718      	adds	r7, #24
 8005f38:	46bd      	mov	sp, r7
 8005f3a:	bd80      	pop	{r7, pc}
 8005f3c:	20018000 	.word	0x20018000
 8005f40:	00000400 	.word	0x00000400
 8005f44:	200015e4 	.word	0x200015e4
 8005f48:	20001730 	.word	0x20001730

08005f4c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8005f4c:	480d      	ldr	r0, [pc, #52]	; (8005f84 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8005f4e:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8005f50:	f7fa f996 	bl	8000280 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8005f54:	480c      	ldr	r0, [pc, #48]	; (8005f88 <LoopForever+0x6>)
  ldr r1, =_edata
 8005f56:	490d      	ldr	r1, [pc, #52]	; (8005f8c <LoopForever+0xa>)
  ldr r2, =_sidata
 8005f58:	4a0d      	ldr	r2, [pc, #52]	; (8005f90 <LoopForever+0xe>)
  movs r3, #0
 8005f5a:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8005f5c:	e002      	b.n	8005f64 <LoopCopyDataInit>

08005f5e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8005f5e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8005f60:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8005f62:	3304      	adds	r3, #4

08005f64 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8005f64:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8005f66:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8005f68:	d3f9      	bcc.n	8005f5e <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8005f6a:	4a0a      	ldr	r2, [pc, #40]	; (8005f94 <LoopForever+0x12>)
  ldr r4, =_ebss
 8005f6c:	4c0a      	ldr	r4, [pc, #40]	; (8005f98 <LoopForever+0x16>)
  movs r3, #0
 8005f6e:	2300      	movs	r3, #0
  b LoopFillZerobss
 8005f70:	e001      	b.n	8005f76 <LoopFillZerobss>

08005f72 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8005f72:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8005f74:	3204      	adds	r2, #4

08005f76 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8005f76:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8005f78:	d3fb      	bcc.n	8005f72 <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 8005f7a:	f000 f83f 	bl	8005ffc <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8005f7e:	f7ff febd 	bl	8005cfc <main>

08005f82 <LoopForever>:

LoopForever:
  b LoopForever
 8005f82:	e7fe      	b.n	8005f82 <LoopForever>
  ldr   r0, =_estack
 8005f84:	20018000 	.word	0x20018000
  ldr r0, =_sdata
 8005f88:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8005f8c:	2000011c 	.word	0x2000011c
  ldr r2, =_sidata
 8005f90:	08017b84 	.word	0x08017b84
  ldr r2, =_sbss
 8005f94:	2000011c 	.word	0x2000011c
  ldr r4, =_ebss
 8005f98:	20001730 	.word	0x20001730

08005f9c <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8005f9c:	e7fe      	b.n	8005f9c <ADC_IRQHandler>
	...

08005fa0 <siprintf>:
 8005fa0:	b40e      	push	{r1, r2, r3}
 8005fa2:	b500      	push	{lr}
 8005fa4:	b09c      	sub	sp, #112	; 0x70
 8005fa6:	ab1d      	add	r3, sp, #116	; 0x74
 8005fa8:	9002      	str	r0, [sp, #8]
 8005faa:	9006      	str	r0, [sp, #24]
 8005fac:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 8005fb0:	4809      	ldr	r0, [pc, #36]	; (8005fd8 <siprintf+0x38>)
 8005fb2:	9107      	str	r1, [sp, #28]
 8005fb4:	9104      	str	r1, [sp, #16]
 8005fb6:	4909      	ldr	r1, [pc, #36]	; (8005fdc <siprintf+0x3c>)
 8005fb8:	f853 2b04 	ldr.w	r2, [r3], #4
 8005fbc:	9105      	str	r1, [sp, #20]
 8005fbe:	6800      	ldr	r0, [r0, #0]
 8005fc0:	9301      	str	r3, [sp, #4]
 8005fc2:	a902      	add	r1, sp, #8
 8005fc4:	f000 f992 	bl	80062ec <_svfiprintf_r>
 8005fc8:	9b02      	ldr	r3, [sp, #8]
 8005fca:	2200      	movs	r2, #0
 8005fcc:	701a      	strb	r2, [r3, #0]
 8005fce:	b01c      	add	sp, #112	; 0x70
 8005fd0:	f85d eb04 	ldr.w	lr, [sp], #4
 8005fd4:	b003      	add	sp, #12
 8005fd6:	4770      	bx	lr
 8005fd8:	20000118 	.word	0x20000118
 8005fdc:	ffff0208 	.word	0xffff0208

08005fe0 <memset>:
 8005fe0:	4402      	add	r2, r0
 8005fe2:	4603      	mov	r3, r0
 8005fe4:	4293      	cmp	r3, r2
 8005fe6:	d100      	bne.n	8005fea <memset+0xa>
 8005fe8:	4770      	bx	lr
 8005fea:	f803 1b01 	strb.w	r1, [r3], #1
 8005fee:	e7f9      	b.n	8005fe4 <memset+0x4>

08005ff0 <__errno>:
 8005ff0:	4b01      	ldr	r3, [pc, #4]	; (8005ff8 <__errno+0x8>)
 8005ff2:	6818      	ldr	r0, [r3, #0]
 8005ff4:	4770      	bx	lr
 8005ff6:	bf00      	nop
 8005ff8:	20000118 	.word	0x20000118

08005ffc <__libc_init_array>:
 8005ffc:	b570      	push	{r4, r5, r6, lr}
 8005ffe:	4d0d      	ldr	r5, [pc, #52]	; (8006034 <__libc_init_array+0x38>)
 8006000:	4c0d      	ldr	r4, [pc, #52]	; (8006038 <__libc_init_array+0x3c>)
 8006002:	1b64      	subs	r4, r4, r5
 8006004:	10a4      	asrs	r4, r4, #2
 8006006:	2600      	movs	r6, #0
 8006008:	42a6      	cmp	r6, r4
 800600a:	d109      	bne.n	8006020 <__libc_init_array+0x24>
 800600c:	4d0b      	ldr	r5, [pc, #44]	; (800603c <__libc_init_array+0x40>)
 800600e:	4c0c      	ldr	r4, [pc, #48]	; (8006040 <__libc_init_array+0x44>)
 8006010:	f000 fc6a 	bl	80068e8 <_init>
 8006014:	1b64      	subs	r4, r4, r5
 8006016:	10a4      	asrs	r4, r4, #2
 8006018:	2600      	movs	r6, #0
 800601a:	42a6      	cmp	r6, r4
 800601c:	d105      	bne.n	800602a <__libc_init_array+0x2e>
 800601e:	bd70      	pop	{r4, r5, r6, pc}
 8006020:	f855 3b04 	ldr.w	r3, [r5], #4
 8006024:	4798      	blx	r3
 8006026:	3601      	adds	r6, #1
 8006028:	e7ee      	b.n	8006008 <__libc_init_array+0xc>
 800602a:	f855 3b04 	ldr.w	r3, [r5], #4
 800602e:	4798      	blx	r3
 8006030:	3601      	adds	r6, #1
 8006032:	e7f2      	b.n	800601a <__libc_init_array+0x1e>
 8006034:	08017b7c 	.word	0x08017b7c
 8006038:	08017b7c 	.word	0x08017b7c
 800603c:	08017b7c 	.word	0x08017b7c
 8006040:	08017b80 	.word	0x08017b80

08006044 <__retarget_lock_acquire_recursive>:
 8006044:	4770      	bx	lr

08006046 <__retarget_lock_release_recursive>:
 8006046:	4770      	bx	lr

08006048 <_free_r>:
 8006048:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800604a:	2900      	cmp	r1, #0
 800604c:	d044      	beq.n	80060d8 <_free_r+0x90>
 800604e:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8006052:	9001      	str	r0, [sp, #4]
 8006054:	2b00      	cmp	r3, #0
 8006056:	f1a1 0404 	sub.w	r4, r1, #4
 800605a:	bfb8      	it	lt
 800605c:	18e4      	addlt	r4, r4, r3
 800605e:	f000 f8df 	bl	8006220 <__malloc_lock>
 8006062:	4a1e      	ldr	r2, [pc, #120]	; (80060dc <_free_r+0x94>)
 8006064:	9801      	ldr	r0, [sp, #4]
 8006066:	6813      	ldr	r3, [r2, #0]
 8006068:	b933      	cbnz	r3, 8006078 <_free_r+0x30>
 800606a:	6063      	str	r3, [r4, #4]
 800606c:	6014      	str	r4, [r2, #0]
 800606e:	b003      	add	sp, #12
 8006070:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8006074:	f000 b8da 	b.w	800622c <__malloc_unlock>
 8006078:	42a3      	cmp	r3, r4
 800607a:	d908      	bls.n	800608e <_free_r+0x46>
 800607c:	6825      	ldr	r5, [r4, #0]
 800607e:	1961      	adds	r1, r4, r5
 8006080:	428b      	cmp	r3, r1
 8006082:	bf01      	itttt	eq
 8006084:	6819      	ldreq	r1, [r3, #0]
 8006086:	685b      	ldreq	r3, [r3, #4]
 8006088:	1949      	addeq	r1, r1, r5
 800608a:	6021      	streq	r1, [r4, #0]
 800608c:	e7ed      	b.n	800606a <_free_r+0x22>
 800608e:	461a      	mov	r2, r3
 8006090:	685b      	ldr	r3, [r3, #4]
 8006092:	b10b      	cbz	r3, 8006098 <_free_r+0x50>
 8006094:	42a3      	cmp	r3, r4
 8006096:	d9fa      	bls.n	800608e <_free_r+0x46>
 8006098:	6811      	ldr	r1, [r2, #0]
 800609a:	1855      	adds	r5, r2, r1
 800609c:	42a5      	cmp	r5, r4
 800609e:	d10b      	bne.n	80060b8 <_free_r+0x70>
 80060a0:	6824      	ldr	r4, [r4, #0]
 80060a2:	4421      	add	r1, r4
 80060a4:	1854      	adds	r4, r2, r1
 80060a6:	42a3      	cmp	r3, r4
 80060a8:	6011      	str	r1, [r2, #0]
 80060aa:	d1e0      	bne.n	800606e <_free_r+0x26>
 80060ac:	681c      	ldr	r4, [r3, #0]
 80060ae:	685b      	ldr	r3, [r3, #4]
 80060b0:	6053      	str	r3, [r2, #4]
 80060b2:	440c      	add	r4, r1
 80060b4:	6014      	str	r4, [r2, #0]
 80060b6:	e7da      	b.n	800606e <_free_r+0x26>
 80060b8:	d902      	bls.n	80060c0 <_free_r+0x78>
 80060ba:	230c      	movs	r3, #12
 80060bc:	6003      	str	r3, [r0, #0]
 80060be:	e7d6      	b.n	800606e <_free_r+0x26>
 80060c0:	6825      	ldr	r5, [r4, #0]
 80060c2:	1961      	adds	r1, r4, r5
 80060c4:	428b      	cmp	r3, r1
 80060c6:	bf04      	itt	eq
 80060c8:	6819      	ldreq	r1, [r3, #0]
 80060ca:	685b      	ldreq	r3, [r3, #4]
 80060cc:	6063      	str	r3, [r4, #4]
 80060ce:	bf04      	itt	eq
 80060d0:	1949      	addeq	r1, r1, r5
 80060d2:	6021      	streq	r1, [r4, #0]
 80060d4:	6054      	str	r4, [r2, #4]
 80060d6:	e7ca      	b.n	800606e <_free_r+0x26>
 80060d8:	b003      	add	sp, #12
 80060da:	bd30      	pop	{r4, r5, pc}
 80060dc:	20001728 	.word	0x20001728

080060e0 <sbrk_aligned>:
 80060e0:	b570      	push	{r4, r5, r6, lr}
 80060e2:	4e0e      	ldr	r6, [pc, #56]	; (800611c <sbrk_aligned+0x3c>)
 80060e4:	460c      	mov	r4, r1
 80060e6:	6831      	ldr	r1, [r6, #0]
 80060e8:	4605      	mov	r5, r0
 80060ea:	b911      	cbnz	r1, 80060f2 <sbrk_aligned+0x12>
 80060ec:	f000 fba6 	bl	800683c <_sbrk_r>
 80060f0:	6030      	str	r0, [r6, #0]
 80060f2:	4621      	mov	r1, r4
 80060f4:	4628      	mov	r0, r5
 80060f6:	f000 fba1 	bl	800683c <_sbrk_r>
 80060fa:	1c43      	adds	r3, r0, #1
 80060fc:	d00a      	beq.n	8006114 <sbrk_aligned+0x34>
 80060fe:	1cc4      	adds	r4, r0, #3
 8006100:	f024 0403 	bic.w	r4, r4, #3
 8006104:	42a0      	cmp	r0, r4
 8006106:	d007      	beq.n	8006118 <sbrk_aligned+0x38>
 8006108:	1a21      	subs	r1, r4, r0
 800610a:	4628      	mov	r0, r5
 800610c:	f000 fb96 	bl	800683c <_sbrk_r>
 8006110:	3001      	adds	r0, #1
 8006112:	d101      	bne.n	8006118 <sbrk_aligned+0x38>
 8006114:	f04f 34ff 	mov.w	r4, #4294967295
 8006118:	4620      	mov	r0, r4
 800611a:	bd70      	pop	{r4, r5, r6, pc}
 800611c:	2000172c 	.word	0x2000172c

08006120 <_malloc_r>:
 8006120:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8006124:	1ccd      	adds	r5, r1, #3
 8006126:	f025 0503 	bic.w	r5, r5, #3
 800612a:	3508      	adds	r5, #8
 800612c:	2d0c      	cmp	r5, #12
 800612e:	bf38      	it	cc
 8006130:	250c      	movcc	r5, #12
 8006132:	2d00      	cmp	r5, #0
 8006134:	4607      	mov	r7, r0
 8006136:	db01      	blt.n	800613c <_malloc_r+0x1c>
 8006138:	42a9      	cmp	r1, r5
 800613a:	d905      	bls.n	8006148 <_malloc_r+0x28>
 800613c:	230c      	movs	r3, #12
 800613e:	603b      	str	r3, [r7, #0]
 8006140:	2600      	movs	r6, #0
 8006142:	4630      	mov	r0, r6
 8006144:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006148:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 800621c <_malloc_r+0xfc>
 800614c:	f000 f868 	bl	8006220 <__malloc_lock>
 8006150:	f8d8 3000 	ldr.w	r3, [r8]
 8006154:	461c      	mov	r4, r3
 8006156:	bb5c      	cbnz	r4, 80061b0 <_malloc_r+0x90>
 8006158:	4629      	mov	r1, r5
 800615a:	4638      	mov	r0, r7
 800615c:	f7ff ffc0 	bl	80060e0 <sbrk_aligned>
 8006160:	1c43      	adds	r3, r0, #1
 8006162:	4604      	mov	r4, r0
 8006164:	d155      	bne.n	8006212 <_malloc_r+0xf2>
 8006166:	f8d8 4000 	ldr.w	r4, [r8]
 800616a:	4626      	mov	r6, r4
 800616c:	2e00      	cmp	r6, #0
 800616e:	d145      	bne.n	80061fc <_malloc_r+0xdc>
 8006170:	2c00      	cmp	r4, #0
 8006172:	d048      	beq.n	8006206 <_malloc_r+0xe6>
 8006174:	6823      	ldr	r3, [r4, #0]
 8006176:	4631      	mov	r1, r6
 8006178:	4638      	mov	r0, r7
 800617a:	eb04 0903 	add.w	r9, r4, r3
 800617e:	f000 fb5d 	bl	800683c <_sbrk_r>
 8006182:	4581      	cmp	r9, r0
 8006184:	d13f      	bne.n	8006206 <_malloc_r+0xe6>
 8006186:	6821      	ldr	r1, [r4, #0]
 8006188:	1a6d      	subs	r5, r5, r1
 800618a:	4629      	mov	r1, r5
 800618c:	4638      	mov	r0, r7
 800618e:	f7ff ffa7 	bl	80060e0 <sbrk_aligned>
 8006192:	3001      	adds	r0, #1
 8006194:	d037      	beq.n	8006206 <_malloc_r+0xe6>
 8006196:	6823      	ldr	r3, [r4, #0]
 8006198:	442b      	add	r3, r5
 800619a:	6023      	str	r3, [r4, #0]
 800619c:	f8d8 3000 	ldr.w	r3, [r8]
 80061a0:	2b00      	cmp	r3, #0
 80061a2:	d038      	beq.n	8006216 <_malloc_r+0xf6>
 80061a4:	685a      	ldr	r2, [r3, #4]
 80061a6:	42a2      	cmp	r2, r4
 80061a8:	d12b      	bne.n	8006202 <_malloc_r+0xe2>
 80061aa:	2200      	movs	r2, #0
 80061ac:	605a      	str	r2, [r3, #4]
 80061ae:	e00f      	b.n	80061d0 <_malloc_r+0xb0>
 80061b0:	6822      	ldr	r2, [r4, #0]
 80061b2:	1b52      	subs	r2, r2, r5
 80061b4:	d41f      	bmi.n	80061f6 <_malloc_r+0xd6>
 80061b6:	2a0b      	cmp	r2, #11
 80061b8:	d917      	bls.n	80061ea <_malloc_r+0xca>
 80061ba:	1961      	adds	r1, r4, r5
 80061bc:	42a3      	cmp	r3, r4
 80061be:	6025      	str	r5, [r4, #0]
 80061c0:	bf18      	it	ne
 80061c2:	6059      	strne	r1, [r3, #4]
 80061c4:	6863      	ldr	r3, [r4, #4]
 80061c6:	bf08      	it	eq
 80061c8:	f8c8 1000 	streq.w	r1, [r8]
 80061cc:	5162      	str	r2, [r4, r5]
 80061ce:	604b      	str	r3, [r1, #4]
 80061d0:	4638      	mov	r0, r7
 80061d2:	f104 060b 	add.w	r6, r4, #11
 80061d6:	f000 f829 	bl	800622c <__malloc_unlock>
 80061da:	f026 0607 	bic.w	r6, r6, #7
 80061de:	1d23      	adds	r3, r4, #4
 80061e0:	1af2      	subs	r2, r6, r3
 80061e2:	d0ae      	beq.n	8006142 <_malloc_r+0x22>
 80061e4:	1b9b      	subs	r3, r3, r6
 80061e6:	50a3      	str	r3, [r4, r2]
 80061e8:	e7ab      	b.n	8006142 <_malloc_r+0x22>
 80061ea:	42a3      	cmp	r3, r4
 80061ec:	6862      	ldr	r2, [r4, #4]
 80061ee:	d1dd      	bne.n	80061ac <_malloc_r+0x8c>
 80061f0:	f8c8 2000 	str.w	r2, [r8]
 80061f4:	e7ec      	b.n	80061d0 <_malloc_r+0xb0>
 80061f6:	4623      	mov	r3, r4
 80061f8:	6864      	ldr	r4, [r4, #4]
 80061fa:	e7ac      	b.n	8006156 <_malloc_r+0x36>
 80061fc:	4634      	mov	r4, r6
 80061fe:	6876      	ldr	r6, [r6, #4]
 8006200:	e7b4      	b.n	800616c <_malloc_r+0x4c>
 8006202:	4613      	mov	r3, r2
 8006204:	e7cc      	b.n	80061a0 <_malloc_r+0x80>
 8006206:	230c      	movs	r3, #12
 8006208:	603b      	str	r3, [r7, #0]
 800620a:	4638      	mov	r0, r7
 800620c:	f000 f80e 	bl	800622c <__malloc_unlock>
 8006210:	e797      	b.n	8006142 <_malloc_r+0x22>
 8006212:	6025      	str	r5, [r4, #0]
 8006214:	e7dc      	b.n	80061d0 <_malloc_r+0xb0>
 8006216:	605b      	str	r3, [r3, #4]
 8006218:	deff      	udf	#255	; 0xff
 800621a:	bf00      	nop
 800621c:	20001728 	.word	0x20001728

08006220 <__malloc_lock>:
 8006220:	4801      	ldr	r0, [pc, #4]	; (8006228 <__malloc_lock+0x8>)
 8006222:	f7ff bf0f 	b.w	8006044 <__retarget_lock_acquire_recursive>
 8006226:	bf00      	nop
 8006228:	20001724 	.word	0x20001724

0800622c <__malloc_unlock>:
 800622c:	4801      	ldr	r0, [pc, #4]	; (8006234 <__malloc_unlock+0x8>)
 800622e:	f7ff bf0a 	b.w	8006046 <__retarget_lock_release_recursive>
 8006232:	bf00      	nop
 8006234:	20001724 	.word	0x20001724

08006238 <__ssputs_r>:
 8006238:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800623c:	688e      	ldr	r6, [r1, #8]
 800623e:	461f      	mov	r7, r3
 8006240:	42be      	cmp	r6, r7
 8006242:	680b      	ldr	r3, [r1, #0]
 8006244:	4682      	mov	sl, r0
 8006246:	460c      	mov	r4, r1
 8006248:	4690      	mov	r8, r2
 800624a:	d82c      	bhi.n	80062a6 <__ssputs_r+0x6e>
 800624c:	898a      	ldrh	r2, [r1, #12]
 800624e:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8006252:	d026      	beq.n	80062a2 <__ssputs_r+0x6a>
 8006254:	6965      	ldr	r5, [r4, #20]
 8006256:	6909      	ldr	r1, [r1, #16]
 8006258:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800625c:	eba3 0901 	sub.w	r9, r3, r1
 8006260:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 8006264:	1c7b      	adds	r3, r7, #1
 8006266:	444b      	add	r3, r9
 8006268:	106d      	asrs	r5, r5, #1
 800626a:	429d      	cmp	r5, r3
 800626c:	bf38      	it	cc
 800626e:	461d      	movcc	r5, r3
 8006270:	0553      	lsls	r3, r2, #21
 8006272:	d527      	bpl.n	80062c4 <__ssputs_r+0x8c>
 8006274:	4629      	mov	r1, r5
 8006276:	f7ff ff53 	bl	8006120 <_malloc_r>
 800627a:	4606      	mov	r6, r0
 800627c:	b360      	cbz	r0, 80062d8 <__ssputs_r+0xa0>
 800627e:	6921      	ldr	r1, [r4, #16]
 8006280:	464a      	mov	r2, r9
 8006282:	f000 faeb 	bl	800685c <memcpy>
 8006286:	89a3      	ldrh	r3, [r4, #12]
 8006288:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800628c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8006290:	81a3      	strh	r3, [r4, #12]
 8006292:	6126      	str	r6, [r4, #16]
 8006294:	6165      	str	r5, [r4, #20]
 8006296:	444e      	add	r6, r9
 8006298:	eba5 0509 	sub.w	r5, r5, r9
 800629c:	6026      	str	r6, [r4, #0]
 800629e:	60a5      	str	r5, [r4, #8]
 80062a0:	463e      	mov	r6, r7
 80062a2:	42be      	cmp	r6, r7
 80062a4:	d900      	bls.n	80062a8 <__ssputs_r+0x70>
 80062a6:	463e      	mov	r6, r7
 80062a8:	6820      	ldr	r0, [r4, #0]
 80062aa:	4632      	mov	r2, r6
 80062ac:	4641      	mov	r1, r8
 80062ae:	f000 faab 	bl	8006808 <memmove>
 80062b2:	68a3      	ldr	r3, [r4, #8]
 80062b4:	1b9b      	subs	r3, r3, r6
 80062b6:	60a3      	str	r3, [r4, #8]
 80062b8:	6823      	ldr	r3, [r4, #0]
 80062ba:	4433      	add	r3, r6
 80062bc:	6023      	str	r3, [r4, #0]
 80062be:	2000      	movs	r0, #0
 80062c0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80062c4:	462a      	mov	r2, r5
 80062c6:	f000 fad7 	bl	8006878 <_realloc_r>
 80062ca:	4606      	mov	r6, r0
 80062cc:	2800      	cmp	r0, #0
 80062ce:	d1e0      	bne.n	8006292 <__ssputs_r+0x5a>
 80062d0:	6921      	ldr	r1, [r4, #16]
 80062d2:	4650      	mov	r0, sl
 80062d4:	f7ff feb8 	bl	8006048 <_free_r>
 80062d8:	230c      	movs	r3, #12
 80062da:	f8ca 3000 	str.w	r3, [sl]
 80062de:	89a3      	ldrh	r3, [r4, #12]
 80062e0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80062e4:	81a3      	strh	r3, [r4, #12]
 80062e6:	f04f 30ff 	mov.w	r0, #4294967295
 80062ea:	e7e9      	b.n	80062c0 <__ssputs_r+0x88>

080062ec <_svfiprintf_r>:
 80062ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80062f0:	4698      	mov	r8, r3
 80062f2:	898b      	ldrh	r3, [r1, #12]
 80062f4:	061b      	lsls	r3, r3, #24
 80062f6:	b09d      	sub	sp, #116	; 0x74
 80062f8:	4607      	mov	r7, r0
 80062fa:	460d      	mov	r5, r1
 80062fc:	4614      	mov	r4, r2
 80062fe:	d50e      	bpl.n	800631e <_svfiprintf_r+0x32>
 8006300:	690b      	ldr	r3, [r1, #16]
 8006302:	b963      	cbnz	r3, 800631e <_svfiprintf_r+0x32>
 8006304:	2140      	movs	r1, #64	; 0x40
 8006306:	f7ff ff0b 	bl	8006120 <_malloc_r>
 800630a:	6028      	str	r0, [r5, #0]
 800630c:	6128      	str	r0, [r5, #16]
 800630e:	b920      	cbnz	r0, 800631a <_svfiprintf_r+0x2e>
 8006310:	230c      	movs	r3, #12
 8006312:	603b      	str	r3, [r7, #0]
 8006314:	f04f 30ff 	mov.w	r0, #4294967295
 8006318:	e0d0      	b.n	80064bc <_svfiprintf_r+0x1d0>
 800631a:	2340      	movs	r3, #64	; 0x40
 800631c:	616b      	str	r3, [r5, #20]
 800631e:	2300      	movs	r3, #0
 8006320:	9309      	str	r3, [sp, #36]	; 0x24
 8006322:	2320      	movs	r3, #32
 8006324:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8006328:	f8cd 800c 	str.w	r8, [sp, #12]
 800632c:	2330      	movs	r3, #48	; 0x30
 800632e:	f8df 81a4 	ldr.w	r8, [pc, #420]	; 80064d4 <_svfiprintf_r+0x1e8>
 8006332:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8006336:	f04f 0901 	mov.w	r9, #1
 800633a:	4623      	mov	r3, r4
 800633c:	469a      	mov	sl, r3
 800633e:	f813 2b01 	ldrb.w	r2, [r3], #1
 8006342:	b10a      	cbz	r2, 8006348 <_svfiprintf_r+0x5c>
 8006344:	2a25      	cmp	r2, #37	; 0x25
 8006346:	d1f9      	bne.n	800633c <_svfiprintf_r+0x50>
 8006348:	ebba 0b04 	subs.w	fp, sl, r4
 800634c:	d00b      	beq.n	8006366 <_svfiprintf_r+0x7a>
 800634e:	465b      	mov	r3, fp
 8006350:	4622      	mov	r2, r4
 8006352:	4629      	mov	r1, r5
 8006354:	4638      	mov	r0, r7
 8006356:	f7ff ff6f 	bl	8006238 <__ssputs_r>
 800635a:	3001      	adds	r0, #1
 800635c:	f000 80a9 	beq.w	80064b2 <_svfiprintf_r+0x1c6>
 8006360:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8006362:	445a      	add	r2, fp
 8006364:	9209      	str	r2, [sp, #36]	; 0x24
 8006366:	f89a 3000 	ldrb.w	r3, [sl]
 800636a:	2b00      	cmp	r3, #0
 800636c:	f000 80a1 	beq.w	80064b2 <_svfiprintf_r+0x1c6>
 8006370:	2300      	movs	r3, #0
 8006372:	f04f 32ff 	mov.w	r2, #4294967295
 8006376:	e9cd 2305 	strd	r2, r3, [sp, #20]
 800637a:	f10a 0a01 	add.w	sl, sl, #1
 800637e:	9304      	str	r3, [sp, #16]
 8006380:	9307      	str	r3, [sp, #28]
 8006382:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8006386:	931a      	str	r3, [sp, #104]	; 0x68
 8006388:	4654      	mov	r4, sl
 800638a:	2205      	movs	r2, #5
 800638c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8006390:	4850      	ldr	r0, [pc, #320]	; (80064d4 <_svfiprintf_r+0x1e8>)
 8006392:	f7f9 ff25 	bl	80001e0 <memchr>
 8006396:	9a04      	ldr	r2, [sp, #16]
 8006398:	b9d8      	cbnz	r0, 80063d2 <_svfiprintf_r+0xe6>
 800639a:	06d0      	lsls	r0, r2, #27
 800639c:	bf44      	itt	mi
 800639e:	2320      	movmi	r3, #32
 80063a0:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80063a4:	0711      	lsls	r1, r2, #28
 80063a6:	bf44      	itt	mi
 80063a8:	232b      	movmi	r3, #43	; 0x2b
 80063aa:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 80063ae:	f89a 3000 	ldrb.w	r3, [sl]
 80063b2:	2b2a      	cmp	r3, #42	; 0x2a
 80063b4:	d015      	beq.n	80063e2 <_svfiprintf_r+0xf6>
 80063b6:	9a07      	ldr	r2, [sp, #28]
 80063b8:	4654      	mov	r4, sl
 80063ba:	2000      	movs	r0, #0
 80063bc:	f04f 0c0a 	mov.w	ip, #10
 80063c0:	4621      	mov	r1, r4
 80063c2:	f811 3b01 	ldrb.w	r3, [r1], #1
 80063c6:	3b30      	subs	r3, #48	; 0x30
 80063c8:	2b09      	cmp	r3, #9
 80063ca:	d94d      	bls.n	8006468 <_svfiprintf_r+0x17c>
 80063cc:	b1b0      	cbz	r0, 80063fc <_svfiprintf_r+0x110>
 80063ce:	9207      	str	r2, [sp, #28]
 80063d0:	e014      	b.n	80063fc <_svfiprintf_r+0x110>
 80063d2:	eba0 0308 	sub.w	r3, r0, r8
 80063d6:	fa09 f303 	lsl.w	r3, r9, r3
 80063da:	4313      	orrs	r3, r2
 80063dc:	9304      	str	r3, [sp, #16]
 80063de:	46a2      	mov	sl, r4
 80063e0:	e7d2      	b.n	8006388 <_svfiprintf_r+0x9c>
 80063e2:	9b03      	ldr	r3, [sp, #12]
 80063e4:	1d19      	adds	r1, r3, #4
 80063e6:	681b      	ldr	r3, [r3, #0]
 80063e8:	9103      	str	r1, [sp, #12]
 80063ea:	2b00      	cmp	r3, #0
 80063ec:	bfbb      	ittet	lt
 80063ee:	425b      	neglt	r3, r3
 80063f0:	f042 0202 	orrlt.w	r2, r2, #2
 80063f4:	9307      	strge	r3, [sp, #28]
 80063f6:	9307      	strlt	r3, [sp, #28]
 80063f8:	bfb8      	it	lt
 80063fa:	9204      	strlt	r2, [sp, #16]
 80063fc:	7823      	ldrb	r3, [r4, #0]
 80063fe:	2b2e      	cmp	r3, #46	; 0x2e
 8006400:	d10c      	bne.n	800641c <_svfiprintf_r+0x130>
 8006402:	7863      	ldrb	r3, [r4, #1]
 8006404:	2b2a      	cmp	r3, #42	; 0x2a
 8006406:	d134      	bne.n	8006472 <_svfiprintf_r+0x186>
 8006408:	9b03      	ldr	r3, [sp, #12]
 800640a:	1d1a      	adds	r2, r3, #4
 800640c:	681b      	ldr	r3, [r3, #0]
 800640e:	9203      	str	r2, [sp, #12]
 8006410:	2b00      	cmp	r3, #0
 8006412:	bfb8      	it	lt
 8006414:	f04f 33ff 	movlt.w	r3, #4294967295
 8006418:	3402      	adds	r4, #2
 800641a:	9305      	str	r3, [sp, #20]
 800641c:	f8df a0c4 	ldr.w	sl, [pc, #196]	; 80064e4 <_svfiprintf_r+0x1f8>
 8006420:	7821      	ldrb	r1, [r4, #0]
 8006422:	2203      	movs	r2, #3
 8006424:	4650      	mov	r0, sl
 8006426:	f7f9 fedb 	bl	80001e0 <memchr>
 800642a:	b138      	cbz	r0, 800643c <_svfiprintf_r+0x150>
 800642c:	9b04      	ldr	r3, [sp, #16]
 800642e:	eba0 000a 	sub.w	r0, r0, sl
 8006432:	2240      	movs	r2, #64	; 0x40
 8006434:	4082      	lsls	r2, r0
 8006436:	4313      	orrs	r3, r2
 8006438:	3401      	adds	r4, #1
 800643a:	9304      	str	r3, [sp, #16]
 800643c:	f814 1b01 	ldrb.w	r1, [r4], #1
 8006440:	4825      	ldr	r0, [pc, #148]	; (80064d8 <_svfiprintf_r+0x1ec>)
 8006442:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8006446:	2206      	movs	r2, #6
 8006448:	f7f9 feca 	bl	80001e0 <memchr>
 800644c:	2800      	cmp	r0, #0
 800644e:	d038      	beq.n	80064c2 <_svfiprintf_r+0x1d6>
 8006450:	4b22      	ldr	r3, [pc, #136]	; (80064dc <_svfiprintf_r+0x1f0>)
 8006452:	bb1b      	cbnz	r3, 800649c <_svfiprintf_r+0x1b0>
 8006454:	9b03      	ldr	r3, [sp, #12]
 8006456:	3307      	adds	r3, #7
 8006458:	f023 0307 	bic.w	r3, r3, #7
 800645c:	3308      	adds	r3, #8
 800645e:	9303      	str	r3, [sp, #12]
 8006460:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8006462:	4433      	add	r3, r6
 8006464:	9309      	str	r3, [sp, #36]	; 0x24
 8006466:	e768      	b.n	800633a <_svfiprintf_r+0x4e>
 8006468:	fb0c 3202 	mla	r2, ip, r2, r3
 800646c:	460c      	mov	r4, r1
 800646e:	2001      	movs	r0, #1
 8006470:	e7a6      	b.n	80063c0 <_svfiprintf_r+0xd4>
 8006472:	2300      	movs	r3, #0
 8006474:	3401      	adds	r4, #1
 8006476:	9305      	str	r3, [sp, #20]
 8006478:	4619      	mov	r1, r3
 800647a:	f04f 0c0a 	mov.w	ip, #10
 800647e:	4620      	mov	r0, r4
 8006480:	f810 2b01 	ldrb.w	r2, [r0], #1
 8006484:	3a30      	subs	r2, #48	; 0x30
 8006486:	2a09      	cmp	r2, #9
 8006488:	d903      	bls.n	8006492 <_svfiprintf_r+0x1a6>
 800648a:	2b00      	cmp	r3, #0
 800648c:	d0c6      	beq.n	800641c <_svfiprintf_r+0x130>
 800648e:	9105      	str	r1, [sp, #20]
 8006490:	e7c4      	b.n	800641c <_svfiprintf_r+0x130>
 8006492:	fb0c 2101 	mla	r1, ip, r1, r2
 8006496:	4604      	mov	r4, r0
 8006498:	2301      	movs	r3, #1
 800649a:	e7f0      	b.n	800647e <_svfiprintf_r+0x192>
 800649c:	ab03      	add	r3, sp, #12
 800649e:	9300      	str	r3, [sp, #0]
 80064a0:	462a      	mov	r2, r5
 80064a2:	4b0f      	ldr	r3, [pc, #60]	; (80064e0 <_svfiprintf_r+0x1f4>)
 80064a4:	a904      	add	r1, sp, #16
 80064a6:	4638      	mov	r0, r7
 80064a8:	f3af 8000 	nop.w
 80064ac:	1c42      	adds	r2, r0, #1
 80064ae:	4606      	mov	r6, r0
 80064b0:	d1d6      	bne.n	8006460 <_svfiprintf_r+0x174>
 80064b2:	89ab      	ldrh	r3, [r5, #12]
 80064b4:	065b      	lsls	r3, r3, #25
 80064b6:	f53f af2d 	bmi.w	8006314 <_svfiprintf_r+0x28>
 80064ba:	9809      	ldr	r0, [sp, #36]	; 0x24
 80064bc:	b01d      	add	sp, #116	; 0x74
 80064be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80064c2:	ab03      	add	r3, sp, #12
 80064c4:	9300      	str	r3, [sp, #0]
 80064c6:	462a      	mov	r2, r5
 80064c8:	4b05      	ldr	r3, [pc, #20]	; (80064e0 <_svfiprintf_r+0x1f4>)
 80064ca:	a904      	add	r1, sp, #16
 80064cc:	4638      	mov	r0, r7
 80064ce:	f000 f879 	bl	80065c4 <_printf_i>
 80064d2:	e7eb      	b.n	80064ac <_svfiprintf_r+0x1c0>
 80064d4:	08017b47 	.word	0x08017b47
 80064d8:	08017b51 	.word	0x08017b51
 80064dc:	00000000 	.word	0x00000000
 80064e0:	08006239 	.word	0x08006239
 80064e4:	08017b4d 	.word	0x08017b4d

080064e8 <_printf_common>:
 80064e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80064ec:	4616      	mov	r6, r2
 80064ee:	4699      	mov	r9, r3
 80064f0:	688a      	ldr	r2, [r1, #8]
 80064f2:	690b      	ldr	r3, [r1, #16]
 80064f4:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80064f8:	4293      	cmp	r3, r2
 80064fa:	bfb8      	it	lt
 80064fc:	4613      	movlt	r3, r2
 80064fe:	6033      	str	r3, [r6, #0]
 8006500:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8006504:	4607      	mov	r7, r0
 8006506:	460c      	mov	r4, r1
 8006508:	b10a      	cbz	r2, 800650e <_printf_common+0x26>
 800650a:	3301      	adds	r3, #1
 800650c:	6033      	str	r3, [r6, #0]
 800650e:	6823      	ldr	r3, [r4, #0]
 8006510:	0699      	lsls	r1, r3, #26
 8006512:	bf42      	ittt	mi
 8006514:	6833      	ldrmi	r3, [r6, #0]
 8006516:	3302      	addmi	r3, #2
 8006518:	6033      	strmi	r3, [r6, #0]
 800651a:	6825      	ldr	r5, [r4, #0]
 800651c:	f015 0506 	ands.w	r5, r5, #6
 8006520:	d106      	bne.n	8006530 <_printf_common+0x48>
 8006522:	f104 0a19 	add.w	sl, r4, #25
 8006526:	68e3      	ldr	r3, [r4, #12]
 8006528:	6832      	ldr	r2, [r6, #0]
 800652a:	1a9b      	subs	r3, r3, r2
 800652c:	42ab      	cmp	r3, r5
 800652e:	dc26      	bgt.n	800657e <_printf_common+0x96>
 8006530:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 8006534:	1e13      	subs	r3, r2, #0
 8006536:	6822      	ldr	r2, [r4, #0]
 8006538:	bf18      	it	ne
 800653a:	2301      	movne	r3, #1
 800653c:	0692      	lsls	r2, r2, #26
 800653e:	d42b      	bmi.n	8006598 <_printf_common+0xb0>
 8006540:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8006544:	4649      	mov	r1, r9
 8006546:	4638      	mov	r0, r7
 8006548:	47c0      	blx	r8
 800654a:	3001      	adds	r0, #1
 800654c:	d01e      	beq.n	800658c <_printf_common+0xa4>
 800654e:	6823      	ldr	r3, [r4, #0]
 8006550:	6922      	ldr	r2, [r4, #16]
 8006552:	f003 0306 	and.w	r3, r3, #6
 8006556:	2b04      	cmp	r3, #4
 8006558:	bf02      	ittt	eq
 800655a:	68e5      	ldreq	r5, [r4, #12]
 800655c:	6833      	ldreq	r3, [r6, #0]
 800655e:	1aed      	subeq	r5, r5, r3
 8006560:	68a3      	ldr	r3, [r4, #8]
 8006562:	bf0c      	ite	eq
 8006564:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8006568:	2500      	movne	r5, #0
 800656a:	4293      	cmp	r3, r2
 800656c:	bfc4      	itt	gt
 800656e:	1a9b      	subgt	r3, r3, r2
 8006570:	18ed      	addgt	r5, r5, r3
 8006572:	2600      	movs	r6, #0
 8006574:	341a      	adds	r4, #26
 8006576:	42b5      	cmp	r5, r6
 8006578:	d11a      	bne.n	80065b0 <_printf_common+0xc8>
 800657a:	2000      	movs	r0, #0
 800657c:	e008      	b.n	8006590 <_printf_common+0xa8>
 800657e:	2301      	movs	r3, #1
 8006580:	4652      	mov	r2, sl
 8006582:	4649      	mov	r1, r9
 8006584:	4638      	mov	r0, r7
 8006586:	47c0      	blx	r8
 8006588:	3001      	adds	r0, #1
 800658a:	d103      	bne.n	8006594 <_printf_common+0xac>
 800658c:	f04f 30ff 	mov.w	r0, #4294967295
 8006590:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006594:	3501      	adds	r5, #1
 8006596:	e7c6      	b.n	8006526 <_printf_common+0x3e>
 8006598:	18e1      	adds	r1, r4, r3
 800659a:	1c5a      	adds	r2, r3, #1
 800659c:	2030      	movs	r0, #48	; 0x30
 800659e:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 80065a2:	4422      	add	r2, r4
 80065a4:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 80065a8:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 80065ac:	3302      	adds	r3, #2
 80065ae:	e7c7      	b.n	8006540 <_printf_common+0x58>
 80065b0:	2301      	movs	r3, #1
 80065b2:	4622      	mov	r2, r4
 80065b4:	4649      	mov	r1, r9
 80065b6:	4638      	mov	r0, r7
 80065b8:	47c0      	blx	r8
 80065ba:	3001      	adds	r0, #1
 80065bc:	d0e6      	beq.n	800658c <_printf_common+0xa4>
 80065be:	3601      	adds	r6, #1
 80065c0:	e7d9      	b.n	8006576 <_printf_common+0x8e>
	...

080065c4 <_printf_i>:
 80065c4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 80065c8:	7e0f      	ldrb	r7, [r1, #24]
 80065ca:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 80065cc:	2f78      	cmp	r7, #120	; 0x78
 80065ce:	4691      	mov	r9, r2
 80065d0:	4680      	mov	r8, r0
 80065d2:	460c      	mov	r4, r1
 80065d4:	469a      	mov	sl, r3
 80065d6:	f101 0243 	add.w	r2, r1, #67	; 0x43
 80065da:	d807      	bhi.n	80065ec <_printf_i+0x28>
 80065dc:	2f62      	cmp	r7, #98	; 0x62
 80065de:	d80a      	bhi.n	80065f6 <_printf_i+0x32>
 80065e0:	2f00      	cmp	r7, #0
 80065e2:	f000 80d4 	beq.w	800678e <_printf_i+0x1ca>
 80065e6:	2f58      	cmp	r7, #88	; 0x58
 80065e8:	f000 80c0 	beq.w	800676c <_printf_i+0x1a8>
 80065ec:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80065f0:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 80065f4:	e03a      	b.n	800666c <_printf_i+0xa8>
 80065f6:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 80065fa:	2b15      	cmp	r3, #21
 80065fc:	d8f6      	bhi.n	80065ec <_printf_i+0x28>
 80065fe:	a101      	add	r1, pc, #4	; (adr r1, 8006604 <_printf_i+0x40>)
 8006600:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8006604:	0800665d 	.word	0x0800665d
 8006608:	08006671 	.word	0x08006671
 800660c:	080065ed 	.word	0x080065ed
 8006610:	080065ed 	.word	0x080065ed
 8006614:	080065ed 	.word	0x080065ed
 8006618:	080065ed 	.word	0x080065ed
 800661c:	08006671 	.word	0x08006671
 8006620:	080065ed 	.word	0x080065ed
 8006624:	080065ed 	.word	0x080065ed
 8006628:	080065ed 	.word	0x080065ed
 800662c:	080065ed 	.word	0x080065ed
 8006630:	08006775 	.word	0x08006775
 8006634:	0800669d 	.word	0x0800669d
 8006638:	0800672f 	.word	0x0800672f
 800663c:	080065ed 	.word	0x080065ed
 8006640:	080065ed 	.word	0x080065ed
 8006644:	08006797 	.word	0x08006797
 8006648:	080065ed 	.word	0x080065ed
 800664c:	0800669d 	.word	0x0800669d
 8006650:	080065ed 	.word	0x080065ed
 8006654:	080065ed 	.word	0x080065ed
 8006658:	08006737 	.word	0x08006737
 800665c:	682b      	ldr	r3, [r5, #0]
 800665e:	1d1a      	adds	r2, r3, #4
 8006660:	681b      	ldr	r3, [r3, #0]
 8006662:	602a      	str	r2, [r5, #0]
 8006664:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8006668:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800666c:	2301      	movs	r3, #1
 800666e:	e09f      	b.n	80067b0 <_printf_i+0x1ec>
 8006670:	6820      	ldr	r0, [r4, #0]
 8006672:	682b      	ldr	r3, [r5, #0]
 8006674:	0607      	lsls	r7, r0, #24
 8006676:	f103 0104 	add.w	r1, r3, #4
 800667a:	6029      	str	r1, [r5, #0]
 800667c:	d501      	bpl.n	8006682 <_printf_i+0xbe>
 800667e:	681e      	ldr	r6, [r3, #0]
 8006680:	e003      	b.n	800668a <_printf_i+0xc6>
 8006682:	0646      	lsls	r6, r0, #25
 8006684:	d5fb      	bpl.n	800667e <_printf_i+0xba>
 8006686:	f9b3 6000 	ldrsh.w	r6, [r3]
 800668a:	2e00      	cmp	r6, #0
 800668c:	da03      	bge.n	8006696 <_printf_i+0xd2>
 800668e:	232d      	movs	r3, #45	; 0x2d
 8006690:	4276      	negs	r6, r6
 8006692:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8006696:	485a      	ldr	r0, [pc, #360]	; (8006800 <_printf_i+0x23c>)
 8006698:	230a      	movs	r3, #10
 800669a:	e012      	b.n	80066c2 <_printf_i+0xfe>
 800669c:	682b      	ldr	r3, [r5, #0]
 800669e:	6820      	ldr	r0, [r4, #0]
 80066a0:	1d19      	adds	r1, r3, #4
 80066a2:	6029      	str	r1, [r5, #0]
 80066a4:	0605      	lsls	r5, r0, #24
 80066a6:	d501      	bpl.n	80066ac <_printf_i+0xe8>
 80066a8:	681e      	ldr	r6, [r3, #0]
 80066aa:	e002      	b.n	80066b2 <_printf_i+0xee>
 80066ac:	0641      	lsls	r1, r0, #25
 80066ae:	d5fb      	bpl.n	80066a8 <_printf_i+0xe4>
 80066b0:	881e      	ldrh	r6, [r3, #0]
 80066b2:	4853      	ldr	r0, [pc, #332]	; (8006800 <_printf_i+0x23c>)
 80066b4:	2f6f      	cmp	r7, #111	; 0x6f
 80066b6:	bf0c      	ite	eq
 80066b8:	2308      	moveq	r3, #8
 80066ba:	230a      	movne	r3, #10
 80066bc:	2100      	movs	r1, #0
 80066be:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 80066c2:	6865      	ldr	r5, [r4, #4]
 80066c4:	60a5      	str	r5, [r4, #8]
 80066c6:	2d00      	cmp	r5, #0
 80066c8:	bfa2      	ittt	ge
 80066ca:	6821      	ldrge	r1, [r4, #0]
 80066cc:	f021 0104 	bicge.w	r1, r1, #4
 80066d0:	6021      	strge	r1, [r4, #0]
 80066d2:	b90e      	cbnz	r6, 80066d8 <_printf_i+0x114>
 80066d4:	2d00      	cmp	r5, #0
 80066d6:	d04b      	beq.n	8006770 <_printf_i+0x1ac>
 80066d8:	4615      	mov	r5, r2
 80066da:	fbb6 f1f3 	udiv	r1, r6, r3
 80066de:	fb03 6711 	mls	r7, r3, r1, r6
 80066e2:	5dc7      	ldrb	r7, [r0, r7]
 80066e4:	f805 7d01 	strb.w	r7, [r5, #-1]!
 80066e8:	4637      	mov	r7, r6
 80066ea:	42bb      	cmp	r3, r7
 80066ec:	460e      	mov	r6, r1
 80066ee:	d9f4      	bls.n	80066da <_printf_i+0x116>
 80066f0:	2b08      	cmp	r3, #8
 80066f2:	d10b      	bne.n	800670c <_printf_i+0x148>
 80066f4:	6823      	ldr	r3, [r4, #0]
 80066f6:	07de      	lsls	r6, r3, #31
 80066f8:	d508      	bpl.n	800670c <_printf_i+0x148>
 80066fa:	6923      	ldr	r3, [r4, #16]
 80066fc:	6861      	ldr	r1, [r4, #4]
 80066fe:	4299      	cmp	r1, r3
 8006700:	bfde      	ittt	le
 8006702:	2330      	movle	r3, #48	; 0x30
 8006704:	f805 3c01 	strble.w	r3, [r5, #-1]
 8006708:	f105 35ff 	addle.w	r5, r5, #4294967295
 800670c:	1b52      	subs	r2, r2, r5
 800670e:	6122      	str	r2, [r4, #16]
 8006710:	f8cd a000 	str.w	sl, [sp]
 8006714:	464b      	mov	r3, r9
 8006716:	aa03      	add	r2, sp, #12
 8006718:	4621      	mov	r1, r4
 800671a:	4640      	mov	r0, r8
 800671c:	f7ff fee4 	bl	80064e8 <_printf_common>
 8006720:	3001      	adds	r0, #1
 8006722:	d14a      	bne.n	80067ba <_printf_i+0x1f6>
 8006724:	f04f 30ff 	mov.w	r0, #4294967295
 8006728:	b004      	add	sp, #16
 800672a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800672e:	6823      	ldr	r3, [r4, #0]
 8006730:	f043 0320 	orr.w	r3, r3, #32
 8006734:	6023      	str	r3, [r4, #0]
 8006736:	4833      	ldr	r0, [pc, #204]	; (8006804 <_printf_i+0x240>)
 8006738:	2778      	movs	r7, #120	; 0x78
 800673a:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
 800673e:	6823      	ldr	r3, [r4, #0]
 8006740:	6829      	ldr	r1, [r5, #0]
 8006742:	061f      	lsls	r7, r3, #24
 8006744:	f851 6b04 	ldr.w	r6, [r1], #4
 8006748:	d402      	bmi.n	8006750 <_printf_i+0x18c>
 800674a:	065f      	lsls	r7, r3, #25
 800674c:	bf48      	it	mi
 800674e:	b2b6      	uxthmi	r6, r6
 8006750:	07df      	lsls	r7, r3, #31
 8006752:	bf48      	it	mi
 8006754:	f043 0320 	orrmi.w	r3, r3, #32
 8006758:	6029      	str	r1, [r5, #0]
 800675a:	bf48      	it	mi
 800675c:	6023      	strmi	r3, [r4, #0]
 800675e:	b91e      	cbnz	r6, 8006768 <_printf_i+0x1a4>
 8006760:	6823      	ldr	r3, [r4, #0]
 8006762:	f023 0320 	bic.w	r3, r3, #32
 8006766:	6023      	str	r3, [r4, #0]
 8006768:	2310      	movs	r3, #16
 800676a:	e7a7      	b.n	80066bc <_printf_i+0xf8>
 800676c:	4824      	ldr	r0, [pc, #144]	; (8006800 <_printf_i+0x23c>)
 800676e:	e7e4      	b.n	800673a <_printf_i+0x176>
 8006770:	4615      	mov	r5, r2
 8006772:	e7bd      	b.n	80066f0 <_printf_i+0x12c>
 8006774:	682b      	ldr	r3, [r5, #0]
 8006776:	6826      	ldr	r6, [r4, #0]
 8006778:	6961      	ldr	r1, [r4, #20]
 800677a:	1d18      	adds	r0, r3, #4
 800677c:	6028      	str	r0, [r5, #0]
 800677e:	0635      	lsls	r5, r6, #24
 8006780:	681b      	ldr	r3, [r3, #0]
 8006782:	d501      	bpl.n	8006788 <_printf_i+0x1c4>
 8006784:	6019      	str	r1, [r3, #0]
 8006786:	e002      	b.n	800678e <_printf_i+0x1ca>
 8006788:	0670      	lsls	r0, r6, #25
 800678a:	d5fb      	bpl.n	8006784 <_printf_i+0x1c0>
 800678c:	8019      	strh	r1, [r3, #0]
 800678e:	2300      	movs	r3, #0
 8006790:	6123      	str	r3, [r4, #16]
 8006792:	4615      	mov	r5, r2
 8006794:	e7bc      	b.n	8006710 <_printf_i+0x14c>
 8006796:	682b      	ldr	r3, [r5, #0]
 8006798:	1d1a      	adds	r2, r3, #4
 800679a:	602a      	str	r2, [r5, #0]
 800679c:	681d      	ldr	r5, [r3, #0]
 800679e:	6862      	ldr	r2, [r4, #4]
 80067a0:	2100      	movs	r1, #0
 80067a2:	4628      	mov	r0, r5
 80067a4:	f7f9 fd1c 	bl	80001e0 <memchr>
 80067a8:	b108      	cbz	r0, 80067ae <_printf_i+0x1ea>
 80067aa:	1b40      	subs	r0, r0, r5
 80067ac:	6060      	str	r0, [r4, #4]
 80067ae:	6863      	ldr	r3, [r4, #4]
 80067b0:	6123      	str	r3, [r4, #16]
 80067b2:	2300      	movs	r3, #0
 80067b4:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 80067b8:	e7aa      	b.n	8006710 <_printf_i+0x14c>
 80067ba:	6923      	ldr	r3, [r4, #16]
 80067bc:	462a      	mov	r2, r5
 80067be:	4649      	mov	r1, r9
 80067c0:	4640      	mov	r0, r8
 80067c2:	47d0      	blx	sl
 80067c4:	3001      	adds	r0, #1
 80067c6:	d0ad      	beq.n	8006724 <_printf_i+0x160>
 80067c8:	6823      	ldr	r3, [r4, #0]
 80067ca:	079b      	lsls	r3, r3, #30
 80067cc:	d413      	bmi.n	80067f6 <_printf_i+0x232>
 80067ce:	68e0      	ldr	r0, [r4, #12]
 80067d0:	9b03      	ldr	r3, [sp, #12]
 80067d2:	4298      	cmp	r0, r3
 80067d4:	bfb8      	it	lt
 80067d6:	4618      	movlt	r0, r3
 80067d8:	e7a6      	b.n	8006728 <_printf_i+0x164>
 80067da:	2301      	movs	r3, #1
 80067dc:	4632      	mov	r2, r6
 80067de:	4649      	mov	r1, r9
 80067e0:	4640      	mov	r0, r8
 80067e2:	47d0      	blx	sl
 80067e4:	3001      	adds	r0, #1
 80067e6:	d09d      	beq.n	8006724 <_printf_i+0x160>
 80067e8:	3501      	adds	r5, #1
 80067ea:	68e3      	ldr	r3, [r4, #12]
 80067ec:	9903      	ldr	r1, [sp, #12]
 80067ee:	1a5b      	subs	r3, r3, r1
 80067f0:	42ab      	cmp	r3, r5
 80067f2:	dcf2      	bgt.n	80067da <_printf_i+0x216>
 80067f4:	e7eb      	b.n	80067ce <_printf_i+0x20a>
 80067f6:	2500      	movs	r5, #0
 80067f8:	f104 0619 	add.w	r6, r4, #25
 80067fc:	e7f5      	b.n	80067ea <_printf_i+0x226>
 80067fe:	bf00      	nop
 8006800:	08017b58 	.word	0x08017b58
 8006804:	08017b69 	.word	0x08017b69

08006808 <memmove>:
 8006808:	4288      	cmp	r0, r1
 800680a:	b510      	push	{r4, lr}
 800680c:	eb01 0402 	add.w	r4, r1, r2
 8006810:	d902      	bls.n	8006818 <memmove+0x10>
 8006812:	4284      	cmp	r4, r0
 8006814:	4623      	mov	r3, r4
 8006816:	d807      	bhi.n	8006828 <memmove+0x20>
 8006818:	1e43      	subs	r3, r0, #1
 800681a:	42a1      	cmp	r1, r4
 800681c:	d008      	beq.n	8006830 <memmove+0x28>
 800681e:	f811 2b01 	ldrb.w	r2, [r1], #1
 8006822:	f803 2f01 	strb.w	r2, [r3, #1]!
 8006826:	e7f8      	b.n	800681a <memmove+0x12>
 8006828:	4402      	add	r2, r0
 800682a:	4601      	mov	r1, r0
 800682c:	428a      	cmp	r2, r1
 800682e:	d100      	bne.n	8006832 <memmove+0x2a>
 8006830:	bd10      	pop	{r4, pc}
 8006832:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8006836:	f802 4d01 	strb.w	r4, [r2, #-1]!
 800683a:	e7f7      	b.n	800682c <memmove+0x24>

0800683c <_sbrk_r>:
 800683c:	b538      	push	{r3, r4, r5, lr}
 800683e:	4d06      	ldr	r5, [pc, #24]	; (8006858 <_sbrk_r+0x1c>)
 8006840:	2300      	movs	r3, #0
 8006842:	4604      	mov	r4, r0
 8006844:	4608      	mov	r0, r1
 8006846:	602b      	str	r3, [r5, #0]
 8006848:	f7ff fb4a 	bl	8005ee0 <_sbrk>
 800684c:	1c43      	adds	r3, r0, #1
 800684e:	d102      	bne.n	8006856 <_sbrk_r+0x1a>
 8006850:	682b      	ldr	r3, [r5, #0]
 8006852:	b103      	cbz	r3, 8006856 <_sbrk_r+0x1a>
 8006854:	6023      	str	r3, [r4, #0]
 8006856:	bd38      	pop	{r3, r4, r5, pc}
 8006858:	20001720 	.word	0x20001720

0800685c <memcpy>:
 800685c:	440a      	add	r2, r1
 800685e:	4291      	cmp	r1, r2
 8006860:	f100 33ff 	add.w	r3, r0, #4294967295
 8006864:	d100      	bne.n	8006868 <memcpy+0xc>
 8006866:	4770      	bx	lr
 8006868:	b510      	push	{r4, lr}
 800686a:	f811 4b01 	ldrb.w	r4, [r1], #1
 800686e:	f803 4f01 	strb.w	r4, [r3, #1]!
 8006872:	4291      	cmp	r1, r2
 8006874:	d1f9      	bne.n	800686a <memcpy+0xe>
 8006876:	bd10      	pop	{r4, pc}

08006878 <_realloc_r>:
 8006878:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800687c:	4680      	mov	r8, r0
 800687e:	4614      	mov	r4, r2
 8006880:	460e      	mov	r6, r1
 8006882:	b921      	cbnz	r1, 800688e <_realloc_r+0x16>
 8006884:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8006888:	4611      	mov	r1, r2
 800688a:	f7ff bc49 	b.w	8006120 <_malloc_r>
 800688e:	b92a      	cbnz	r2, 800689c <_realloc_r+0x24>
 8006890:	f7ff fbda 	bl	8006048 <_free_r>
 8006894:	4625      	mov	r5, r4
 8006896:	4628      	mov	r0, r5
 8006898:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800689c:	f000 f81b 	bl	80068d6 <_malloc_usable_size_r>
 80068a0:	4284      	cmp	r4, r0
 80068a2:	4607      	mov	r7, r0
 80068a4:	d802      	bhi.n	80068ac <_realloc_r+0x34>
 80068a6:	ebb4 0f50 	cmp.w	r4, r0, lsr #1
 80068aa:	d812      	bhi.n	80068d2 <_realloc_r+0x5a>
 80068ac:	4621      	mov	r1, r4
 80068ae:	4640      	mov	r0, r8
 80068b0:	f7ff fc36 	bl	8006120 <_malloc_r>
 80068b4:	4605      	mov	r5, r0
 80068b6:	2800      	cmp	r0, #0
 80068b8:	d0ed      	beq.n	8006896 <_realloc_r+0x1e>
 80068ba:	42bc      	cmp	r4, r7
 80068bc:	4622      	mov	r2, r4
 80068be:	4631      	mov	r1, r6
 80068c0:	bf28      	it	cs
 80068c2:	463a      	movcs	r2, r7
 80068c4:	f7ff ffca 	bl	800685c <memcpy>
 80068c8:	4631      	mov	r1, r6
 80068ca:	4640      	mov	r0, r8
 80068cc:	f7ff fbbc 	bl	8006048 <_free_r>
 80068d0:	e7e1      	b.n	8006896 <_realloc_r+0x1e>
 80068d2:	4635      	mov	r5, r6
 80068d4:	e7df      	b.n	8006896 <_realloc_r+0x1e>

080068d6 <_malloc_usable_size_r>:
 80068d6:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80068da:	1f18      	subs	r0, r3, #4
 80068dc:	2b00      	cmp	r3, #0
 80068de:	bfbc      	itt	lt
 80068e0:	580b      	ldrlt	r3, [r1, r0]
 80068e2:	18c0      	addlt	r0, r0, r3
 80068e4:	4770      	bx	lr
	...

080068e8 <_init>:
 80068e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80068ea:	bf00      	nop
 80068ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80068ee:	bc08      	pop	{r3}
 80068f0:	469e      	mov	lr, r3
 80068f2:	4770      	bx	lr

080068f4 <_fini>:
 80068f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80068f6:	bf00      	nop
 80068f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80068fa:	bc08      	pop	{r3}
 80068fc:	469e      	mov	lr, r3
 80068fe:	4770      	bx	lr
